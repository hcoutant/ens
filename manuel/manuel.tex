%
% Texte de l'annexe
%
% Historique
%   1987/??/?? : pda : conception
%   1991/??/?? : jt  : traduction en LaTeX
%   1991/02/07 : pda : conception de la partie socket
%   1992/01/09 : pda : intégration des sockets berkeley
%   1992/01/09 : pda : début des IPC System V
%   1992/01/12 : pda : intégration des IPC System V
%   1992/01/12 : pda : ajout puis mise en commentaire des fonctions BSD
%   1992/01/22 : pda : rédaction des fonctions BSD
%   1992/07/22 : pda : intégration des remarques de jt sur les sockets
%   1992/12/13 : pda : page de garde
%   1993/01/25 : pda : passage en a5
%   1993/11/06 : pda : début des signaux POSIX
%   1995/02/03 : pda : actualisation
%   1996/09/18 : pda : actualisation pour 1996/97
%   1997/08/29 : pda : actualisation pour 1997/98
%   1997/08/29 : pda : actualisation pour 97/98 (ajout des recommandations}
%   1997/08/31 : pda : conversion a LaTeX2e
%   1997/09/23 : pda : intégration des docs de purify et purecoverage
%   2012/04/20 : pda : obsolescence des fonctions gets/strcpy/etc.
%   2012/04/20 : pda : obsolescence des fonctions inet_ntoa/etc seulement IPv4
%   2015/12/23 : pda : ajout hyperref
%   2015/12/23 : pda : ajout strftime & co
%

\documentclass [twoside] {report}
    \usepackage {makeidx}

    \usepackage [francais] {babel}
    \usepackage [utf8] {inputenc}
    \usepackage [T1] {fontenc}
    \usepackage {times}
    \renewcommand {\ttdefault}{cmtt}
    \usepackage {supertabular}
    \usepackage [a4paper, margin=20mm] {geometry}
    \usepackage {hyperref}

    \raggedbottom	% par défaut, babel aligne les bas de page. Pas bôôôôô !

    \setlength {\parskip} {2mm}
    \setlength {\parindent} {0mm}

    \makeindex
    \renewcommand {\arraystretch} {1.1}

    \newcommand {\tassertoc} {{ \setlength {\parskip} {0cm} \tableofcontents }}


    \newcommand {\primitive} [1]
    {
	\phantomsection
	{\large \bf #1}
	\addcontentsline {toc} {subsection} {#1}
    }

    \newcommand {\separation}
    {
	\vspace {5mm}
	\nopagebreak
	\hrule
    }

\begin {document}

\thispagestyle {empty}

\begin {titlepage}
    \input {ue}

    \vfill

    \begin {center}
	\huge\bf
	Notice simplifiée \\
	\vspace* {5mm}
	Primitives système et fonctions de librairie \\
	\vspace* {5mm}
	\input {annee}
    \end {center}

    \vfill

    \begin {flushright}
	Pierre David
    \end {flushright}
\end {titlepage}

\cleardoublepage
\tassertoc


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% LES APPELS SYSTEME
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\chapter {Les appels système}


L'accès aux services du système Unix est réalisée
au moyen des {\it appels système}, encore appelés
{\it primitives système}.

Ces primitives sont l'outil de plus bas niveau
dont dispose le programmeur. Quand cela est
possible, il est généralement préférable d'utiliser
les fonctions de la bibliothèque standard.


La liste ci-dessous donne une classification de
ces appels par catégorie. Ce sont~:

\begin {itemize}
    \item les numéros d'erreur (catégorie spéciale),
    \item l'accès aux fichiers,
    \item la gestion des processus,
    \item les tubes, les signaux V7 et POSIX,
    \item l'horloge du système,
    \item les disques et les périphériques,
    \item les sockets Berkeley,
    \item les IPC System V, et
    \item les éternels inclassables...
\end {itemize}

Cette classification ne prétend pas être
rigoureuse. Certains appels auraient pu être dans
plusieurs catégories, il a bien fallu choisir.
D'autre part, cette liste n'est pas exhaustive,
mais elle donne néanmoins toutes les primitives
utiles à l'élaboration des applications.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Erreurs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Définition des erreurs}


La plupart des primitives système renvoient une valeur au programme
appelant. En général, il s'agit d'une valeur
positive ou nulle pour une exécution normale, ou
de la valeur -1 lorsqu'il y a eu une erreur. Dans
ce dernier cas, la variable globale {\tt errno}
indique le numéro de l'erreur intervenue, et
permet donc une plus grande précision dans le
diagnostic.

La déclaration de la variable {\tt errno} est~:

\begin {quote}
\begin {verbatim}
#include <errno.h>
extern int errno ;
\end{verbatim}
\end {quote}

L'accès à la signification en clair de ces
messages d'erreur se fait souvent par
l'intermédiaire des fonctions {\tt perror}
ou \texttt {strerror} de la
librairie standard.

La liste suivante est la description
des principales erreurs pouvant intervenir. Il faut noter que
la variable {\tt errno} n'est pas remise à 0 avant un
appel système. Ceci implique donc que sa valeur ne
doit être testée que si l'appel signale une
erreur au moyen de la valeur de retour.

{\tt EPERM}~: Not owner \\
Survient typiquement lors d'une
tentative de modification d'une donnée interdite.

{\tt ENOENT}~: No such file or directory \\
Survient lorsqu'un fichier est spécifié et que ce
fichier n'existe pas, ou lorsqu'un chemin d'accès
un fichier spécifie un répertoire inexistant.

{\tt ESRCH}~: No such process \\
Survient lorsque le processus ne peut être trouvé
par {\tt kill}, {\tt ptrace}, ou lorsque le processus
n'est pas accessible.

{\tt EINTR}~: Interrupted system call \\
Un signal asynchrone (interruption de
l'utilisateur par exemple) traité par
l'utilisateur est arrivé pendant un appel système.
Si l'exécution reprend après l'appel système, la
valeur de retour indiquera une erreur.

{\tt EIO}~: I/O error \\
Survient lors d'une erreur d'entrée sortie.

{\tt ENXIO}~: No such device or address \\
Survient lorsqu'une entrée sortie est demandé sur
un périphérique qui n'est pas en ligne ou lorsque
l'entrée sortie dépasse la capacité du
périphérique.

{\tt E2BIG}~: Arg list too long \\
Survient lorsqu'une liste d'arguments ou
d'environnement est plus grande que la longueur
supportée lors d'un {\tt exec}.

{\tt ENOEXEC}~: Exec format error \\
Survient lorsqu'{\tt exec} ne reconnaît pas le
format du fichier demandé.

{\tt EBADF}~: Bad file number \\
Survient lorsqu'un descripteur de fichier ne
réfère aucun fichier ouvert, ou lorsqu'une
écriture est demandée sur un fichier ouvert en
lecture seule, ou vice-versa.

{\tt ECHILD}~: No child process \\
Survient lorsqu'un {\tt wait} est demandé et
qu'aucun processus fils n'existe.

{\tt EAGAIN}~: No more process \\
Survient lorsque {\tt fork} ne peut trouver une
entrée disponible dans la table des processus, ou
lorsque l'utilisateur a dépassé son quota de
processus.

{\tt ENOMEM}~: Not enough space \\
Survient lorsqu'un processus demande plus de
place que ce que le système est capable de lui
fournir.

{\tt EACCES}~: Permission denied \\
Une tentative a été faite pour accéder à un
fichier interdit.

{\tt EFAULT}~: Bad address \\
Survient lorsque le système a généré une trappe matérielle en
essayant d'utiliser un mauvais argument d'un
appel.

{\tt ENOTBLK}~: Block device requested \\
Survient lorsqu'un fichier de type autre que
{\it block device} est transmis à {\tt mount}.

{\tt EBUSY}~: Device or resource busy \\
Survient lorsqu'un péripérique ou une ressource
est déjà occupée (fichier actif lors d'un
{\tt mount} par exemple), ou lorsqu'un mode est déjà
activé ({\tt acct}).

{\tt EEXIST}~: File exists \\
Survient lorsqu'un fichier existant est mentionné
dans un contexte non approprié (par exemple
{\tt link}).

{\tt EXDEV}~: Cross-device link \\
Survient lorsqu'un lien est demandé entre deux
systèmes de fichiers.

{\tt ENODEV}~: No such device \\
Survient lorsqu'un appel système est inapproprié
au périphérique, comme par exemple une lecture sur
un périphérique en écriture seulement.

{\tt ENOTDIR}~: Not a directory \\
Survient lorsqu'un répertoire est nécessaire et
n'est pas fourni à l'appel système, comme par
exemple un argument à {\tt chdir}.

{\tt EISDIR}~: Is a directory \\
Survient lors d'une tentative d'ouverture dans un
fichier de type répertoire.

{\tt EINVAL}~: Invalid argument \\
Quelques arguments invalides et inclassables.

{\tt ENFILE}~: File table overflow \\
La table centrale des fichiers ouverts est
pleine, et il n'est plus possible pour l'instant
d'accepter des {\tt open}.

{\tt EMFILE}~: Too many open files \\
Survient lorsqu'un processus essaye de dépasser
son quota de fichiers ouverts.

{\tt ENOTTY}~: Not a typewriter \\
Survient lorsque la primitive {\tt ioctl} est
inappropriée pour le périphérique.

{\tt ETXTBSY}~: Text file busy \\
Survient lors d'une tentative d'exécution d'un
fichier exécutable ouvert en écriture, ou
vice-versa.

{\tt EFBIG}~: File too large \\
Survient lorsque la taille du fichier dépasse la
taille maximum permise par le système.

{\tt ENOSPC}~: No space left on device \\
Survient lors d'une écriture dans un fichier
ordinaire, quand il n'y a plus de place sur le
périphérique.

{\tt ESPIPE}~: Illegal seek \\
Survient lors d'un {\tt lseek} sur un tube.

{\tt EROFS}~: Read-only file system \\
Survient lors d'une tentative de modification sur
un fichier ou un répertoire d'un système de
fichiers monté en lecture seulement.

{\tt EMLINK}~: Too many links \\
Survient lorsqu'un {\tt link} dépasse 1000 liens
pour le fichier.

{\tt EPIPE}~: Broken pipe \\
Survient lors d'une écriture dans un tube sans
lecteur. Cette condition génère normalement un
signal. L'erreur est renvoyée si le signal est
ignoré.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Définition des types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Définition des types}

Certaines primitives et fonctions de librairie utilisent des paramètres
représentant des identificateurs de processus, des numéros d'utilisateur
ou d'autres informations.  Même s'il s'agit le plus souvent d'entiers,
il est intéressant d'utiliser des types définis pour faciliter la
lisibilité et la portabilité des programmes. Pour fixer les idées, voici
les principaux types utilisés~:

\begin {itemize}
    \item {\tt clock\_t} (entier long non signé)~: nombre de tops
	d'horloge (voir {\tt sysconf}, page~\pageref {sysconf})
    \item {\tt dev\_t} (entier long)~: numéro (mineur et majeur) de
	périphérique
    \item {\tt gid\_t} (entier long)~: identificateur de groupe
    \item {\tt ino\_t} (entier long non signé)~: numéro d'inode
    \item {\tt jmp\_buf} (tableau)~: buffer pour {\tt setjmp} et {\tt
	longjmp}
    \item {\tt key\_t} (entier long)~: clef utilisée pour les IPC System~V
    \item {\tt mode\_t} (entier court non signé)~: permissions associées
	à un fichier
    \item {\tt off\_t} (entier long)~: déplacement dans un fichier
    \item {\tt pid\_t} (entier long)~: identificateur de processus
    \item {\tt sigset\_t} (tableau)~: bitmap utilisée pour les signaux POSIX
    \item {\tt size\_t} (entier non signé)~: nombre d'octets
    \item {\tt ssize\_t} (entier)~: nombre d'octets signé
    \item {\tt time\_t} (entier long)~: nombre de secondes écoulées
	depuis le premier janvier 1970.
    \item {\tt uid\_t} (entier long)~: identificateur d'utilisateur
\end {itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Accès aux fichiers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Accès aux fichiers}


Les primitives d'accès aux fichiers sont de deux
ordres~:
\begin {itemize}
    \item accès au contenu d'un fichier,
    \item accès au descripteur ({\it inode}).
\end {itemize}

Il y a deux façons d'accéder à un fichier. La première nécessite un
chemin d'accès au fichier, c'est-à-dire son nom sous forme d'une chaîne
de caractères terminée par un octet nul.  La deuxième nécessite
l'ouverture préalable du fichier, c'est-à-dire nécessite un petit
entier obtenu par les primitives {\tt open}, {\tt creat}, {\tt dup},
{\tt fcntl} ou {\tt pipe}.

La deuxième méthode est la seule possible pour
accéder à la partie données d'un fichier. Notons
que trois fichiers sont automatiquement ouverts~:
0 pour l'entrée standard, 1 pour la sortie
standard, et 2 pour les erreurs.





\separation
\primitive {access} --- détermine l'accessibilité d'un fichier
    \index{{\tt access}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int access (const char *nom, int motif)
\end{verbatim}
\end {quote}

La primitive {\tt access} vérifie l'accessibilité
du fichier en comparant le motif binaire avec les
protections du fichier. La comparaison est
réalisée avec les identificateurs d'utilisateur et
de groupe {\it réels} et non avec les identificateurs
{\it effectifs}.

Le motif binaire est construit à partir des bits
suivants~:
\begin {quote}
    \begin {tabular} {|lll|} \hline
	\verb|R_OK| & 04 & lecture \\
	\verb|W_OK| & 02 & écriture \\
	\verb|X_OK| & 01 & exécution \\
	\verb|F_OK| & 00 & vérifier que le fichier existe \\ \hline
    \end {tabular}
\end {quote}

Par exemple, \verb/access("toto",R_OK|W_OK)/ teste à la fois
l'accessibilité en lecture et en écriture au fichier de nom {\tt toto}.

Cette primitive renvoie 0 si l'accès est permis
ou -1 en cas d'erreur.




\separation
\primitive {chmod} --- change les protections d'un fichier
    \index{{\tt chmod}}

\begin {quote}
\begin {verbatim}
int chmod (const char *nom, mode_t mode)
\end{verbatim}
\end {quote}

La primitive {\tt chmod} change les droits d'accès
d'un fichier, suivant le motif binaire contenu
dans {\tt mode}~:

\begin {quote}
    \begin {tabular} {|lll|} \hline
	\tt S\_ISUID & 04000 & bit {\it set user id} \\
	\tt S\_IGUID & 02000 & bit {\it set group id} \\
	             & 01000 & bit {\it sticky bit} \\
	\tt S\_IRWXU & 00700 & droits pour le propriétaire \\
	\tt S\_IRUSR & 00400 & lecture pour le propriétaire \\
	\tt S\_IWUSR & 00200 & écriture pour le propriétaire \\
	\tt S\_IXUSR & 00100 & exécution pour le propriétaire \\
	\tt S\_IRWXG & 00070 & lecture, écriture et exécution pour le groupe \\
	\tt S\_IRGRP & 00040 & lecture pour le groupe \\
	\tt S\_IWGRP & 00020 & écriture pour le groupe \\
	\tt S\_IXGRP & 00010 & exécution pour le groupe \\
	\tt S\_IRWXO & 00007 & lecture, écriture et exécution pour les autres \\
	\tt S\_IROTH & 00004 & lecture pour les autres \\
	\tt S\_IWOTH & 00002 & écriture pour les autres \\
	\tt S\_IXOTH & 00001 & exécution pour les autres \\ \hline
    \end {tabular}
\end {quote}

Par exemple, \verb/chmod("toto",S_IRUSR|S_IWUSR|S_IRGRP)/ est
équivalent, mais plus portable, à \verb/chmod("toto",0640)/.

Seul le propriétaire du fichier (ou le
super-utilisateur) a le droit de modifier les
droits d'accès d'un fichier.

Cette primitive renvoie 0 en cas de modification
réussie ou -1 en cas d'erreur.




\separation
\primitive {chown} --- change le propriétaire d'un fichier
    \index{{\tt chown}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int chown (const char *nom, uid_t proprietaire, gid_t groupe)
\end{verbatim}
\end {quote}

La primitive {\tt chown} change le propriétaire et
le groupe d'un fichier.

Seul le propriétaire d'un fichier (ou le super
utilisateur) peut changer ces informations.

Cette primitive renvoie 0 en cas de modification
réussie ou -1 en cas d'erreur.




\separation
\primitive {close} --- ferme un fichier
    \index{{\tt close}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int close (int desc)
\end{verbatim}
\end {quote}

La primitive {\tt close} ferme le fichier associé
au descripteur {\tt desc}, obtenu par {\tt open},
{\tt creat}, {\tt dup}, {\tt fcntl} ou {\tt pipe}.

Cette primitive renvoie 0 en cas de modification
réussie ou -1 en cas d'erreur.




\separation
\primitive {creat} --- crée et ouvre un fichier
    \index{{\tt creat}}

\begin {quote}
\begin {verbatim}
#include <fcntl.h>

int creat (const char *nom, mode_t mode)
\end{verbatim}
\end {quote}

La primitive {\tt creat} crée un nouveau fichier,
l'ouvre en écriture et renvoie un descripteur de
fichier.

Si le fichier existait déjà, sa longueur est
remise à 0 et ses protections sont inchangées.
Sinon, le fichier est créé avec les protections
spécifiées par le motif binaire {\tt mode} (voir
{\tt chmod}) et le masque de création de fichier
(voir {\tt umask}).

Cette primitive renvoie le descripteur de fichier
(non négatif) en cas de création et d'ouverture
réussies, ou -1 en cas d'erreur.




\separation
\primitive {dup, dup2} --- duplique un descripteur de fichier
    \index{{\tt dup}}
    \index{{\tt dup2}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int dup (int ancien)
int dup2 (int ancien, int nouveau)
\end{verbatim}
\end {quote}

La primitive {\tt dup} duplique le descripteur de
fichier {\tt ancien} (obtenu par {\tt open}, {\tt creat},
{\tt dup}, {\tt fcntl} ou {\tt pipe}), et retourne le
nouveau descripteur, partageant les
caractéristiques suivantes avec l'original~:

\begin {itemize}
    \item même fichier ouvert,
    \item même pointeur de fichier,
    \item même mode d'accès (lecture, écriture), et
    \item même état de fichier (voir {\tt fcntl}).
\end {itemize}

Le nouveau descripteur retourné est le plus petit
disponible, et est marqué comme {\it préservé lors
d'un exec}.

La primitive {\tt dup2} duplique le descripteur {\tt ancien} et
l'affecte au descripteur {\tt nouveau}. Si le descripteur {\tt nouveau}
référençait un fichier ouvert, celui-ci est d'abord fermé.

Ces primitive renvoient le nouveau descripteur de fichier
(non négatif) en cas de duplication
réussie, ou -1 en cas d'erreur.




\separation
\primitive {fcntl} --- contrôle un fichier ouvert
    \index{{\tt fcntl}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>
#include <fcntl.h>

int fcntl (int desc, int cmd, ...)
\end{verbatim}
\end {quote}

La primitive {\tt fcntl} fournit un moyen
d'agir sur des fichiers ouverts par
l'intermédiaire de
{\tt desc} (obtenu par {\tt open}, {\tt creat}, {\tt dup},
{\tt fcntl} ou {\tt pipe}).

Les commandes disponibles sont~:

\begin {itemize}
    \item {\tt F\_DUPFD}~: renvoie un nouveau descripteur de
	fichier, de manière comparable à {\tt dup}.

    \item {\tt F\_GETFD}~: renvoie le flag {\it fermeture lors
	d'un exec}. Si le bit de poids faible est nul, le
	fichier restera ouvert lors d'un {\tt exec}.

    \item {\tt F\_SETFD}~: modifie le flag {\it fermeture lors
	d'un exec}, suivant la valeur ci-dessus.

    \item {\tt F\_GETFL}~: renvoie les flags du fichier.

    \item {\tt F\_SETFL}~: modifie les flags du fichier.

    \item {\tt F\_GETLK}~:  lit le premier verrou qui bloque l'accès à
	la portion de fichier décrite par le troisième argument (de type
	pointeur sur {\tt struct flock}), et retourne ses
	caractéristiques à la place.

    \item {\tt F\_SETLK}~:  pose (ou annule) un verrou sur une portion
	du fichier, décrite par le troisième argument (de type pointeur
	sur {\tt struct flock}).  Si le verrou ne peut être modifié
	immédiatement, {\tt fcntl} renvoie -1.

    \item {\tt F\_SETLKW}~:  pose (ou annule) un verrou sur une portion
	du fichier, décrite par le troisième argument (de type pointeur
	sur {\tt struct flock}).  Si le verrou ne peut être modifié
	immédiatement, {\tt fcntl} attend que le verrou précédent soit
	libéré.

\end {itemize}


Les flags du fichier qui peuvent être lus ou modifiés sont~:

{\small
\begin {quote}
    \begin {tabular} {|ll|} \hline
	\tt O\_RDONLY & ouverture en lecture seulement \\
	\tt O\_WRONLY & ouverture en écriture seulement \\
	\tt O\_RDWR & ouverture en lecture et en écriture \\
	\tt O\_NDELAY & mode non bloquant \\
	\tt O\_APPEND & accès uniquement à la fin du fichier \\
	\tt O\_SYNCIO & accès aux fichiers en mode {\em write through}
	    \\ \hline
    \end {tabular}
\end {quote}
}

Les verrous sont décrits par une structure {\tt flock}, dont les champs
sont les suivants~:

\begin {quote}
\begin {verbatim}
short   l_type;     /* F_RDLCK, F_WRLCK ou F_UNLCK */
short   l_whence;   /* origine du deplacement - voir lseek */
off_t   l_start;    /* deplacement relatif en octets */
off_t   l_len;      /* taille; tout le fichier si 0 */
pid_t   l_pid;      /* Processus ayant le verrou (F_GETLK) */
\end{verbatim}
\end {quote}

La valeur retournée par {\tt flock} dépend de l'action, mais est
toujours non négative en cas de réussite, ou
-1 en cas d'erreur.




\separation
\primitive {getdirentries} --- lit des entrées dans un répertoire
    \index{{\tt getdirentries}}

\begin {quote}
\begin {verbatim}
#include <dirent.h>

int getdirentries (int fd, struct direct *buf, int taille, off_t *offset)
\end{verbatim}
\end {quote}

Cette primitive renvoie des entrées dans un répertoire dans une
forme indépendante du format natif du répertoire ouvert par {\tt open}.
Les entrées sont placées dans un tableau de structures {\tt direct},
chacune de ces structures contenant~:

\begin {itemize}
    \item {\tt unsigned long d\_fileno}~:  numéro unique du fichier
	(exemple~:  numéro d'inode si le fichier est sur un disque
	local)~;
    \item {\tt unsigned short d\_reclen}~: longueur en octets de l'entrée
	dans le répertoire~;
    \item {\tt unsigned short d\_namlen}~: longueur en octets du nom, y
	compris le caractère nul terminal~;
    \item {\tt char d\_name}~: tableau de caractères de longueur {\tt
	MAXNAMELEN+1} contenant le nom, terminé par un caractère nul.

\end {itemize}

Le nombre d'entrées dans le tableau {\tt buf} est déduit de la taille en
octets {\tt taille} de l'ensemble du tableau {\tt buf}. Cette taille
doit être supérieure ou égale à la taille du bloc du système de
fichiers.

Le paramètre {\tt offset} contient en retour la position courante du bloc
lu.

La valeur de retour est le nombre d'octets transférés en cas d'opération
réussie, -1 sinon.

Note~:  cette primitive n'étant pas spécifiée par POSIX, les
fonctions {\tt opendir}, {\tt readdir} etc.  de la librairie doivent
être utilisées de préférence (voir page~\pageref {opendir}).


\separation
\primitive {link} --- établit un nouveau lien sur un fichier
    \index{{\tt link}}

\begin {quote}
\begin {verbatim}
int link (const char *nom, const char *nouveaunom)
\end{verbatim}
\end {quote}

La primitive {\tt link} crée un nouveau lien pour
fichier existant de nom {\tt nom}. Le nouveau lien
(la nouvelle entrée dans le répertoire) porte
le nom {\tt nouveaunom}.

Cette primitive renvoie 0 en cas de liaison
réussie ou -1 en cas d'erreur.




\separation
\primitive {lseek} --- déplace le pointeur de lecture/écriture d'un fichier
    \index{{\tt lseek}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

off_t lseek (int desc, off_t deplacement, int apartir)
\end{verbatim}
\end {quote}

La primitive {\tt lseek} déplace le pointeur du
fichier repéré par {\tt desc} (obtenu par
{\tt open},{\tt creat}, {\tt dup}, {\tt fctnl} ou {\tt pipe}).
Le déplacement est régi par par la valeur de
{\tt àpartir}~:

\begin {quote}
    \begin {tabular} {|lll|} \hline
	\tt SEEK\_SET & 0 & à partir du début \\
	\tt SEEK\_CUR & 0 & à partir de la position courante \\
	\tt SEEK\_END & 0 & à partir de la fin \\ \hline
    \end {tabular}
\end {quote}

Cette primitive renvoie le nouveau pointeur en cas
de déplacement réussi, ou -1 (plus exactement \verb|((off_t)-1)|)
en cas d'erreur.




\separation
\primitive {mkdir} --- crée un répertoire
    \index{{\tt mkdir}}

\begin {quote}
\begin {verbatim}
#include <sys/stat.h>

int mkdir (const char *nom, mode_t mode)
\end{verbatim}
\end {quote}

La primitive {\tt mkdir} crée le répertoire de nom {\tt nom}. Les 
protections initiales sont spécifiée en binaire avec l'argument {\tt
mode} (voir {\tt chmod}).

Cette primitive renvoie 0 en cas de création réussie
ou -1 en cas d'erreur.




\separation
\primitive {open} --- ouvre un fichier
    \index{{\tt open}}

\begin {quote}
\begin {verbatim}
#include <sys/stat.h>
#include <fcntl.h>

int open (const char *nom, int flags)
int open (const char *nom, int flags, mode_t mode)
\end{verbatim}
\end {quote}

La primitive {\tt open} ouvre un fichier et renvoie
son descripteur. Si le fichier doit être créé,
{\tt mode} spécifie ses protections (voir {\tt chmod}).

L'état du fichier est initialisé à la valeur de
{\tt flags}, construite à partir des bits suivants
(les trois premiers sont mutuellement exclusifs)~:

\begin {itemize}
    \item {\tt O\_RDONLY}~: ouverture en lecture seulement,
    \item {\tt O\_WRONLY}~: ouverture en écriture seulement,
    \item {\tt O\_RDWR}~: ouverture en lecture et écriture,
    \item {\tt O\_NDELAY}~: affectera les lectures ou
	écritures (voir {\tt read} et {\tt write}),
    \item {\tt O\_APPEND}~: le pointeur est déplacé à la fin du fichier,
    \item {\tt O\_CREAT}~: le fichier est créé s'il n'existait pas
	(dans ce cas, le mode est initialisé à partir du paramètre {\tt mode}),
    \item {\tt O\_TRUNC}~: si le fichier existe, sa taille est remise à 0,
    \item {\tt O\_EXCL}~: si {\tt O\_EXCL} et {\tt O\_CREAT} sont mis,
	{\tt open} échoue si le fichier existe,
    \item {\tt O\_NOCTTY}~: si le fichier est un terminal, {\tt open}
	n'essaiera pas de l'utiliser comme terminal de contrôle,
    \item {\tt O\_NONBLOCK}~: le fichier (spécial ou fifo) est ouvert en
	mode non bloquant,
\end {itemize}

Cette primitive renvoie le descripteur de fichier
(non négatif) en cas d'ouverture
réussie, ou -1 en cas d'erreur.




\separation
\primitive {read} --- lit dans un fichier
    \index{{\tt read}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

ssize_t read (int desc, void *buf, size_t nombre)
\end{verbatim}
\end {quote}

La primitive {\tt read} lit {\tt nombre} octets dans
le fichier associé au descripteur {\tt desc}
(retourné par {\tt open}, {\tt creat}, {\tt dup}, {\tt fcntl}
ou {\tt pipe}) et les place à partir de l'adresse
{\tt buf}.

La valeur renvoyée est le nombre d'octets lus et
stockés dans {\tt buf}. Cette valeur peut être
inférieure à {\tt nombre} si~:
\begin {itemize}
    \item le descripteur {\tt desc} est associé à une ligne
	de communication, ou
    \item il ne reste pas assez d'octets dans le fichier
	pour satisfaire la demande.
\end {itemize}

Deux cas spéciaux~:

\begin {enumerate}
    \item lecture dans un tube vide~: si le flag {\tt O\_NDELAY}
	est spécifié lors de l'ouverture ou avec {\tt fcntl},
	la lecture renverra 0, sinon la lecture
	sera bloquante jusqu'à ce que le tube ne soit plus
	vide ou qu'il n'y ait plus de processus qui y écrive.
    \item lecture d'une ligne de communications sur
	laquelle il n'y a pas de données~: si le flag {\tt O\_NDELAY}
	est spécifié, la lecture renverra 0, sinon la lecture
	sera bloquante jusqu'à ce que des données
	deviennent disponibles.
\end {enumerate}

Cette primitive renvoie le nombre d'octets lus
(non négatif) en cas de lecture
réussie, ou -1 en cas d'erreur.




\separation
\primitive {rmdir} --- supprime un répertoire
    \index{{\tt rmdir}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int rmdir (const char *nom)
\end{verbatim}
\end {quote}

La primitive {\tt rmdir} supprime le répertoire (qui doit être vide)
spécifié par l'argument {\tt nom}.

Cette primitive renvoie 0 en cas de suppression réussie
ou -1 en cas d'erreur.




\separation
\primitive {stat, fstat} --- consulte le descripteur d'un fichier
    \index{{\tt stat}}
    \index{{\tt fstat}}
    \label {stat}

\begin {quote}
\begin {verbatim}
#include <sys/stat.h>

int stat (const char *nom, struct stat *buf)
int fstat (int desc, struct stat *buf)
\end{verbatim}
\end {quote}

Les primitives {\tt stat} et {\tt fstat} lisent la partie système d'un
fichier (son {\it inode}) et placent ces informations dans la structure
pointée par {\tt buf}. Le fichier peut être spécifié par son nom
({\tt stat}) ou par le descripteur de fichier qui lui est associé
({\tt fstat}).

Le contenu de la structure {\tt buf} est défini
comme suit~:

\begin {quote}
\begin {verbatim}
dev_t  st_dev ;
ino_t  st_ino ;
ushort st_mode ;
short  st_nlink ;
ushort st_uid ;
ushort st_gid ;
dev_t  st_rdev ;
off_t  st_size ;
time_t st_atime ;
time_t st_mtime ;
time_t st_ctime ;
\end{verbatim}
\end {quote}

\begin {itemize}
    \item {\tt st\_dev}~: le périphérique contenant le fichier,
    \item {\tt st\_ino}~: numéro d'inode,
    \item {\tt st\_mode}~: type et protections du fichier
    \item {\tt st\_nlink}~: nombre de liens,
    \item {\tt st\_uid} et {\tt st\_gid}~: numéros de propriétaire et de groupe,
    \item {\tt st\_rdev}~: identification du périphérique dans le cas
	d'un fichier spécial (bloc ou caractère),
    \item {\tt st\_size}~: taille du fichier en octets,
    \item {\tt st\_blksize}~: taille optimale des entrées/sorties
    \item {\tt st\_atime}~: date du dernier accès ({\tt creat},
	{\tt mknod}, {\tt pipe}, {\tt utime} et {\tt read}).
    \item {\tt st\_mtime}~: date de la dernière modification
	({\tt creat}, {\tt mknod}, {\tt pipe}, {\tt utime} et {\tt write}).
    \item {\tt st\_ctime}~: date de la dernière modification
	de l'état du fichier ({\tt chmod}, {\tt chown}, {\tt creat},
	{\tt link}, {\tt mknod}, {\tt pipe}, {\tt rmdir}, {\tt unlink},
	{\tt utime} et {\tt write}).
\end {itemize}

Le champ {\tt st\_mode} est composé de~:

\begin {itemize}
    \item 12 bits de poids faible pour les droits d'accès au fichier
	(voir {\tt chmod})
    \item plusieurs bits de poids fort pour le type du fichier. Ces bits
	peuvent être extraits avec le masque binaire {\tt S\_IFMT} (dans
	{\tt stat.h}) et comparés avec les valeurs suivantes (les valeurs
	numériques sont fournies pour l'exemple et ne sont valides que
	sur SunOS)~:

	\begin {tabular} {|lll|} \hline
	    \tt S\_IFREG & 0100000 & fichier ordinaire \\
	    \tt S\_IFBLK & 0060000 & fichier périphérique (mode bloc) \\
	    \tt S\_IFCHR & 0020000 & fichier périphérique (mode caractère) \\
	    \tt S\_IFDIR & 0040000 & répertoire \\
	    \tt S\_IFIFO & 0010000 & tube ou tube nommé \\
	    \tt S\_IFLNK & 0120000 & lien symbolique \\
	    \tt S\_IFSOCK & 0140000 & socket \\
	    \hline
	\end {tabular}

	Il est également possible de tester le type du fichier avec~:

	\begin {tabular} {|ll|} \hline
	    \tt S\_ISREG({\em mode}) & fichier ordinaire \\
	    \tt S\_ISBLK({\em mode}) & fichier périphérique (mode bloc) \\
	    \tt S\_ISCHR({\em mode}) & fichier périphérique (mode caractère) \\
	    \tt S\_ISDIR({\em mode}) & répertoire \\
	    \tt S\_ISFIFO({\em mode}) & tube ou tube nommé \\
	    \hline
	\end {tabular}

\end {itemize}

Cette primitive renvoie 0 en cas d'accès réussi
ou -1 en cas d'erreur.




\separation
\primitive {unlink} --- supprime le fichier (enlève un lien)
    \index{{\tt unlink}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int unlink (const char *nom)
\end{verbatim}
\end {quote}

La primitive {\tt unlink} supprime une des entrées
de répertoire du fichier. Lorsque toutes les
entrées sont supprimées, c'est-à-dire lorsque le
nombre de liens devient nul, le fichier est
physiquement effacé et l'espace occupé est ainsi
libéré.

Cette primitive renvoie 0 en cas de suppression
réussie ou -1 en cas d'erreur.




\separation
\primitive {write} --- écrit dans un fichier
    \index{{\tt write}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

ssize_t write (int desc, const void *buf, size_t nombre)
\end{verbatim}
\end {quote}

La primitive {\tt write} écrit {\tt nombre} octets à
partir de l'adresse pointée par {\tt buf} dans le
fichier associé au descripteur {\tt desc} (obtenu par
{\tt open}, {\tt creat}, {\tt dup}, {\tt fcntl} ou {\tt pipe}).

Si le flag {\tt O\_APPEND} est mis, le pointeur de
fichier sera mis à la fin du fichier avant toute
écriture.

Le nombre renvoyé par {\tt write} est le nombre
d'octets réellement écrits dans le fichier. Ce
nombre peut être inférieur à {\tt nombre}, si la
limite du fichier (voir {\tt ulimit}) ou du volume
est atteinte.

Si le fichier est un tube et si le flag
{\tt O\_NDELAY} est mis, alors l'écriture ne sera pas
complète s'il n'y a pas assez de place dans le
tube.

Cette primitive renvoie le nombre d'octets écrits
(non négatif) en cas d'écriture
réussie, ou -1 en cas d'erreur.


\separation
\primitive {mmap} --- établit une correspondance entre fichier et mémoire
    \index{{\tt mmap}}

\begin {quote}
\begin {verbatim}
#include <sys/mman.h>

void *mmap (void *adr, size_t lg, int prot, int flags, int fd, int offset)
\end{verbatim}
\end {quote}

La primitive {\tt mmap} établit une correspondance entre un fichier
ouvert et une zone de mémoire virtuelle : l'octet à l'offset $i$ du
fichier est accessible en mémoire à l'adresse indiquée par \texttt
{adr}$+i$. Toute lecture mémoire à cette adresse provoquera la lecture
dans le fichier à l'offset correspondant, et toute écriture à cette
adresse provoquera une écriture dans le fichier.

Si le paramètre \texttt {adr} vaut \texttt {NULL}, le système choisit
l'adresse où placer la zone de mémoire virtuelle et renvoie cette
adresse comme valeur de retour. La longueur de la zone est spécifiée
par le paramètre \texttt {lg}. Le fichier est référencé par son
descripteur \texttt {fd}, et l'offset de début dans le fichier est
indiqué par le paramètre \texttt {offset} (qui doit être un multiple
de la taille d'une page, voir le paramètre \texttt {SC\_PAGE\_SIZE}
de {\tt sysconf} page~\pageref {sysconf}). Si le paramètre \texttt {lg}
n'est pas un multiple de la taille d'une page, le système peut étendre
la zone jusqu'au plus prochain multiple.

Le paramètre \texttt {prot} spécifie le type d'accès mémoire
souhaité, par une combinaison des bits suivants~:

\begin {quote}
    \begin {tabular} {|ll|} \hline
	\tt PROT\_NONE & aucun accès autorisé \\
	\tt PROT\_READ & accès en lecture \\
	\tt PROT\_WRITE & accès en écriture \\
	\tt PROT\_EXEC & accès en exécution \\
	\hline
    \end {tabular}
\end {quote}

Le paramètre \texttt {flags} doit obligatoirement inclure l'un des deux
bits suivants~:

\begin {itemize}
    \item \texttt {MAP\_SHARED}~: les modifications sont partagées entre
	tous les processus ayant établi une correspondance avec le
	fichier~;
    \item \texttt {MAP\_PRIVATE}~: les modifications effectuées ne sont
	pas propagées dans le fichier, et ne sont pas visibles par les
	autres processus ayant établi une correspondance avec le fichier.

\end {itemize}

De plus, le comportement de \texttt {mmap} peut être modifié par des
bits supplémentaires dans le paramètre \texttt {flags}, parmi lesquels~:

\begin {itemize}
    \item \texttt {MAP\_ANONYMOUS}~: la zone de mémoire n'est pas mise
	en correspondance avec un fichier (et donc les paramètres
	\texttt {fd} et \texttt {offset} doivent valoir respectivement
	-1 et 0).  Ceci permet d'avoir une zone de mémoire partagée
	entre plusieurs processus (ce qui implique l'utilisation du bit
	\texttt {MAP\_SHARED})~;

    \item \texttt {MAP\_FIXED}~: avec ce bit, \texttt {mmap} interprète
	une adresse (paramètre \texttt {adr}) non nulle comme une
	adresse impérative, et non comme une indication où placer la
	zone de mémoire virtuelle.

\end {itemize}

L'utilisation de tout autre bit pour le paramètre \texttt {flag} est
par essence non portable et doit donc être évitée (par exemple en
ayant recours à d'autres primitives similaires).

Cette primitive renvoie l'adresse de la zone de mémoire virtuelle, ou
la valeur \texttt {MAP\_FAILED} (-1) en cas d'erreur.


\separation
\primitive {munmap} --- supprime une correspondance entre fichier et mémoire
    \index{{\tt munmap}}

\begin {quote}
\begin {verbatim}
#include <sys/mman.h>

int munmap (void *adr, size_t lg)
\end{verbatim}
\end {quote}

La primitive {\tt munmap} supprime une correspondance entre un fichier
ouvert et une zone de mémoire virtuelle établie par \texttt {mmap}.

Cette primitive renvoie 0 en cas de suppression réussie, ou -1 en
cas d'erreur.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gestion des processus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Gestion des processus}


Un nombre important de primitives système sont
dédiées à la gestion des processus.

La seule méthode pour créer un nouveau processus
est la primitive {\tt fork}. La seule méthode pour
exécuter un fichier est une des primitives
{\tt exec}.

Chaque processus a un certain nombre
d'attributs, tels que le répertoire courant,
l'identificateur d'utilisateur, etc. Certaines
primitives permettent de les consulter, certaines
de les changer.


\separation
\primitive {chdir} --- change le répertoire courant
    \index{{\tt chdir}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int chdir (const char *nom)
\end{verbatim}
\end {quote}

La primitive {\tt chdir} change le répertoire
courant du processus, c'est-à-dire le point de
départ des chemins relatifs.

Cette primitive renvoie 0 en cas de changement
réussi, ou -1 en cas d'erreur.




\separation
\primitive {chroot} --- change le répertoire racine
    \index{{\tt chroot}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int chroot (const char *nom)
\end{verbatim}
\end {quote}

La primitive {\tt chroot} change le répertoire
racine du processus, c'est-à-dire le point de
départ des chemins absolus. Le répertoire courant
n'est pas affecté par cette opération.

L'utilisateur {\em effectif} doit être le super
utilisateur pour pouvoir utiliser cet appel.

Cette primitive renvoie 0 en cas de changement
réussi, ou -1 en cas d'erreur.




\separation
\primitive {exec} --- exécute un fichier
    \index{{\tt exec}}
    \index{{\tt execl}}
    \index{{\tt execv}}
    \index{{\tt execlp}}
    \index{{\tt execvp}}
    \index{{\tt execle}}
    \index{{\tt execve}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int execl (char *chemin, char *arg0, char *arg1, ... char *argn, (char *) 0)
int execv (char *chemin, char *argv [])
int execle (char *chemin, char *arg0, char *arg1, ... char *argn, (char *) 0, char *envp [])
int execve (char *chemin, char *argv [], char *envp [])
int execlp (char *fichier, char *arg0, char *arg1, ... char *argn, (char *) 0)
int execvp (char *fichier, char *argv [])
\end{verbatim}
\end {quote}

Les primitives de la famille {\tt exec} chargent un
programme contenu dans un fichier exécutable,
qu'il soit binaire ou interprétable par un
{\em shell}.

Lorsqu'un programme C est exécuté, il est appelé
comme suit~:

\begin {quote}
\begin {verbatim}
extern char **environ ;

int main (int argc, char *argv [])
{
    ...
}
\end{verbatim}
\end {quote}

où {\tt argc} est le nombre d'arguments, {\tt argv}
est un tableau de pointeurs sur les arguments
eux-mêmes. {\tt environ} est une variable globale,
tableau de pointeurs sur les variables de l'environnement.

Les descripteurs de fichiers marqués {\it fermeture
lors d'un exec} sont fermés automatiquement.

Les signaux positionnés pour provoquer la terminaison
du programme ou pour être ignorés restent
inchangés. En revanche, les signaux positionnés
pour être attrapés sont remis à leur valeur par
défaut.

Si le bit {\it set user id} du fichier exécutable
est mis, l'utilisateur {\it effectif} est changé en le
propriétaire du fichier. L'utilisateur {\it réel}
reste inchangé. Ceci n'est pas valide pour les
scripts, pour lesquels le bit {\it set user id} est
ignoré.

Les segments de mémoire partagés du programme
appelant ne sont pas transmis.

La mesure des temps d'exécution par {\tt profil} est
invalidée.

Le nouveau programme hérite des caractéristiques
suivantes~:
\begin {itemize}
    \item valeur de {\tt nice},
    \item identificateur de processus,
    \item identificateur de groupe de processus,
%    \item valeur de {\it semadj} (voir {\tt semop}),
    \item identificateur de groupe tty (voir {\tt exit} et {\tt signal}),
    \item flag de trace (voir {\tt ptrace}),
    \item durée d'une alarme (voir {\tt alarm}),
    \item répertoire courant,
    \item répertoire racine,
    \item masque de protections (voir {\tt umask}),
    \item limites de taille de fichiers (voir {\tt ulimit}), et
    \item temps d'exécution du processus.
\end {itemize}

Un {\it script shell} commence par une ligne de la
forme {\tt \#!{\it shell}}, où {\tt \#!} doivent être les deux
premiers caractères. Le shell doit être
complètement spécifié, il n'y a pas de recherche à
l'aide de PATH.

Les diverses formes de {\tt exec} permettent de
spécifier un fichier sans se soucier de son chemin
d'accès complet, de passer ou non l'environnement
de manière automatique, et de choisir la méthode
de passage des paramètres. Le tableau ci-dessous
résume les 6 possibilités~:

\begin {center}
    \begin {tabular} {|c|c|c|c|}
	\hline
	\multicolumn {1}{|c|}{primitive} &
	\multicolumn {1}{|c|}{mode passage} &
	\multicolumn {1}{|c|}{passage environnement} &
	\multicolumn {1}{|c|}{recherche PATH} \\
	\hline
	\hline
	execl	&    liste	& automatique &  non \\
	execv	&  vecteur	& automatique &  non \\
	execle	&    liste	&      manuel &  non \\
	execve	&  vecteur	&      manuel &  non \\
	execlp	&    liste	& automatique &  oui \\
	execvp	&  vecteur	& automatique &  oui \\
	\hline
    \end {tabular}
\end {center}


Si ces primitives retournent à l'appelant, une erreur est
arrivée. La valeur renvoyée est donc toujours -1.




\separation
\primitive {exit} --- termine un processus
    \index{{\tt exit}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

void exit (int etat)
\end{verbatim}
\end {quote}

La primitive {\tt exit} termine l'exécution du
processus appelant et passe l'argument {\tt etat} au
système pour inspection. Cet argument est
utilisable par {\tt wait}. Utiliser {\tt return} dans la
fonction {\tt main} d'un programme C a le même effet
que {\tt exit}.

{\tt Etat} est indéfini si {\tt exit} n'a pas de
paramètre.

A la terminaison du processus, les actions
suivantes sont effectuées~:

\begin {itemize}
\item tous les fichiers sont fermés,
\item si le processus père est dans la primitive
{\tt wait}, il est réveillé et la valeur de {\tt état}
(les 8 bits de poids faible) est transmise,
\item si le processus père n'exécute pas {\tt wait} et
s'il n'ignore pas le signal {\tt SIGCLD}, le
processus fils devient {\it zombie},
\item le processus 1 devient le père de tous les
processus fils du processus appelant,
\item tous les segments de mémoire partagée sont
détachés,
\item si un des segments du processus était
verrouillé en mémoire, il est déverrouillé (voir
{\tt plock}),
\item une ligne de mesure (voir {\tt acct}) est écrite
si le système de surveillance est mis,
\item si les identificateurs de processus, de groupe
de processus et de groupe de terminal sont égaux,
le signal {\tt SIGHUP} est envoyé à tous les
processus partageant le même groupe de
processus.
\end {itemize}

Cette primitive ne renvoie pas de code de
retour...




\separation
\primitive {fork} --- crée un nouveau processus
    \index{{\tt fork}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

pid_t fork (void)
\end{verbatim}
\end {quote}

La primitive {\tt fork} crée un nouveau processus
(le processus {\it fils})
par duplication du processus appelant (le
processus {\it père}). Le fils hérite des
caractéristiques suivantes~:

\begin {itemize}
    \item environnement,
    \item flags de {\it fermeture lors d'un exec} de tous les fichiers,
    \item traitement des signaux,
    \item bits {\it set user id} et {\it set group id},
    \item mesure des fonctions (voir {\tt profil}),
    \item valeur de {\tt nice},
    \item tous les segments de mémoire partagée,
    \item identificateur de groupe de processus,
    \item identificateur de groupe de terminaux (voir {\tt exit} et
	{\tt signal}),
    \item flag de trace (voir {\tt ptrace}),
    \item répertoire courant,
    \item répertoire racine,
    \item masque de protections (voir {\tt umask}), et
    \item limites de taille de fichiers (voir {\tt ulimit}).
\end {itemize}

Le processus fils diffère du processus père par
les points suivants~:

\begin {itemize}
    \item le fils a un identificateur de processus unique,
    \item le fils a un identificateur de processus père différent,
    \item le fils a ses propres descripteurs de
	fichiers, mais partage les pointeurs dans ces fichiers,
    \item tous les segments du processus sont
	déverrouillés, et
    \item les temps d'exécution sont mis à 0.
\end {itemize}

En cas de duplication réussie, cette primitive
renvoie 0 pour le processus fils, et
l'identificateur du processus fils pour le père.
En cas d'erreur, la valeur -1 est renvoyée.





\separation
\primitive {getpid, getpgrp, getppid} --- renvoie les process-id
    \index{{\tt getpgrp}}
    \index{{\tt getppid}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

pid_t getpid (void)
pid_t getpgrp (void)
pid_t getppid (void)
\end{verbatim}
\end {quote}

La primitive {\tt getpid} renvoie l'identificateur
du processus appelant.

La primitive {\tt getpgrp} renvoie l'identificateur
du groupe de processus auquel appartient le
processus parent.

La primitive {\tt getppid} renvoie l'identificateur
du processus père du processus appelant.




\separation
\primitive {getuid, geteuid, getgid, getegid} --- renvoie les process-id effectifs
    \index{{\tt getuid}}
    \index{{\tt geteuid}}
    \index{{\tt getgid}}
    \index{{\tt getegid}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

uid_t getuid (void)
uid_t geteuid (void)
gid_t getgid (void)
gid_t getegid (void)
\end{verbatim}
\end {quote}

La primitive {\tt getuid} renvoie l'identificateur
de l'utilisateur {\it réel} du processus.

La primitive {\tt geteuid} renvoie l'identificateur
de l'utilisateur {\it effectif} du processus.

La primitive {\tt getgid} renvoie l'identificateur
du groupe {\it réel} du processus.

La primitive {\tt getegid} renvoie l'identificateur
du groupe {\it effectif} du processus.




\separation
\primitive {nice} --- change la priorité d'un processus
    \index{{\tt nice}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int nice (int increment)
\end{verbatim}
\end {quote}

La primitive {\tt nice} ajoute la valeur de
{\tt incrément} à la valeur de {\tt nice} du processus
appelant. La valeur de {\tt nice} d'un processus est
une valeur entière qui indique une priorité
CPU d'autant plus faible que la valeur est grande.

Cette valeur est comprise en 0 et 39. Toute
tentative de modification hors de ces valeurs
ramènera la valeur à la limite correspondante.

Seul le super utilisateur a le droit de diminuer
la valeur de {\tt nice}.

Cette primitive renvoie la nouvelle valeur de
{\tt nice} moins 20, ou -1 en cas d'erreur. Il faut
noter que certaine valeur de {\tt nice} renvoie une
valeur assimilable au cas d'erreur.




\separation
\primitive {plock} --- verrouille un segment en mémoire
    \index{{\tt plock}}

\begin {quote}
\begin {verbatim}
#include <sys/lock.h>

int plock (int requete)
\end{verbatim}
\end {quote}

La primitive {\tt plock} sert à verrouiller en
mémoire le segment {\it text} ({\it text lock}), le
segment {\it data} ({\it data lock}) ou les segments
{\it text} et {\it data} ({\it process lock}) du processus
appelant.

Les segments verrouillés en mémoire sont
insensibles aux routines de {\it swap}.

Le choix du segment à verrouiller ou du
déverrouillage est réalisé grâce au paramètre
{\tt requête}~:

\begin {itemize}
    \item {\tt PROCLOCK}~: verrouille les segments {\it text} et {\it data},
    \item {\tt TXTLOCK}~: verrouille le segment {\it text},
    \item {\tt DATLOCK}~: verrouille le segment {\it data}, et
    \item {\tt UNLOCK}~: enlève les verrous.
\end {itemize}

Cette primitive renvoie 0 en cas de verrouillage
ou déverrouillage réussi, ou -1 en cas d'erreur.




\separation
\primitive {setpgrp, setsid} --- change l'identificateur de session
    \index{{\tt setpgrp}}
    \index{{\tt setsid}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

pid_t setpgrp (void)
pid_t setsid (void)
\end{verbatim}
\end {quote}

La primitive {\tt setpgrp} modifie l'identificateur du groupe
de processus et le met à la valeur de l'identificateur du
processus appelant.

La primitive {\tt setsid} crée une nouvelle session, et retourne
l'identificateur de groupe de processus créé.

Ces primitives renvoient la valeur du nouvel identificateur
de groupe de processus, ou -1 en cas d'erreur.




\separation
\primitive {setuid, setgid} --- change les identificateurs d'utilisateur et de groupe
    \index{{\tt setuid}}
    \index{{\tt setgid}}

\begin {quote}
\begin {verbatim}
int setuid (uid_t uid)
int setgid (gid_t gid)
\end{verbatim}
\end {quote}

La primitive {\tt setuid} change les identificateurs
{\it réel}, {\it effectif} et {\it sauvé} (ruid, euid ou
suid respectivement) suivant les conditions
ci-dessous (en fonction de su, l'identificateur du
super utilisateur)~:

\begin {itemize}
\item si {\tt uid} = ruid = su, alors euid~:= {\tt uid},
\item si {\tt uid} {$\neq$} su et {\tt uid} = euid alors ruid~:=~{\tt uid},
\item si {\tt uid} {$\neq$} su et {\tt uid} = suid alors euid~:=~{\tt uid},
\item si euid = su alors ruid~:=~euid~:=~suid~:=~{\tt uid}.
\end {itemize}

La primitive {\tt setgid} opère de même pour les
identificateurs de groupe.

Ces primitives renvoient 0 en cas de modification
réussie, ou -1 en cas d'erreur.




\separation
\primitive {wait, waitpid} --- attend la terminaison d'un processus fils
    \index{{\tt wait}}
    \index{{\tt waitpid}}

\begin {quote}
\begin {verbatim}
#include <sys/wait.h>

pid_t wait (int *statut)
pid_t waitpid (pid_t pid, int *statut, int options)
\end{verbatim}
\end {quote}

La primitive {\tt wait} suspend l'exécution du
processus appelant jusqu'à ce qu'un de ses fils
directs se termine ou soit stoppé sur un point
d'arrêt.

Cette primitive retourne prématurément à la
réception d'un signal. Si un fils avait déjà
terminé, le retour est immédiat.

Si le paramètre {\tt statut} est non nul, 16 bits
d'information sont stockés dans les 16 bits de
poids faible situés à l'adresse indiquée. Ils
servent à distinguer entre un processus stoppé et
un processus terminé, de la manière suivante~:

{\small
\begin {center}
    \begin {tabular} {|p{25mm}|p{25mm}|p{25mm}|p{25mm}|} \cline {2-4}
	\multicolumn {1}{c|}{} & 
	    \multicolumn {1}{|c|}{code retour} &
	    \multicolumn {1}{|c|}{poids fort} &
	    \multicolumn {1}{|c|}{poids faible}
	    \\ \hline
	processus stoppé en mode trace &
	    identificateur~du pro\-ces\-sus &
	    numéro du signal &
	    \multicolumn {1}{|c|}{0177}
	    \\ \hline
	processus terminé par exit &
	    identificateur~du pro\-ces\-sus &
	    argument de exit sur 8 bits &
	    \multicolumn {1}{|c|}{0}
	    \\ \hline
	processus terminé par signal &
	    identificateur~du pro\-ces\-sus &
	    \multicolumn {1}{|c|}{0} &
	    numéro du signal (+0200 si core)
	    \\ \hline
	wait~interrompue par signal &
	    \multicolumn {1}{|c|}{-1} &
	    \multicolumn {1}{|c|}{?} &
	    \multicolumn {1}{|c|}{?}
	    \\ \hline 
    \end {tabular}
\end {center}
}

La manière portable pour analyser les code de retour consiste à
utiliser les macros suivantes~:

{\small
\begin {quote}
    \begin {tabular} {|l|p{70mm}|} \hline
	\tt WIFEXITED({\em stat\_val}) &
	    renvoie vrai si le processus s'est terminé par un {\tt
	    exit} explicite ou implicite
	    \\ \hline
	\tt WEXITSTATUS({\em stat\_val}) &
	    dans le cas précédent, renvoie le code de retour
	    \\ \hline
	\tt WIFSIGNALED({\em stat\_val}) &
	    renvoie vrai si le processus s'est terminée à cause
	    d'un signal
	    \\ \hline
	\tt WTERMSIG({\em stat\_val}) &
	    dans le cas précédent, renvoie le signal en question
	    \\ \hline
	\tt WIFSTOPPED({\em stat\_val}) &
	    renvoie vrai si le processus est stoppé
	    d'un signal
	    \\ \hline
	\tt WSTOPSIG({\em stat\_val}) &
	    dans le cas précédent, renvoie le signal en question
	    \\ \hline
    \end {tabular}
\end {quote}
}

La primitive {\tt waitpid} fonctionne de manière anlogue à {\tt wait},
à ceci près qu'elle peut attendre des conditions plus spécifiques, selon
la valeur du paramètre {\tt pid}~:

\begin {itemize}
    \item {\tt pid} $= -1$ :  attendre n'importe quel
	processus (similaire à {\tt wait})~;

    \item {\tt pid} $> 0$ :  attendre le processus
	spécifié par {\tt pid} et seulement celui-là~;

    \item {\tt pid} $= 0$ :  attendre n'importe quel
	processus du groupe de processus courant~;

    \item {\tt pid} $< -1$ :  attendre n'importe quel
	processus du groupe d'identificateur {\tt -pid}.

\end {itemize}

Le paramètre {\tt option} peut contenir les bits suivants~:

{\small
\begin {quote}
    \begin {tabular} {|l|p{90mm}|} \hline
	\tt WNOHANG &
	    {\tt waitpid} n'est pas bloquant, et la valeur 0 est renvoyée
	    si aucun processus fils n'est terminé ou stoppé.
	    \\ \hline
	\tt WUNTRACED &
	    {\tt waitpid} détecte les processus stoppés mais non tracés
	    (avec {\tt ptrace}).
	    \\ \hline
    \end {tabular}
\end {quote}
}

Ces primitives renvoient l'identificateur du
processus si l'attente s'est bien déroulée, ou -1
en cas d'erreur ou d'interruption par un signal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tubes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Tubes}

Les tubes sont un moyen de communication entre processus.  Une fois
un tube créé, on peut utiliser les primitives système {\tt read}
et {\tt write}, comme pour n'importe quel descripteur de fichier.

Une lecture est bloquante tant que le tube est vide, sauf s'il n'y a
plus d'écrivain, c'est-à-dire de processus ayant le tube ouvert en
écriture. Lorsqu'il n'y a plus d'écrivain et que le tube est vide,
le tube simule une fin de fichier.

Si lire dans un tube sans écrivain ne représente pas une erreur,
écrire dans un tube sans lecteur est incohérent. Pour signaler
cela, le système envoie le signal {\tt SIGPIPE} dans ce cas.

On rencontre deux sortes de tubes : les tubes anonymes et
les tubes nommés. Les premiers sont créés à l'aide de la
primitive système {\tt pipe}, alors que les seconds sont créés par
la fonction de librairie {\tt mkfifo} (voir page~\pageref {mkfifo}).


\separation
\primitive {pipe} --- crée un canal de communication
    \index{{\tt pipe}}

\begin {quote}
\begin {verbatim}
int pipe (int tubedesc [2])
\end{verbatim}
\end {quote}

La primitive {\tt pipe} crée un tube anonyme,
puis place dans {\tt tubedesc[0]}
le descripteur utilisé pour lire depuis le tube, et dans {\tt
tubedesc[1]} le descripteur utilisé pour écrire dans le tube.

Cette primitive renvoie 0 en cas d'ouverture
réussie, ou -1 en cas d'erreur.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Signaux V7
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Signaux V7}


Les signaux sont un mécanisme comparable aux interruptions
matérielles. Ils permettent à un processus de réagir à un
événement extérieur (appui sur la touche d'interruption,
déconnexion, etc.) ou provoqué par un autre processus.

Un processus choisit avec la primitive {\tt signal}
le type de réaction aux événements ultérieurs~:

\begin {itemize}
    \item ignorer le signal,
    \item faire l'action définie par défaut par le
	système (généralement la terminaison du processus),
    \item ou interrompre l'exécution du programme pour exécuter
	une fonction définie, avec retour au programme après
	la fin de la fonction.
\end {itemize}

Les principaux signaux sont~:

\begin {itemize}
    \label {ps:sigv7}
    \item {\tt SIGHUP}~: déconnection,
    \item {\tt SIGINT}~: interruption (touche [BREAK]),
    \item {\tt SIGQUIT}{$^1$}~: abandon (touche [CTL]{[ $\backslash$ ]}),
    \item {\tt SIGILL}{$^{1, 3}$}~: instruction illégale,
    \item {\tt SIGTRAP}{$^{1, 3}$}~: trace trap,
    \item {\tt SIGIOT}{$^1$}~: instruction IOT,
    \item {\tt SIGEMT}{$^1$}~: instruction EMT,
    \item {\tt SIGFPE}{$^1$}~: exception en calcul flottant,
    \item {\tt SIGKILL}{$^4$}~: kill (non masquable ni interceptable),
    \item {\tt SIGBUS}{$^1$}~: erreur mémoire,
    \item {\tt SIGSEGV}{$^1$}~: violation de segment,
    \item {\tt SIGSYS}~: argument incorrect dans une primitive. Non utilisé,
    \item {\tt SIGPIPE}~: écriture dans un tube sans lecteur,
    \item {\tt SIGALRM}~: alarme
    \item {\tt SIGTERM}~: signal logiciel de terminaison,
    \item {\tt SIGUSR1}~: user defined signal 1,
    \item {\tt SIGUSR2}~: user defined signal 2,
    \item {\tt SIGCLD}{$^2$}~: mort d'un fils, et
    \item {\tt SIGPWR}{$^{3, 2}$}~: chute de tension.
\end {itemize}

Notes~: \\
1~: une image de la mémoire peut être sauvegardée dans
un fichier nommée {\tt core}. \\
2~: l'action par défaut est ignorer le
signal, plutôt que terminer le processus. \\
3~: l'action n'est pas remise à l'action par
défaut lorsque le signal arrive. \\
4~: ce signal ne peut être ni ignoré, ni traité.

Si un signal survient (et provoque un déroutement
vers une fonction) pendant l'exécution des primitives
{\tt open},
{\tt read},
{\tt write},
{\tt sendto},
{\tt recvfrom},
{\tt sendmsg},
{\tt recvmsg},
{\tt wait} ou
{\tt ioctl},
la primitive peut renvoyer une erreur ({\tt errno} = {\tt EINTR}),
ou le transfert de données peut être abrégé suivant le cas.



\separation
\primitive {alarm} --- initialise l'interruption d'horloge
    \index{{\tt alarm}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

unsigned int alarm (unsigned int secondes)
\end{verbatim}
\end {quote}

La primitive {\tt alarm} initialise l'horloge pour
générer le signal {\tt SIGALRM} dans {\tt secondes}
secondes.

L'alarme sera envoyée avec une tolérance de plus ou
moins une demi seconde. De plus, le mécanisme
d'allocation du processeur peut retarder la
réception du signal, particulièrement si le
processus n'est pas en train de s'exécuter au
moment ou le signal est envoyé.

Les alarmes ne sont pas empilées. Un nouvel appel
à {\tt alarm} annule la précédente. Une alarme nulle
annule l'alarme précédente si elle existait.

Les alarmes ne sont pas transmises lors d'un
{\tt fork}.

Cette primitive renvoie le temps restant avant la
précédente alarme.




\separation
\primitive {kill} --- envoie un signal à un processus
    \index{{\tt kill}}
    \label {kill}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int kill (pid_t pid, int signal)
\end{verbatim}
\end {quote}

La primitive {\tt kill} envoie un signal à un
processus ou à un groupe de processus spécifié par
le paramètre {\tt pid}. Le signal à envoyer est
spécifié par le paramètre {\tt signal}.

Si {\tt signal} est nul, aucun signal n'est envoyé,
mais une vérification est faite
sur le paramètre {\tt pid}.

Si {\tt pid} est nul, le signal est est envoyé à tous
les processus du même groupe que le processus
appelant.

Si {\tt pid} = -1, le signal est envoyé à tous les
processus dont le propriétaire est le propriétaire
{\it effectif} du processus courant.

Si {\tt pid} est négatif, mais différent de -1, le
signal est envoyé à tous les processus dont le
groupe est égal à la valeur absolue de {\tt pid}.

Cette primitive renvoie 0 si le signal a été
envoyé, ou -1 en cas d'erreur.




\separation
\primitive {pause} --- suspend le processus en attendant un signal
    \index{{\tt pause}}

\begin {quote}
\begin {verbatim}
int pause (void)
\end{verbatim}
\end {quote}

La primitive {\tt pause} suspend l'exécution du
processus jusqu'à ce qu'il reçoive un signal. Le
signal ne doit pas être ignoré pour réveiller le
processus.

Si le signal provoque la terminaison du
processus, la primitive {\tt pause} ne retourne pas à
l'appelant.

Si le signal est traité par la processus
appelant, et la fonction de traitement retourne,
le processus reprend l'exécution après le point de
suspension.

Etant donné que cette primitive attend indéfiniment jusqu'à
ce qu'elle soit interrompue, la valeur de retour est toujours -1.



\separation
\primitive {signal} --- spécifie le traitement à effectuer à l'arrivée d'un signal
    \index{{\tt signal}}

\begin {quote}
\begin {verbatim}
#include <signal.h>

void (*signal (int sig, void (*action) (int))) (int)
\end{verbatim}
\end {quote}

La primitive {\tt signal} permet à un processus de
choisir une des trois manières de traiter un
signal. Le paramètre {\tt sig} indique le numéro
du signal (voir page~\pageref {ps:sigv7}).

Le paramètre {\tt action} peut prendre trois
valeurs~:

\begin {enumerate}
    \item {\tt SIG\_DFL}~: termine (sauf pour les cas
	particuliers) l'exécution du processus,
    \item {\tt SIG\_IGN}~: ignore le signal, ou
    \item une adresse de fonction~: à la réception du
	signal {\tt sig}, la fonction {\tt fonction} sera
	exécutée avec le numéro du signal comme paramètre.

	Attention~: si le signal parvient au processus,
	celui-ci exécute la fonction, mais le système
	remet également l'action à {\t SIG\_DFL}. Ceci
	signifie que si un signal peut arriver plusieurs
	fois, la primitive {\tt signal} doit être appelée
	de nouveau dans la fonction.
\end {enumerate}

Le signal {\tt SIGKILL} ne peut être ni ignoré ni
traité.

Cette primitive renvoie l'adresse de l'ancienne
fonction en cas de modification réussie, ou -1 en
cas d'erreur.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Les signaux POSIX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Signaux POSIX}

Les signaux de la version 7 (voir page~\pageref {ps:sigv7}) ont un
certain nombre de défaut, parmi lesquels une absence de fiabilité (perte
d'informations, possibilité de terminaison involontaire du processus,
etc.).  Le comité POSIX a revu en profondeur le fonctionnement des
signaux.  La nouvelle interface de programmation mérite une section à
part.

Les signaux requis par la norme sont récapitulés dans le tableau
ci-dessous (voir page~\pageref {ps:sigv7} pour la signification de ces
constantes).  Les signaux de la deuxième moitié ne sont requis que si le
système dispose de l'extension {\em job control}.

\begin {quote}
    \small\tt
    \begin {tabular} {|llllll|} \hline
	SIGABRT & SIGALRM & SIGFPE  & SIGHUP  & SIGILL  & SIGINT  \\
	SIGKILL & SIGPIPE & SIGQUIT & SIGSEGV & SIGTERM & SIGUSR1 \\
	SIGUSR2 &         &         &         &         &         \\ \hline
	SIGCHLD & SIGCONT & SIGSTOP & SIGTSTP & SIGTTIN & SIGTTOU \\ \hline
    \end {tabular}
\end {quote}



\separation
\primitive {sigaction} --- manipulation de l'action associée à un signal
    \index{{\tt sigaction}}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigaction (int sig, const struct sigaction *nouvelle, struct sigaction *ancienne)
\end{verbatim}
\end {quote}

La primitive {\tt sigaction} permet la récupération ou la modification
de l'action associée au signal {\tt sig}.

Le contenu de la structure {\tt sigaction} est défini comme suit~:

\begin {tabular} {|l|l|p{70mm}|} \hline
    \multicolumn {1} {|c|} {\bf Type}
	& \multicolumn {1} {|c|} {\bf Nom}
	& \multicolumn {1} {|c|} {\bf Description}
	\\ \hline
    \verb:void (*)(int):
	& \verb:sa_handler:
	& \verb:SIG_DFL:, \verb:SIG_IGN: ou un pointeur sur une fonction
	\\ \hline
    \verb:sigset_t:
	& \verb:sa_mask:
	& ensemble de signaux à bloquer pendant l'éxecution de l'action
	    (en plus de {\tt sig})
	\\ \hline
    \verb:int:
	& \verb:sa_flags:
	& paramètres affectant le comportement du signal.
	    POSIX n'en définit qu'un~: \verb:SA_NOCLDSTOP: pour ne pas
	    envoyer le signal {\tt SIGCHLD} lorsqu'un processus fils est
	    stoppé (en utilisant {\tt ptrace}).
	\\ \hline
\end {tabular}


Si le paramètre {\tt nouvelle} est non nul, il pointe sur une structure
spécifiant l'action à effectuer lorsque le signal {\tt sig} sera reçu.
Si ce paramètre est nul, l'action n'est pas modifiée.

Si le paramètre {\tt ancienne} est non nul, il pointe sur une structure
que la primitive {\tt sigaction} doit remplir avec l'action (avant
l'appel à {\tt sigaction}) associée au signal {\tt sig}.  Si ce
paramètre est nul, rien n'est recopié.

Lorsque le signal est reçu, pendant l'exécution de l'action, un nouveau
masque de signaux est fabriqué par l'union du masque courant, du masque
associé au signal et du signal lui-même. \`A la fin de l'exécution de
l'action, l'action reste associée au signal mais l'ancien masque est
réinstallé.

Les objets de type {\tt sigset\_t} sont manipulés avec les fonctions de
librairie {\em sigsetopts} (voir page~\pageref {sigsetopts}).

Cette primitive renvoie 0 en cas d'opération réussie, ou -1 en cas
d'erreur.



\separation
\primitive {sigprocmask} --- manipulation du masque de signaux
    \index{{\tt sigprocmask}}
    \label {sigprocmask}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigprocmask (int comment, const sigset_t *nouveau, sigset_t *ancien)
\end{verbatim}
\end {quote}

Si l'argument {\tt nouveau} est non nul, le processus courant initialise
son masque de signaux avec la valeur pointée. Le paramètre {\tt comment}
spécifie comment ce changement doit être effectué~:

\begin {quote}
\begin {tabular} {|l|p{80mm}|} \hline
    \multicolumn {1} {|c|} {\tt comment}
	& \multicolumn {1} {|c|} {\bf Description}
	\\ \hline
    \verb:SIG_BLOCK:
	& le nouveau masque devient l'union de l'ancien et de celui pointé
	    par {\tt nouveau}
	\\ \hline
    \verb:SIG_UNBLOCK:
	& le nouveau masque est l'intersection de l'ancien et du
	    complément de celui pointé par {\tt nouveau} (tous ceux qui
	    figurent dans {\tt nouveau} sont retirés de l'ancien).
	\\ \hline
    \verb:SIG_SETMASK:
	& le nouveau masque devient celui pointé par {\tt nouveau}
	\\ \hline
\end {tabular}
\end {quote}

Si l'argument {\tt nouveau} est nul, le paramètre {\tt comment}
n'est pas significatif, cette primitive ne sert qu'à obtenir des
informations sur le masque courant.

Si l'argument {\tt ancien} est non nul, il pointe sur une structure que
la primitive {\tt sigprocmask} doit remplir avec le masque (avant
l'appel à {\tt sigprocmask}).  Si ce paramètre est nul, rien n'est
recopié.

Les objets de type {\tt sigset\_t} sont manipulés avec les fonctions de
librairie {\em sigsetopts}.

Cette primitive renvoie 0 en cas d'opération réussie, ou -1 en cas
d'erreur.



\separation
\primitive {sigwait} --- attend un signal
    \index{{\tt sigwait}}
    \label {sigwait}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigwait (const sigset_t *ensemble, int *recu)
\end{verbatim}
\end {quote}

Cette primitive suspend le processus (ou le thread) courant en attendant
l'un des signaux spécifiés par \texttt {ensemble}. Le numéro du signal
reçu est placé en retour dans l'entier pointé par \texttt {recu}.

La valeur de retour est soit 0 en cas d'attente réussie, soit une valeur
strictement supérieure à 0 pour indiquer le numéro d'erreur.


\separation
\primitive {sigpending} --- consultation des signaux en attente
    \index{{\tt sigpending}}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigpending (sigset_t *signaux)
\end{verbatim}
\end {quote}

La zone pointée par {\tt signaux} est remplie avec les signaux bloqués
en attente.

Les objets de type {\tt sigset\_t} sont manipulés avec les fonctions de
librairie {\em sigsetopts}.

Cette primitive renvoie 0 en cas d'opération réussie, ou -1 en cas
d'erreur.



\separation
\primitive {sigsuspend} --- suspend le processus en attendant un signal
    \index{{\tt sigsuspend}}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigsuspend (const sigset_t *signaux)
\end{verbatim}
\end {quote}

Cette primitive remplace le masque de signaux par l'ensemble pointé par
{\tt signaux} et suspend le processus jusqu'à l'exécution d'une action
spécifiée par {\tt sigaction} ou la terminaison du processus.

Si une action est exécutée, {\tt sigsuspend} se termine lorsque l'action
est terminée, le masque de signaux est alors remis à sa valeur
antérieure.

Les objets de type {\tt sigset\_t} sont manipulés avec les fonctions de
librairie {\em sigsetopts}.

Cette primitive renvoie toujours -1 pour indiquer une opération
interrompue par l'arrivée d'un signal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% L'horloge du système
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Horloge du système}


Une autre catégorie de primitives système est
celle qui exploite l'horloge du système.
Indépendamment des mécanismes matériels, celle-ci
assure la mesure des temps d'exé\-cu\-tion et la
mémorisation des heure et date courantes.



\separation
\primitive {stime} --- initialise la date et l'heure du système
    \index{{\tt stime}}

\begin {quote}
\begin {verbatim}
#include <time.h>

int stime (const time_t *adresse)
\end{verbatim}
\end {quote}

La primitive {\tt stime} permet au super
utilisateur de modifier l'heure et la date du
système.

L'heure est stockée dans un entier long à
l'adresse pointée par le paramètre {\tt adresse}. Cet
entier représente le nombre de secondes écoulées
depuis 00:00:00 UTC January 1, 1970.

Cette primitive renvoie 0 en cas de modification
réussie, ou -1 en cas d'erreur.




\separation
\primitive {time} --- renvoie la date et l'heure
    \label {time}
    \index{{\tt time}}

\begin {quote}
\begin {verbatim}
#include <time.h>

time_t time ((time_t *) 0)
time_t time (time_t *adresse)
\end{verbatim}
\end {quote}

La primitive {\tt time} renvoie l'heure et la date
courante en secondes écoulées depuis
00:00:00 UTC, January 1, 1970.

Si le paramètre {\tt adresse} est non nul, la valeur
de retour est aussi stockée à l'adresse
indiquée.

La primitive \texttt {time} renvoie l'heure courante, ou -1 (ou plus
exactement \verb|((time_t)-1)|) en cas d'erreur.

Les fonctions de bibliothèque décrites en~\ref {gestion-temps} (voir
page~\pageref {gestion-temps}) assurent la conversion entre un \texttt
{time\_t} et une chaîne de caractères.


\separation
\primitive {gettimeofday} --- renvoie la date et l'heure précises
    \label {gettimeofday}
    \index{{\tt gettimeofday}}

\begin {quote}
\begin {verbatim}
#include <sys/time.h>

int gettimeofday (struct timeval *tv, struct timezone *tz)
\end{verbatim}
\end {quote}


La primitive \texttt {gettimeofday} renvoie l'heure courante avec une
précision supérieure à la seconde, ainsi que le fuseau horaire. La
structure \texttt {timeval} contient les champs suivants~:
\begin {quote}
\begin {verbatim}
time_t      tv_sec ;           /* secondes */
suseconds_t tv_usec ;          /* et microsecondes */
\end{verbatim}
\end {quote}
et la structure \texttt {timezone} contient les champs suivants~:
\begin {quote}
\begin {verbatim}
int         tz_minuteswest ;   /* minutes à l'ouest de Greenwich */
int         tz_dsttime ;       /* != 0 si l'heure d'été est en vigueur */
\end{verbatim}
\end {quote}

Si un des pointeurs passé en paramètre vaut \texttt {NULL}, la structure
correspondante n'est pas mise à jour par la primitive système. La
primitive renvoie 0 si tout s'est bien passé, ou -1 en cas d'erreur.


\separation
\primitive {times} --- renvoie les temps du processus et de ses fils
    \index{{\tt times}}

\begin {quote}
\begin {verbatim}
#include <sys/times.h>

clock_t times (struct tms *buf)
\end{verbatim}
\end {quote}

La primitive {\tt times} place dans la structure pointée par le
paramètre \texttt {buf} les temps d'unité centrale du processus et de
ses fils. La structure possède les champs suivants~:

\begin {quote}
\begin {verbatim}
clock_t tms_utime ;
clock_t tms_stime ;
clock_t tms_cutime ;
clock_t tms_cstime ;
\end{verbatim}
\end {quote}

\begin {itemize}
    \item {\tt tms\_utime} est le temps CPU utilisé par le processus
	pendant l'exécution des instructions en mode utilisateur,

    \item {\tt tms\_stime} est le temps CPU utilisé par le processus
	pendant l'exécution des instructions en mode système,

    \item {\tt tms\_cutime} est la somme des temps CPU (mode
	utilisateur) utilisés par tous les processus terminés et
	descendants du processus courant,

    \item {\tt tms\_cstime} est la somme des temps CPU (mode système)
	utilisés par tous les processus terminés et descendants du
	processus courant.
\end {itemize}

Ces temps viennent du processus et de tous les processus fils pour
lesquels le processus a appelé la primitive {\tt wait}. L'unité dans
laquelle ces temps sont exprimés est typiquement le {\em top d'horloge},
valeur dépendant du système utilisé.
Il y a {\tt CLK\_TCK} (voir {\tt sysconf} page~\pageref {sysconf}) tops
d'horloge par seconde sur les systèmes POSIX. Sur les systèmes anciens,
il y a {\tt HZ} tops par seconde, avec {\tt HZ} défini dans le fichier
{\tt param.h}.

Note~: \texttt {times} est redondante avec \texttt {getrusage} (voir
page~\pageref {getrusage}) qui est plus générale et devrait être
privilégiée.

Cette primitive renvoie le temps réel écoulé ({\it elapsed}) depuis un
repère dans le passé (typiquement l'heure de boot), ou -1 en cas
d'erreur.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Disques et les périphériques
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Disques et périphériques}


Les appels qui suivent sont tous liés à la
gestion des systèmes de fichier et des périphériques en
général. Il faut bien distinguer la notion de
système de fichiers de celle de disque~: un disque
peut contenir plusieurs systèmes de fichiers. Le
disque n'est qu'un support.




\separation
\primitive {fsync} --- vide le contenu des buffers internes associés à un fichier sur le disque
    \index{{\tt fsync}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int fsync (int desc)
\end{verbatim}
\end {quote}

La primitive {\tt fsync} provoque l'écriture réelle
sur le disque de tous les éléments modifiés du fichier dont le
descripteur est {\tt desc} (obtenu par {\tt open},
{\tt creat}, {\tt dup}, {\tt fcntl} ou {\tt pipe}).

Tous les buffers internes associés au fichier
sont donc vidés.

Cette primitive renvoie 0 en cas d'écriture
réussie, -1 en cas d'erreur.




\separation
\primitive {ioctl} --- opérations diverses sur un périphérique
    \index{{\tt ioctl}}

\begin {quote}
\begin {verbatim}
#include <sys/ioctl.h>

int ioctl (int desc, int requete, ... /* argument */)
\end{verbatim}
\end {quote}

La primitive {\tt ioctl} accomplit une variété
d'actions sur des périphériques en mode caractère,
accédés par l'intermédiaire d'un descripteur de
fichier obtenu par {\tt open}, {\tt dup} ou {\tt fcntl}.

Les requêtes sont des ordres passés au driver de
périphérique. Pour plus d'informations, consulter
la documentation du driver.

Cette primitive renvoie -1 en cas d'erreur.




\separation
\primitive {mount} --- monte un système de fichiers
    \index{{\tt mount}}

\begin {quote}
\begin {verbatim}
int mount (const char *special, const char *rep, int rwflag)
\end{verbatim}
\end {quote}

La primitive {\tt mount} demande qu'un système de
fichiers identifié par {\tt spécial}, le nom du périphérique en
mode bloc, soit monté sous le répertoire nommé
{\tt rep}. Ces deux arguments sont des chemins
d'accès.

Le bit de poids faible est utilisé pour contrôler
l'écriture dans le système de fichiers. S'il vaut
1, l'écriture est interdite. Sinon, l'écriture est
autorisée, moyennant l'accessibilité individuelle
de chaque fichier.

Seul le super utilisateur a le droit de monter un
système de fichiers.

Cette primitive renvoie 0 en cas de montage
réussi, ou -1 en cas d'erreur.




\separation
\primitive {sync} --- vide le contenu de tous les buffers internes sur les disques
    \index{{\tt sync}}

\begin {quote}
\begin {verbatim}
void sync (void)
\end{verbatim}
\end {quote}

La primitive {\tt sync} provoque la sauvegarde sur
disque de tous les buffers internes en mémoire.
Ceci inclut le super-block, les inodes modifiés et
les blocs non encore écrits.

Cette primitive devrait être appelée par tout
programme devant examiner un système de fichiers,
tel que {\tt fsck} ou {\tt df}, etc. D'autre part,
{\tt sync} est obligatoire avant de stopper le
système de manière à assurer l'intégrité des
données.




\separation
\primitive {ulimit} --- renvoie ou change les limites (en taille de mémoire ou de fichier)
    \index{{\tt ulimit}}

\begin {quote}
\begin {verbatim}
long ulimit (int commande, long limite)
\end{verbatim}
\end {quote}

La primitive {\tt ulimit} fournit un moyen de
contrôle sur les limitations imposées aux
processus. Les valeurs que peut prendre le
paramètre {\tt commande} sont~:

\begin {enumerate}
    \item renvoyer la taille maximum que peut prendre
	un fichier. La limite est en multiple de 512
	octets, et est héritée aux processus fils.
    \item changer la taille maximum que peut prendre
	un fichier par {\tt limite}. Tous les processus
	peuvent diminuer cette limite, mais seul le super
	utilisateur peut l'augmenter.
    \item renvoyer la taille maximum allouable par {\tt brk}.
\end {enumerate}

Cette primitive renvoie un nombre non négatif en
cas de réussite, ou -1 en cas d'erreur.




\separation
\primitive {umount} --- démonte un système de fichiers
    \index{{\tt umount}}

\begin {quote}
\begin {verbatim}
int umount (const char *special)
\end{verbatim}
\end {quote}

La primitive {\tt unmount} provoque le démontage du
système de fichiers identifié par {\tt spécial}, le nom du
périphérique en mode bloc.

Cette primitive renvoie 0 en cas de démontage
réussi, ou -1 en cas d'erreur.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sockets Berkeley
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Sockets Berkeley}

Les ajouts de l'Université de Berkeley dans le domaine du
réseau sont, pour le programmeur, de nouvelles primitives
systèmes et de nouvelles fonctions de librairie. Ces nouvelles
primitives sont décrites ci-après.

\section* {Erreurs}

Les primitives système renvoient -1 en cas d'erreur. Dans ce
cas, la variable globale {\tt errno} est initialisée à la
valeur correspondant à l'erreur survenue. Les cas ajoutés
par l'Université de Berkeley dans le domaine du réseau sont~:

\begin {itemize}
    \item {\tt EADDRINUSE}~: adresse déjà utilisée,
    \item {\tt EADDRNOTAVAIL}~: l'adresse ne peut être affectée, comme
	par exemple pour une socket dont l'adresse n'est
	pas l'ordinateur courant,
    \item {\tt EAFNOSUPPORT}~: la famille d'adresses n'est pas supportée
	dans {\tt socket},
    \item {\tt ECONNABORTED}~: la connexion est rompue,
    \item {\tt ECONNREFUSED}~: la connexion est refusée,
    \item {\tt ECONNRESET}~: la connexion est rompue par l'autre
	extrémité, normalement par {\tt shutdown},
    \item {\tt EDESTADDRREQ}~: l'adresse de destination est requise pour
	l'opération demandée,
    \item {\tt EHOSTDOWN}~: une opération est demandée sur un ordinateur
	ne répondant pas,
    \item {\tt EHOSTUNREACH}~: aucune route trouvée vers l'ordinateur
	demandé,
    \item {\tt EINPROGRESS}~: l'opération est en cours de réalisation,
    \item {\tt EISCONN}~: la socket est déjà connectée,
    \item {\tt ENET}~: erreur sur le logiciel ou le matériel du réseau,
    \item {\tt ENETDOWN}~: le réseau est hors service,
    \item {\tt ENETRESET}~: le réseau a coupé la connexion,
    \item {\tt ENETUNREACH}~: aucune route trouvée vers le réseau
	demandé,
    \item {\tt ENOPROTOOPT}~: le protocole demandé n'est pas
	disponible, une mauvaise option demandée lors de
	{\tt getsockopt} ou {\tt setsockopt},
    \item {\tt ENOTCONN}~: la socket n'est pas connectée,
    \item {\tt ENOTSOCK}~: l'opération nécessite une socket,
    \item {\tt EPROTONOSUPPORT}~: le protocole demandé n'est pas
	supporté,
    \item {\tt EPROTOTYPE}~: mauvais type pour la socket,
    \item {\tt ESHUTDOWN}~: tentative de transmission après un {\tt
	shutdown},
    \item {\tt ESOCKTNOSUPPORT}~: type de socket non supporté,
    \item {\tt ETIMEDOUT}~: la connexion n'a pas pu avoir lieu car elle
	a excédé la durée d'attente maximum.
\end {itemize}

%%% ACCEPT

\separation
\primitive {accept} --- attente de connection
    \index{{\tt accept}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int accept (int s, struct sockaddr *adresse, int *longueur)
\end{verbatim}
\end {quote}

Cette primitive est utilisée dans les sockets
de type ``connecté''. La socket {\tt s} est supposée créée
par {\tt socket}, avoir acquis une adresse avec {\tt bind}
et en attente de connexion avec {\tt listen}. {\tt accept}
extrait la première connexion en attente, crée une nouvelle
socket avec les mêmes propriétés que {\tt s}, renvoie son
descripteur, et remplit {\tt adresse} et {\tt longueur}
avec ses paramètres.

La valeur de retour est le descripteur de la nouvelle
socket, ou -1 en cas d'erreur.


%%% BIND

\separation
\primitive {bind} --- affectation d'une adresse
    \index{{\tt bind}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netinet/in.h>

int bind (int s, struct sockaddr *adresse, int longueur)
\end{verbatim}
\end {quote}

La primitive {\tt bind} affecte une adresse à la socket
désignée par {\tt s}. La variable {\tt longueur} contient la
longueur de l'adresse stockée à l'adresse {\tt adresse}.

La valeur de retour est 0 si tout s'est bien passé, -1
sinon.


%%% CLOSE

\separation
\primitive {close} --- fermeture de socket
    \index{{\tt close}}

\begin {quote}
\begin {verbatim}
int close (int s)
\end{verbatim}
\end {quote}

La primitive {\tt close} est étendue aux connexions IP.


%%% CONNECT

\separation
\primitive {connect} --- tentative de connection
    \index{{\tt connect}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netinet/in.h>

int connect (int s, struct sockaddr *adresse, int longueur)
\end{verbatim}
\end {quote}

La primitive {\tt connect} demande à la socket {\tt s}
d'ouvrir une connexion avec l'adresse spécifiée par
{\tt adresse} et {\tt longueur}.

Si {\tt s} est de type {\tt SOCK\_DGRAM}, {\tt connect}
enregistre l'adresse de destination et retourne immédiatement.
Si le type est {\tt SOCK\_STREAM}, {\tt connect} essaye
d'établir une connection fiable.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% GETHOSTNAME

\separation
\primitive {gethostname, sethostname} --- lecture du nom de host
    \index{{\tt gethostname}}
    \index{{\tt sethostname}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int gethostname (char *nom, size_t nombre)
int sethostname (char *nom, size_t nombre)
\end{verbatim}
\end {quote}

La primitive {\tt gethostname} recopie le nom symbolique de
l'ordinateur dans la zone identifiée par {\tt nom}. Au
plus {\tt nombre} caractères sont recopiés, et terminés par un
caractère nul si la place le permet.

La primitive {\tt sethostname} permet à l'administrateur du système de
modifier le nom symbolique de l'ordinateur.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% GETPEERNAME

\separation
\primitive {getpeername} --- lecture de l'adresse de l'autre partie
    \index{{\tt getpeername}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int getpeername (int s, struct sockaddr *adresse, int *longueur)
\end{verbatim}
\end {quote}

La primitive {\tt getpeername} renvoie la description de la
socket connectée distante dans {\tt adresse} et {\tt
longueur}.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% GETSOCKNAME

\separation
\primitive {getsockname} --- lecture de l'adresse de la socket
    \index{{\tt getsockname}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int getsockname (int s, struct sockaddr *adresse, int *longueur)
\end{verbatim}
\end {quote}

La primitive {\tt getsockname} renvoie la description de la
socket {\tt s} dans {\tt adresse} et {\tt longueur}.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% GETSOCKOPT

\separation
\primitive {getsockopt} --- lecture des options associées à la socket
    \index{{\tt getsockopt}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int getsockopt (int s, int niveau, int option, void *valeur, int *longueur)
\end{verbatim}
\end {quote}

La primitive {\tt getsockopt} renvoie les options associées à
une socket. Voir la description des paramètres dans {\tt
setsockopt}.

Les options booléennes renvoient 0 si non armées, ou -1 si
armées. Les paramètres {\tt valeur} et {\tt longueur}
peuvent être modifiés pour toutes les options, booléennes ou
non.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% LISTEN

\separation
\primitive {listen} --- initialisation de la file d'attente
    \index{{\tt listen}}

\begin {quote}
\begin {verbatim}
int listen (int s, int longueur)
\end{verbatim}
\end {quote}

Pour accepter des connexions, une socket est d'abord créée
avec {\tt socket}, puis une file d'attente pour les demandes
de connexion est créée avec {\tt listen}. Le paramètre {\tt
longueur} est le nombre maximum de connexion (entre 1 et 20)
en attente pouvant être mémorisée dans cette file.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% READ

\separation
\primitive {read} --- lecture de données
    \index{{\tt read}}

\begin {quote}
\begin {verbatim}
ssize_t read (int desc, void *buf, size_t nombre)
\end{verbatim}
\end {quote}

La primitive {\tt read} est étendue aux connexions IP.


%%% RECV
%%% RECVFROM

\separation
\primitive {recv, recvfrom} --- lecture de données
    \index{{\tt recv}}
    \index{{\tt recvfrom}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int recv (int s, void *buf, int longueur, int flags)
int recvfrom (int s, void *buf, int longueur, int flags, struct sockaddr *exp, int longexp)
\end{verbatim}
\end {quote}

La primitive {\tt recv} attend la réception
d'un message à partir d'une
socket {\tt s}. Le message de longueur maximum {\tt
longueur} est placé à partir de l'adresse {\tt buf}.
Le paramètre {\tt flags} est initialisé à {\tt MSG\_PEEK}
(lecture sans retirer de la file d'attente de réception), à {\tt
MSG\_OOB} (lecture de données urgentes), ou 0.

La primitive {\tt recvfrom} est identique à la primitive
{\tt recv}, à la différence que les paramètres de
l'expéditeur sont renvoyées dans {\tt exp} et {\tt longexp}.

La valeur de retour est le nombre d'octets reçus, ou -1 si
il y a eu erreur.


%%% SELECT

\separation
\primitive {select} --- attente d'un évènement
    \index{{\tt select}}
    \index{{\tt FD\_ZERO}}
    \index{{\tt FD\_CLR}}
    \index{{\tt FD\_SET}}
    \index{{\tt FD\_ISSET}}

\begin {quote}
\begin {verbatim}
#include <sys/select.h>

int select (int ndescs, fd_set *rdesc, fd_set *wdesc, fd_set *xdesc, struct timeval *delai)
void FD_ZERO fd_set *ensemble)
void FD_CLR (int fd, fd_set *ensemble)
void FD_SET (int fd, fd_set *ensemble)
void FD_ISSET (int fd, fd_set *ensemble)

\end{verbatim}
\end {quote}

La primitive {\tt select} attend qu'un des descripteurs
spécifiés par {\tt rdesc} ait des données en attente, qu'un
des descripteurs spécifiés par {\tt wdesc} soit prêt à
recevoir des données, qu'un des descripteurs spécifiés par
{\tt xdesc} exhibe une condition exceptionnelle, ou
que la durée spécifiée par {\tt delai} soit écoulée.

La spécification des descripteurs est réalisée par des ensembles
de bits. Le descripteur $f$ est représenté par le bit \verb|1<<f|.
Pour faciliter la manipulation de ces ensembles, il faut utiliser les
macros \texttt {FD\_ZERO} (positionner tous les bits de l'ensemble à 0),
\texttt {FD\_CLR} et \texttt {FD\_SET} (positionner le bit correspondant
au descripteur \texttt {fd} respectivement à 0 ou 1) ou \texttt
{FD\_ISSET} (tester la valeur du bit correspondant au descripteur \texttt
{fd}).

Le nombre de bits à surveiller dans les descripteurs est
indiqué par \texttt {ndesc} (autrement dit, \texttt {ndesc}
est égal au maximum des descripteurs + 1, les descripteurs
débutant à 0).

Si un descripteur remplit une des conditions ci-dessus, le
bit correspondant est laissé à 1 dans le masque
correspondant. Sinon, il est remis à 0.

Si un masque ou {\tt delai} n'est pas utile, le pointeur
nul peut être transmis à la place.

La valeur renvoyée est le nombre de descripteurs affectés,
0 si la durée est écoulée sans événement, ou -1 en cas
d'erreur.


%%% SEND
%%% SENDTO

\separation
\primitive {send, sendto} --- émission de données
    \index{{\tt send}}
    \index{{\tt sendto}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int send (int s, void *buf, int longueur, int flags)
int sendto (int s, void *buf, int longueur, int flags, struct sockaddr dest, int longdest)
\end{verbatim}
\end {quote}

La primitive {\tt send} envoie un message spécifié par {\tt
buf} et de longueur {\tt longueur} par la socket {\tt s}.

La primitive {\tt sendto} est similaire à la primitive {\tt
send} à ceci près que l'adresse de destination est
spécifiée.

La valeur de retour est le nombre d'octets envoyés, ou -1 si
il y a eu erreur.


%%% SETHOSTNAME

\separation
\primitive {sethostname} --- initialisation du nom de host
    \index{{\tt sethostname}}

\begin {quote}
\begin {verbatim}
int sethostname (const char *nom, unsigned int nombre)
\end{verbatim}
\end {quote}

La primitive {\tt sethostname} permet, si l'utilisateur est
{\em root}, de changer le nom de l'ordinateur.

%%% SETSOCKOPT

\separation
\primitive {setsockopt} --- modification des options associées à la socket
    \index{{\tt setsockopt}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int setsockopt (int s, int niveau, int option, const void *valeur, int longueur)
\end{verbatim}
\end {quote}

La primitive {\tt setsockopt} change les options associées à
une socket. Le niveau doit être {\tt SOL\_SOCKET} pour
manipuler les options au niveau {\em socket}.

Les options sont définies dans {\tt <sys/socket.h>} et sont
décrites ci-dessous~:

\begin {itemize}
    \item {\tt SO\_BURST\_IN} (sockets {\tt SOCK\_DGRAM}
	seulement)~: nombre de messages pouvant être mémorisés
	en réception avant d'être rejetés,
    \item {\tt SO\_BURST\_OUT} (sockets {\tt SOCK\_DGRAM}
	seulement)~: nombre de messages pouvant être mémorisés
	en émission avant d'être rejetés,
    \item {\tt SO\_DONTROUTE} (sockets {\tt SOCK\_STREAM}
	seulement)~: pas d'utilisation des tables de
	routage,
    \item {\tt SO\_REUSEADDR} (sockets {\tt AF\_INET}
	seulement)~: permet la réutilisation des adresses
	locales,
    \item {\tt SO\_KEEPALIVE} (sockets {\tt SOCK\_STREAM} et
	{\tt AF\_INET} seulement)~: force les sockets
	connectées, mais inactives et sans réponse, à
	émettre toutes les 45 secondes, jusqu'à 6 minutes,
    \item {\tt SO\_LINGER} (sockets {\tt SOCK\_STREAM} et
	{\tt AF\_INET} seulement)~: garde la socket active
	lors d'un {\tt close} s'il y a des données présentes,
    \item {\tt SO\_DONTLINGER} (sockets {\tt SOCK\_STREAM} et
	{\tt AF\_INET} seulement)~: ne garde pas la socket active
	lors d'un {\tt close}.
    \item {\tt SO\_RCVBUF}~: pour la réception,
	change la taille du buffer
	(sockets {\tt SOCK\_STREAM}) ou la taille
	maximum d'un message (sockets {\tt SOCK\_DGRAM}),
    \item {\tt SO\_SNDBUF}~: pour l'émission,
	change la taille du buffer
	(sockets {\tt SOCK\_STREAM}) ou la taille
	maximum d'un message (sockets {\tt SOCK\_DGRAM}),
\end {itemize}

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% SHUTDOWN

\separation
\primitive {shutdown} --- fermeture de socket
    \index{{\tt shutdown}}

\begin {quote}
\begin {verbatim}
int shutdown (int s, int comment)
\end{verbatim}
\end {quote}

La primitive {\tt shutdown} ferme une socket. Le paramètre
{\tt comment} spécifie que les réceptions (si 0), les
émissions (si 1), ou les émissions et les réceptions (si 2) sont
désactivées.

La valeur renvoyée est 0 si tout s'est bien passé, ou -1 en
cas d'erreur.


%%% SOCKET

\separation
\primitive {socket} --- création de socket
    \index{{\tt socket}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>

int socket (int famille, int type, int protocole)
\end{verbatim}
\end {quote}

La primitive {\tt socket} crée une socket, c'est-à-dire
une extrémité d'un canal de communication, et renvoie le
descripteur associé.

Le paramètre {\tt famille} spécifie une famille d'adresses utilisée
pour interpréter les adresses dans les opérations ultérieures. Les
familles courantes sont {\tt PF\_INET} (IPv4), \texttt {PF\_INET6}
(IPv6) et {\tt PF\_UNIX} (chemins d'accès dans l'aborescence Unix).

Le paramètre {\tt type} spécifie la sémantique de la
connexion. Le type est soit {\tt SOCK\_STREAM} (mode
connecté, ordonné, fiable, bi-directionnel, dont l'unité est
l'octet), soit {\tt SOCK\_DGRAM} (mode non connecté, non
fiable, dont l'unité est le message de taille fixe et
habituellement petite).

Le paramètre {\tt protocole} désigne le protocole utilisé.
Normalement, un seul protocole existe pour une famille et un
type donné. Toutefois, il pourrait arriver qu'il en existe
plusieurs. La valeur 0 signifie que le système choisit le
protocole le mieux adapté aux deux paramètres précités.

La valeur renvoyée est le descripteur de la socket créée, ou
-1 en cas d'erreur.


%%% WRITE

\separation
\primitive {write} --- émission de données
    \index{{\tt write}}

\begin {quote}
\begin {verbatim}
ssize_t write (int desc, void *buf, size_t nombre)
\end{verbatim}
\end {quote}

La primitive {\tt write} est étendue aux connexions IP.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IPC System V
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {IPC System V}

Les IPC System V sont les mécanismes de communication inter-processus
(IPC) introduits dans System V.  Ces mécanismes sont suffisamment
distincts, tant dans leur fonctionnalité que dans leur interface, du
reste des primitives pour justifier une section à part.

Les IPC System V sont décomposés en trois parties~:

\begin {enumerate}
    \item les files de messages
    \item la mémoire partagée
    \item les sémaphores
\end {enumerate}

Pour qu'un processus puisse utiliser ces primitives, il faut qu'il
transforme une {\em clef} en un identificateur interne à l'aide de {\tt
msgget}, {\tt shmget} ou {\tt semget}.  Le tableau suivant fait une
analogie avec les fichiers~:

\begin {tabular} {|l|l|l|} \cline {2-3}
    \multicolumn {1} {c|} {}
	& \multicolumn {1} {|c|} {Fichiers}
	& \multicolumn {1} {|c|} {IPC System V}
	\\ \hline
    nom externe
	& type = {\tt char *}
	& type = {\tt key\_t}
	\\
	& chaîne, nom de fichier
	& entier, convention entre les
	\\
	&
	& processus communiquants
	\\ \hline
    nom interne
	& type = {\tt int}
	& type = {\tt int}
	\\
	& descripteur de fichier
	& identificateur d'IPC
	\\ \hline
    conversion
	& primitive {\tt open}
	& primitives {\tt {\em xxx}get}
	\\ \hline
    droits d'accès
	& $3^e$ paramètre de {\tt open}
	& dernier paramètre de {\tt {\em xxx}get}
	\\ \hline
\end {tabular}


\section* {Files de messages}

%%% MSGCTL

\separation
\primitive {msgctl} --- opérations de contrôle d'une file de messages
    \index{{\tt msgctl}}

\begin {quote}
\begin {verbatim}
#include <sys/msg.h>

int msgctl (int msqid, int cmd, struct msqid_ds *buf)
\end{verbatim}
\end {quote}

Le paramètre {\tt cmd} de la primitive {\tt msgctl} indique l'action à
effectuer sur la file de messages repérée par l'identificateur {\tt
msqid}~:

\begin {itemize}
    \item {\tt IPC\_STAT}~: place dans la structure pointée par {\tt
	buf} les paramètres de la file de messages~;
    \item {\tt IPC\_SET}~: initialise les paramètres de la file de
	messages indiqués par les champs {\tt msg\_perm.uid},
	{\tt msg\_perm.gid}, {\tt msg\_perm.mode} et {\tt msg\_qbytes}
	de la structure pointée par {\tt buf}~;
    \item {\tt IPC\_RMID}~: supprime la file de messages si
	l'utilisateur est le super-utilisateur ou le propriétaire de
	la file de message.
\end {itemize}

Cette primitive renvoie 0 en cas d'opération
réussie, ou -1 en cas d'erreur.


\separation
\primitive {msgget} --- retourne l'identificateur d'une file de messages
    \index{{\tt msgget}}

\begin {quote}
\begin {verbatim}
#include <sys/msg.h>

int msgget (key_t clef, int flags)
\end{verbatim}
\end {quote}

Cette primitive renvoie l'identificateur interne associé à la clef
fournie en argument.

La file de message est créée si la clef égale {\tt IPC\_PRIVATE} ou si
le paramètre {\tt flags} contient le bit {\tt IPC\_CREAT}.  La file de
messages est créée avec des permissions égales aux 9 premiers bits de
{\tt flags}.

La création est refusée si la file existe déjà et si les flags {\tt
IPC\_CREAT} et {\tt IPC\_EXCL} sont positionnés.

Cette primitive ne peut renvoyer de file de message déjà créée avec la
clef {\tt IPC\_PRIVATE}.

Cette primitive renvoie un nombre positif ou nul en cas d'opération
réussie, ou -1 en cas d'erreur.


\separation
\primitive {msgsnd, msgrcv} --- émission et lecture de messages
    \index{{\tt msgsnd}}
    \index{{\tt msgrcv}}

\begin {quote}
\begin {verbatim}
#include <sys/msg.h>

int msgsnd (int msqid, const void *msgp, size_t taille, int flags)
int msgrcv (int msqid, void *msgp, size_t taille, long type, int flags)
\end{verbatim}
\end {quote}

Un message (pointé par {\tt msgp}) est constitué d'un champ de type {\tt
long} qui permet à l'utilisateur de spécifier un type ($\geq$ 1) de message
et d'une suite d'octets (entre 0 et une limite imposée
par le système) formant la donnée du message.

La primitive {\tt msgsnd} est utilisée pour envoyer un message.  Lorsque
la file de messages est saturée, le bit {\tt IPC\_NOWAIT} du paramètre
{\tt flags} spécifie si le processus doit être mis en attente.

La primitive {\tt msgrcv} est utilisée pour recevoir~:

\begin {itemize}
    \item le premier message en attente si {\tt type} $= 0$~;
    \item le premier message de type {\tt type} en attente si {\tt type}
	$> 0$~;
    \item le message de type minimum inférieur à la valeur absolue de
	{\tt type} si {\tt type}$\leq 0$.
\end {itemize}

Si aucun message n'est disponible, le bit {\tt IPC\_NOWAIT} du paramètre
{\tt flags} spécifie si le processus doit être mis en attente.

Le paramètre {\tt taille} spécifie la taille du message à émettre (pour
{\tt msgsnd}) ou la taille maximum du message que le processus peut
recevoir (pour {\tt msgrcv}).  Cette taille ne comprend pas le champ de
type {\tt long}.

En cas d'opération réussie, {\tt msgsnd} renvoie 0, {\tt msgrcv} renvoie
la taille (non compris le champ de type {\tt long}) du message lu.
En cas d'erreur, ces primitives renvoient -1.



\section* {Mémoire partagée}

\separation
\primitive {shmctl} --- opérations de contrôle d'un segment de mémoire partagée
    \index{{\tt shmctl}}

\begin {quote}
\begin {verbatim}
#include <sys/shm.h>

int shmctl (int shmid, int cmd, struct shmid_ds *buf)
\end{verbatim}
\end {quote}

Le paramètre {\tt cmd} de la primitive {\tt shmctl} indique l'action à
effectuer sur le segment de mémoire partagé repéré par l'identificateur {\tt
shmid}~:

\begin {itemize}
    \item {\tt IPC\_STAT}~:  place dans la structure pointée par {\tt
	buf} les paramètres du segment~;
    \item {\tt IPC\_SET}~:  initialise les paramètres du segment
	indiqués par les champs {\tt shm\_perm.uid}, {\tt shm\_perm.gid}
	et {\tt shm\_perm.mode} de la structure pointée par {\tt buf}~;
    \item {\tt IPC\_RMID}~:  supprime le segment de mémoire partagée si
	l'utilisateur est le super-utilisateur ou le propriétaire du
	segment~;
    \item {\tt SHM\_LOCK}~:  verrouille le segment de mémoire partagée
	en mémoire si l'utilisateur est le super-utilisateur~;
    \item {\tt SHM\_UNLOCK}~:  déverrouille le segment de mémoire
	partagée en mémoire si l'utilisateur est le super-utilisateur~;
\end {itemize}

Cette primitive renvoie 0 en cas d'opération
réussie, ou -1 en cas d'erreur.



\separation
\primitive {shmget} --- retourne l'identificateur d'un segment de mémoire partagée
    \index{{\tt shmget}}

\begin {quote}
\begin {verbatim}
#include <sys/shm.h>

int shmget (key_t clef, size_t taille, int flags)
\end{verbatim}
\end {quote}

Cette primitive renvoie l'identificateur interne associé à la clef
fournie en argument.

Le segment de mémoire partagée est créé (avec une taille {\tt taille})
si la clef égale {\tt IPC\_PRIVATE} ou si le paramètre {\tt flags}
contient le bit {\tt IPC\_CREAT}.  Le segment est créé avec des
permissions égales aux 9 premiers bits de {\tt flags}.

La création est refusée si le segment existe déjà et si les flags {\tt
IPC\_CREAT} et {\tt IPC\_EXCL} sont positionnés.

Cette primitive ne peut renvoyer de segment déjà créé avec la clef
{\tt IPC\_PRIVATE}.

Cette primitive renvoie un nombre positif ou nul en cas d'opération
réussie, ou -1 en cas d'erreur.


\separation
\primitive {shmat, shmdt} --- attachement et détachement de segment de mémoire partagée
    \index{{\tt shmat}}
    \index{{\tt shmdt}}

\begin {quote}
\begin {verbatim}
#include <sys/shm.h>

void *shmat (int shmid, void *adresse, int flags)
int shmdt (void *adresse)
\end{verbatim}
\end {quote}

La primitive {\tt shmat} attache un segment de mémoire partagée dans
l'espace d'adresses du processus à l'adresse spécifiée ou à une adresse
sélectionnée par le système si le paramètre {\tt adresse} est nul. Le
bit {\tt SHM\_RDONLY} du paramètre {\tt flags} spécifie si le segment
doit être attaché en lecture seule ou en lecture et en écriture.

La primitive {\tt shmdt} détache le segment situé à l'adresse {\tt
adresse}.

En cas d'opération réussie, {\tt shmat} renvoie l'adresse d'attachement
du segment, {\tt shmdt} renvoie 0.  En cas d'erreur, ces primitives
renvoient -1.


\section* {Sémaphores}

\separation
\primitive {semctl} --- opérations de contrôle de sémaphores
    \index{{\tt semctl}}

\begin {quote}
\begin {verbatim}
#include <sys/sem.h>

int semctl (int semid, int numero, int cmd, ... /* arg */)
\end{verbatim}
\end {quote}

Le paramètre {\tt cmd} de la primitive {\tt semctl} indique l'action à
effectuer sur le groupe de sémaphores repéré par l'identificateur {\tt
semid}~:

\begin {itemize}
    \item {\tt IPC\_STAT}~: place dans la structure pointée par {\tt
	buf} les paramètres du groupe~;
    \item {\tt IPC\_SET}~: initialise les paramètres du groupe
	indiqués par les champs {\tt sem\_perm.uid}, {\tt sem\_perm.gid}
	et {\tt sem\_perm.mode} de la structure pointée par {\tt buf}~;
    \item {\tt IPC\_RMID}~: supprime le groupe si l'utilisateur est le
	super-utilisateur ou le propriétaire du groupe~;
    \item {\tt GETVAL}~:  renvoie la valeur du {\tt numero}-ième
	sémaphore du groupe~;
    \item {\tt SETVAL}~: initialise la valeur du {\tt numero}-ième
	sémaphore dans le groupe avec un quatrième paramètre entier~;
    \item {\tt GETPID}~: renvoie le numéro du dernier processus ayant
	fait une opération sur le {\tt numero}-ième sémaphore du
	groupe~;
    \item {\tt GETNCNT}~: renvoie le nombre de processus attendant que
	la valeur du {\tt numero}-ième sémaphore du groupe prenne une
	valeur supérieure à la valeur courante~;
    \item {\tt GETZCNT}~: renvoie le nombre de processus attendant que
	la valeur du {\tt numero}-ième sémaphore du groupe prenne une
	valeur nulle~;
    \item {\tt GETALL}~: place dans le tableau d'entier courts non
	signés passé en quatrième paramètre les valeurs de tous les
	sémaphores du groupe~;
    \item {\tt SETALL}~: initialise tous les sémaphores du groupe avec
	les valeurs contenues dans le tableau d'entier courts non
	signés passé en quatrième paramètre.
\end {itemize}

Cette primitive renvoie 0 ou la valeur à renvoyer en cas d'opération
réussie, ou -1 en cas d'erreur.


\separation
\primitive {semget} --- retourne l'identificateur d'un ensemble de sémaphores
    \index{{\tt semget}}

\begin {quote}
\begin {verbatim}
#include <sys/sem.h>

int semget (key_t clef, int nsem, int flags)
\end{verbatim}
\end {quote}

Cette primitive renvoie l'identificateur interne associé à la clef
fournie en argument.

Le groupe de sémaphores est créé (avec le nombre de sémaphores {\tt
nsem}) si la clef égale {\tt IPC\_PRIVATE} ou si le paramètre {\tt
flags} contient le bit {\tt IPC\_CREAT}.  Le groupe est créé avec des
permissions égales aux 9 premiers bits de {\tt flags}.

La création est refusée si le groupe existe déjà et si les flags {\tt
IPC\_CREAT} et {\tt IPC\_EXCL} sont positionnés.

Cette primitive ne peut renvoyer de groupe déjà créé avec la clef
{\tt IPC\_PRIVATE}.

Cette primitive renvoie un nombre positif ou nul en cas d'opération
réussie, ou -1 en cas d'erreur.


\separation
\primitive {semop} --- opérations sur sémaphores
    \index{{\tt semop}}

\begin {quote}
\begin {verbatim}
#include <sys/sem.h>

int semop (int semid, struct sembuf *sops, int nsops)
\end{verbatim}
\end {quote}

Cette primitive est utilisée pour réaliser de manière atomique un
ensemble d'opérations sur un groupe de sémaphores repéré par
l'identificateur {\tt semid}.

Le paramètre {\tt nsops} spécifie le nombre de sémaphores dans le groupe
concernés par l'action en cours.  Le tableau {\tt sops} (de {\tt nsops}
éléments) décrit l'opération à réaliser sur chacun d'entre eux.  Chaque
élément de ce tableau est une structure contenant les champs~:

\begin {itemize}
    \item {\tt unsigned short sem\_num}~: numéro du sémaphore~;
    \item {\tt short sem\_op}~: opération sur le sémaphore~;
    \item {\tt short sem\_flg}~: paramètres de l'opération~;
\end {itemize}

Pour chaque sémaphore du groupe, {\tt sem\_op} indique l'opération~:

\begin {itemize}
    \item si $\mbox {\tt sem\_op} < 0$~:\\
	si la valeur courante du sémaphore est supérieure à la valeur
	absolue de {\tt sem\_op}, cette valeur est soustraite de la
	valeur courante du sémaphore. Sinon, le processus est mis en
	attente ou la primitive renvoie la valeur -1, suivant la valeur
	du bit {\tt IPC\_NOWAIT} de {\tt sem\_flg}~;

    \item si $\mbox {\tt sem\_op} > 0$~:\\
	la valeur de {\tt sem\_op} est ajoutée à la valeur courante du
	sémaphore~;

    \item si $\mbox {\tt sem\_op} = 0$~:\\
	si la valeur courante du sémaphore est nulle, {\tt semop}
	continue avec l'opération suivante. Sinon, le processus est mis
	en attente ou la primitive renvoie la valeur -1, suivant la
	valeur du bit {\tt IPC\_NOWAIT} de {\tt sem\_flg}~;
\end {itemize}

Si le bit {\tt SEM\_UNDO} de {\tt sem\_flg} est mis, l'opération est
inversée (valeurs soustraites au lieu d'être ajoutées et vice-versa)
sans mise en attente du processus.

Par exemple, pour réaliser un P, puis un V sur un sémaphore, il faut
faire~:

\begin {quote}
\small
\begin {verbatim}
sops [0].sem_num = 1 ; sops [0].sem_op = -1 ; sops [0].sem_flg = 0 ;
semop (semid, sops, 1) ;

sops [0].sem_num = 1 ; sops [0].sem_op = 1 ; sops [0].sem_flg = 0 ;
semop (semid, sops, 1) ;
\end{verbatim}
\end {quote}

Cette primitive renvoie une valeur positive ou nulle en cas
d'opérations réussies, ou -1 en cas d'erreur.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Divers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Divers}


Les primitives système qui suivent ne sont pas
classables facilement. Elles font intervenir des
concepts aussi différent que le changement de
taille des segments d'un processus ou l'obtention
du nom du système.




\separation
\primitive {acct} --- active ou désactive la surveillance des processus
    \index{{\tt acct}}

\begin {quote}
\begin {verbatim}
#include <sys/acct.h>

int acct (const char *nom)
\end{verbatim}
\end {quote}

La primitive {\tt acct} valide ou invalide la
surveillance des processus ({\it process
accounting}). Si la surveillance est validée, une
ligne sera écrite dans le fichier {\tt nom} chaque
fois qu'un processus se terminera.

Il faut être super utilisateur pour utiliser cet
appel.

Cette primitive renvoie 0 en cas de réussite, ou
-1 en cas d'erreur.




\separation
\primitive {brk, sbrk} --- modifie la taille du segment de données
    \index{{\tt brk}}
    \index{{\tt sbrk}}

\begin {quote}
\begin {verbatim}
int brk (const void *fin)
void *sbrk (int increment)
\end{verbatim}
\end {quote}

Ces deux primitives servent à modifier dynamiquement la taille du
segment de données, c'est-à-dire les variables globales (statiques) et
le tas du processus.

La primitive {\tt brk} modifie la taille de telle manière que {\tt fin}
soit une adresse valide dans l'espace de données usager.

La primitive {\tt sbrk} ajoute {\tt incrément} octets à la taille du
segment de données.

La fonction {\tt malloc} de la librairie standard réalise une allocation
d'espace de manière plus souple pour le programmeur.

En cas de réussite, {\tt brk} renvoie 0 et {\tt sbrk} l'ancienne adresse
de la fin du segment de données.  En cas d'erreur, la valeur -1 est
renvoyée.




\separation
\primitive {mknod} --- crée un fichier spécial
    \index{{\tt mknod}}

\begin {quote}
\begin {verbatim}
#include <mknod.h>
#include <sys/stat.h>

int mknod (const char *nom, int mode, dev_t peripherique)
\end{verbatim}
\end {quote}

La primitive {\tt mknod} crée un nouveau fichier de
nom {\tt nom}. Le mode du fichier (son type et ses
protections) est initialisé avec {\tt mode}. Les
différents bits constituant {\tt mode} sont~:

\begin {itemize}
    \item 0170000~: type du fichier. Un des bits suivants~:
	\begin {itemize}
	    \item 0010000~: fichier spécial fifo,
	    \item 0020000~: fichier spécial en mode caractère,
	    \item 0040000~: répertoire,
	    \item 0060000~: fichier spécial en mode bloc
	    \item 0100000 ou 0000000~: fichier ordinaire, et
	\end {itemize}
    \item 0004000~: bit {\it set user id}
    \item 0002000~: bit {\it set group id}
    \item 0001000~: {\it sticky bit} (sauver le code après exécution)
    \item 0000777~: protections du fichier. Construites
	à partir des bits suivants~:
	\begin {itemize}
	    \item 0000400~: lecture par le propriétaire
	    \item 0000200~: écriture par le propriétaire
	    \item 0000100~: exécution par le propriétaire
	    \item 0000070~: idem pour le groupe
	    \item 0000007~: idem pour les autres
	\end {itemize}
\end {itemize}

Les valeurs de {\tt mode} autres que celles
ci-dessus ne sont pas définies et ne devraient pas
être utilisées.

Le propriétaire du fichier spécial est
l'utilisateur {\it effectif} du processus.

Les 9 bits de poids faible sont masqués par le
masque de création de fichiers (voir {\tt umask}).

Le paramètre {\tt périphérique} est signifiant
uniquement si {\tt mode} indique un périphérique en
mode bloc ou caractère.

Seul le super utilisateur peut utiliser {\tt mknod}
pour des fichiers autres que {\it fifo}.

Cette primitive renvoie 0 en cas de création
réussie, ou -1 en cas d'erreur.




\separation
\primitive {profil} --- mesure du temps d'exécution
    \index{{\tt profil}}

\begin {quote}
\begin {verbatim}
void profil (unsigned short *buf, int taille, int offset, int echelle)
\end{verbatim}
\end {quote}

La primitive {\tt profil} valide la mesure des temps d'exécution ({\it
process profiling}), qui aide à identifier les portions de programme
prenant le plus de temps. La valeur du pointeur programme est lue à
chaque top d'horloge (i.e. {\tt CLK\_TCK} fois par seconde, voir {\tt
sysconf} page~\pageref {sysconf}) pour incrémenter un compteur dans
la zone {\tt buf}. {\tt Echelle} et {\tt offset} sont utilisés pour
déterminer le mot à incrémenter.

Une {\tt échelle} nulle ou égale à 1 invalide la
mesure.

L'appel {\tt profil} est (presque ?) exclusivement
utilisée par l'option {\tt -p} du compilateur {\tt cc}.




\separation
\primitive {ptrace} --- tracer un processus
    \index{{\tt ptrace}}

\begin {quote}
\begin {verbatim}
#include <ptrace.h>

int ptrace (int requete, int pid, int adresse, int donnee)
\end{verbatim}
\end {quote}

La primitive {\tt ptrace} est utilisée par un
processus pour contrôler l'exécution d'un
processus fils. Elle est exclusivement utilisée
pour implémenter des débogueurs.

Pour qu'un processus soit débogable, il faut
qu'il ait exécuté {\tt ptrace} avec la requête 0. Il
s'arrête alors.

Le processus père doit attendre avec {\tt wait} que
le processus fils soit arrêté. Il peut ensuite
avec les diverses requêtes consulter ou modifier
la mémoire du fils. La requête 9 fait exécuter une
instruction par le fils.




\separation
\primitive {sysconf} --- renvoie des paramètres du système
    \index{{\tt sysconf}}
    \label {sysconf}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

long sysconf (int paramètre)
\end{verbatim}
\end {quote}

La primitive {\tt sysconf} est une primitive introduite
par la norme POSIX pour obtenir les valeurs numériques
de quelques paramètres du système. La table ci-dessous
donne quelques-uns des paramètres requis par la norme~:

\begin {tabular} {|l|p{80mm}|} \hline
    \multicolumn {1} {|c|} {\tt paramètre}
	& \multicolumn {1} {|c|} {\bf Description}
	\\ \hline
    \verb:_SC_ARG_MAX:
	& Taille maximum en octets des arguments de {\tt execve}
	\\
    \verb:_SC_CHILD_MAX:
	& Nombre maximum de processus par utilisateur
	\\
    \verb:_SC_CLK_TCK:
	& Fréquence de l'horloge utilisée par {\tt times}
	    (en nombre de tops par seconde)
	\\
    \verb:_SC_NGROUPS_MAX:
	& Nombre maximum de groupes auquel un utilisateur peut
	    appartenir
	\\
    \verb:_SC_OPEN_MAX:
	& Nombre maximum de fichiers ouverts par utilisateur
	\\
    \verb:_SC_PAGE_SIZE:
	& Taille d'une page de mémoire virtuelle
	\\
    \verb:_SC_JOB_CONTROL:
	& 1 si le {\em job control} est disponible, ou -1 sinon
	\\
    \verb:_SC_VERSION:
	& La version de la norme ISO/IEC 9945 (POSIX 1003.1)
	    que ce système supporte
	\\
    \verb:_SC_BC_BASE_MAX:
	& Valeur maximum pour les paramètres {\tt ibase} et {\tt obase}
	    dans l'utilitaire {\tt bc}
	\\
    \verb:_SC_BC_DIM_MAX:
	& Taille maximum des tableaux
	    dans l'utilitaire {\tt bc}
	\\
    \verb:_SC_BC_SCALE_MAX:
	& Valeur maximum pour le paramètre {\tt scale}
	    dans l'utilitaire {\tt bc}
	\\
    \verb:_SC_BC_STRING_MAX:
	& Longueur maximum des chaînes
	    dans l'utilitaire {\tt bc}
	\\
    \verb:_SC_EXPR_NEST_MAX:
	& Nombre maximum d'expressions que l'on peut imbriquer
	    entre parenthèses dans l'utilitaire {\tt expr}
	\\
    \verb:_SC_LINE_MAX:
	& Longeur maximum de ligne admissible par les utilitaires
	    de traitement de textes
	\\
    \verb:_SC_2_VERSION:
	& La version de la norme POSIX 1003.2
	    que ce système supporte
	\\
	\hline
\end {tabular}

Cette primitive renvoie la valeur du paramètre demandé,
ou -1 en cas d'erreur.



\separation
\primitive {getrusage} --- récupère des informations sur l'utilisation des ressources
    \label {getrusage}
    \index{{\tt getrusage}}

\begin {quote}
\begin {verbatim}
#include <sys/resource.h>

int getrusage (int qui, struct rusage *res)
\end{verbatim}
\end {quote}

La primitive {\tt getrusage} récupère les informations sur les
resssources utilisées par le processus courant (paramètre \texttt {qui}
= \texttt {RUSAGE\_SELF}), par ses processus fils terminés (\texttt {qui}
= \texttt {RUSAGE\_CHILDREN}) ou par le thread courant (\texttt {qui}
= \texttt {RUSAGE\_THREAD}).

Les champs de la structure \texttt {rusage} sont~:

\begin {itemize}
    \item \texttt {ru\_utime}~: temps CPU en mode utilisateur (\texttt
	{struct timeval}, voir \texttt {gettimeofday}, page~\pageref
	{gettimeofday})
    \item \texttt {ru\_stime}~: temps CPU en mode système (\texttt
	{struct timeval}, voir \texttt {gettimeofday}, page~\pageref
	{gettimeofday})
    \item \texttt {ru\_maxrss}~: capacité maximum utilisée en mémoire
	physique
    \item \texttt {ru\_minflt}~: nombre de défauts de page n'entraînant
	pas d'entrée/sortie
    \item \texttt {ru\_majflt}~: nombre de défauts de page entraînant
	des entrées/sorties
    \item \texttt {ru\_inblock}~: nombre de lectures disque effectuées
	par le processus
    \item \texttt {ru\_oublock}~: nombre d'écritures disque effectuées
	par le processus
    \item \texttt {ru\_msgsnd}~: nombre de messages IPC System V envoyés
    \item \texttt {ru\_msgrcv}~: nombre de messages IPC System V reçus
    \item \texttt {ru\_nsignals}~: nombre de signaux reçus \item \texttt
    {ru\_nvcsw}~: nombre de changements volontaires de
	processus (suite à une attente de ressource, par exemple)
    \item \texttt {ru\_nivcsw}~: nombre de changements involontaires
	de processus (du fait d'un processus plus prioritaire, par
	exemple)

\end {itemize}

La norme POSIX ne définit que les deux premiers champs (\texttt
{ru\_utime} et \texttt {ru\_stime}), la présence des autres n'est pas
garantie sur toutes les architectures ou toutes les versions de système.
De même, POSIX ne définit pas \texttt {RUSAGE\_THREAD}.

Cette primitive renvoie 0 en cas de succès, ou -1 en cas d'erreur.



\separation
\primitive {umask} --- renvoie ou modifie le masque de création de fichiers
    \index{{\tt umask}}

\begin {quote}
\begin {verbatim}
#include <sys/stat.h>

mode_t umask (mode_t masque)
\end{verbatim}
\end {quote}

La primitive {\tt umask} initialise le masque
binaire de mode de création de fichier (voir {\tt chmod}).
Seuls les 9
bits de poids faible sont significatifs.

Les bits mis à 1 dans le masque spécifient quels
sont les bits de protection à mettre à 0 dans le
mode des fichiers à créer.

Cette primitive renvoie la précédente valeur de
masque.




\separation
\primitive {uname} --- renvoie le nom du système
    \index{{\tt uname}}

\begin {quote}
\begin {verbatim}
#include <sys/utsname.h>

int uname (struct utsname *buf)
\end{verbatim}
\end {quote}

La primitive {\tt uname} renvoie des informations
sur le nom et la version du système Unix dans un
buffer pointé par {\tt buf}. Les champs de la
structure {\tt utsname} sont~:

\begin {quote}
\begin {verbatim}
char sysname [9] ;
char nodename [9] ;
char release [9] ;
char version [9] ;
char machine [9] ;
\end{verbatim}
\end {quote}

Il faut noter que toutes les chaînes de cette
structure sont terminées par un octet nul.

Cette primitive renvoie un nombre non négatif en
cas de réussite, ou -1 en cas d'erreur.




\separation
\primitive {utime} --- change les dates d'accès et de modification d'un fichier
    \index{{\tt utime}}

\begin {quote}
\begin {verbatim}
#include <utime.h>

int utime (const char *nom, const struct utimbuf *buf)
\end{verbatim}
\end {quote}

La primitive {\tt utime} modifie les dates d'accès
et de modification d'un fichier de nom {\tt nom}.

Si {\tt buf} est une adresse nulle, ces dates sont
mises à la date courante. Un processus doit être
le propriétaire d'un fichier ou avoir la
permission en écriture sur le fichier pour
procéder de la sorte.

Si {\tt buf} n'est pas nul, il pointe sur une
structure {\tt utimbuf} dont les champs sont~:

\begin {quote}
\begin {verbatim}
time_t actime ;
time_t modtime ;
\end{verbatim}
\end {quote}

Seul le propriétaire du fichier ou le super
utilisateur peuvent utiliser {\tt utime} de cette
manière.

Cette primitive renvoie 0 si la modification a
été réussie, ou -1 sinon.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% LES FONCTIONS DE LA LIBRAIRIE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\chapter {Les fonctions de la librairie standard}


Le langage C ne définit que le langage proprement dit. Ceci
permet une plus grande souplesse dans le traitement des
entrées/sorties et dans l'interface avec le système.

Pour accéder au système ou à certaines caractéristiques
intéressantes, l'utilisateur dispose de librairies. Le
système UNIX en comprend de nombreuses, depuis la gestion de
la vidéo jusqu'aux fonctions mathématiques, en passant par
les librairies spécialisées pour tel ou tel outil.

Cependant, une librairie est distinguée. Il s'agit de la
{\em librairie standard}, ou encore {\em librairie C}. L'éditeur
de liens la cherche automatiquement.

Ses fonctions peuvent être classées en grandes catégories~:

\begin {itemize}
    \item les fonctions d'entrées / sorties
    \item les fonctions de gestion de la mémoire
    \item les fonctions sur les caractères et les chaînes
    \item les fonctions associées aux sockets Berkeley
    \item les fonctions système
\end {itemize}

La liste ci-dessous donne la liste de ces fonctions par
catégorie. Attention~: cette liste n'est absolument pas
exhaustive. Certaines fonctions peuvent en outre être
différentes sur certains systèmes. Néanmoins, ces fonctions
sont communes à presque tous les systèmes UNIX.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Les fonctions d'entrées / sorties
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Fonctions d'entrées / sorties}


Les fonctions d'entrées sorties nécessitent toutes
l'inclusion du fichier {\em stdio.h}. Un fichier sous UNIX est
une suite ininterrompue de caractères. L'accès est aussi
bien séquentiel qu'aléatoire.

Les fonctions de la librairie sont implémentées de manière
sûre et efficace. Il ne faut pas hésiter à les utiliser
quand c'est possible.

Un fichier est référencé par un {\em flux}, qui est
l'association d'un fichier et d'un tampon d'entrées sorties.
Un {\em flux} est représenté par le type prédéfini {\tt FILE}. Trois
{\em flux} spéciaux sont automatiquement ouverts~: {\tt stdin},
{\tt stdout} et {\tt stderr}.

La constante {\tt NULL} représente une valeur illégale de
{\em flux}.

La constante {\tt EOF} est la valeur représentant la fin du
fichier.


\separation
\primitive {fclose, fflush} --- fermer ou actualiser les fichiers
    \index{{\tt fclose}}
    \index{{\tt fflush}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int fclose (FILE *flux)
int fflush (FILE *flux)
\end{verbatim}
\end {quote}


Les deux fonctions écrivent le contenu des tampons associés
au flux {\tt flux} dans le fichier associé. La fonction
{\tt fclose} ferme ensuite le fichier.

Ces fonctions renvoient 0 s'il n'y a pas eû d'erreur,
{\tt EOF} sinon.


\separation
\primitive {feof, ferror, clearerr, fileno} --- état d'un flux
    \index{{\tt feof}}
    \index{{\tt ferror}}
    \index{{\tt clearerr}}
    \index{{\tt fileno}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int feof (FILE *flux)
int ferror (FILE *flux)
void clearerr (FILE *flux)
int fileno (FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt feof} renvoie un résultat différent de 0 si
la fin de fichier a été rencontrée sur le flux {\tt flux},
0 sinon.

La fonction {\tt ferror} renvoie un résultat différent de 0 si
une erreur a été rencontrée en cours de lecture ou
d'écriture sur le flux {\tt flux}, 0 sinon.

La fonction {\tt clearerr} efface les indicateurs de fin de
fichier ou d'erreur associés au flux {\tt flux}.

La fonction {\tt fileno} renvoie le numéro du descripteur de
fichier qui est associé au flux {\tt flux} pour utiliser un
appel système. Attention à utiliser {\tt fflush} avant d'appeler
la primitive système.


\separation
\primitive {fopen, freopen, fdopen} --- ouvrir un flux
    \index{{\tt fopen}}
    \index{{\tt freopen}}
    \index{{\tt fdopen}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

FILE *fopen (const char *nom, const char *mode)
FILE *freopen (const char *nom, const char *mode, FILE *flux)
FILE *fdopen (int descripteur, const char *mode)
\end{verbatim}
\end {quote}

La fonction {\tt fopen} ouvre le fichier {\tt nom} suivant le
mode sélectionné par {\tt mode}, qui peut être~: \par
{\tt r  }: ouverture en lecture \\
{\tt w  }: effacement et ouverture en écriture \\
{\tt a  }: ouverture en écriture à la fin du fichier \\
{\tt r+ }: ouverture en lecture et écriture \\
{\tt w+ }: effacement et ouverture en lecture et écriture \\
{\tt a+ }: ouverture en lecture et écriture à la fin du fichier 

La fonction {\tt freopen} remplace le flux {\tt flux} par
l'ouverture du fichier {\tt nom}.

La fonction {\tt fdopen} associe un flux au descripteur de
fichier {\tt descripteur} obtenu en utilisant un appel
système.

Ces trois fonctions renvoient le nouveau flux, ou la valeur
{\tt NULL} si une erreur est intervenue.



\separation
\primitive {fread, fwrite} --- entrée / sortie binaire
    \index{{\tt fread}}
    \index{{\tt fwrite}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int fread (void *buf, int taille, int nb, FILE *flux)
int fwrite (const void *buf, int taille, int nb, FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt fread} lit {\tt taille} octets sur le flux
{\tt flux}, les place dans le buffer {\tt buf}, et répète
l'opération {\tt nb} fois.

L'argument {\tt taille} est habituellement obtenu par
l'opérateur {\tt sizeof} de C.

La fonction {\tt fwrite} réalise la même opération en écriture
sur le flux {\tt flux}.

Ces deux fonctions renvoient le nombre d'éléments lus ou
écrits, ou 0 en cas d'erreur ou de fin de fichier.



\separation
\primitive {fseek, ftell, rewind} --- modifier le pointeur de flux
    \index{{\tt fseek}}
    \index{{\tt ftell}}
    \index{{\tt rewind}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int fseek (FILE *flux, long offset, int mode)
long ftell (FILE *flux)
long rewind (FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt fseek} modifie la position de la prochaine
lecture ou écriture sur le flux {\tt flux}. La valeur de
{\tt offset}, suivant l'argument {\tt mode}, signifie un
déplacement relatif à partir~:

\begin {itemize}
\item du début du fichier, si {\tt mode} = {\tt SEEK\_SET} (valeur = 0),
\item de la position courante, si {\tt mode} = {\tt SEEK\_CUR} (valeur = 1),
\item de la fin du fichier, si {\tt mode} = {\tt SEEK\_END} (valeur = 2).
\end {itemize}

La valeur renvoyée est 0 si il n'y a pas eû d'erreur, ou une valeur
non nulle sinon.

La fonction {\tt ftell} retourne la position courante dans le
fichier, en nombre d'octets depuis le début du fichier.

La fonction {\tt rewind} positionne le flux {\tt flux} au début
du fichier.


\separation
\primitive {getc, getchar, fgetc, getw} --- lire un caractère sur le flux
    \index{{\tt getc}}
    \index{{\tt getchar}}
    \index{{\tt fgetc}}
    \index{{\tt getw}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int getc (FILE *flux)
int getchar (void)
int fgetc (FILE *flux)
int getw (FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt getc} renvoie le premier caractère
disponible sur le flux {\tt flux}, et incrémente le pointeur
dans le flux.

La fonction {\tt getchar} est équivalente à {\tt getc(stdin)}.

La fonction {\tt fgetc} est identique à {\tt getc}, mais est une
fonction et non une macro. Moins rapide, mais plus
économique en place occupée.

La fonction {\tt getw} renvoie le prochain mot ({\tt int} en C).

Ces fonctions renvoient {\tt EOF} en cas d'erreur ou de fin de
fichier sur le flux.



\separation
\primitive {gets, fgets} --- lit une chaîne sur le flux
    \index{{\tt gets}}
    \index{{\tt fgets}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

char *gets (char *str)
char *fgets (char *str, int max, FILE *flux)
\end{verbatim}
\end {quote}

Attention : la fonction \texttt {gets} est \textbf {obsolète}, car elle ne
vérifie pas le débordement de la chaîne fournie en paramètre. Il
faut utiliser \texttt {fgets} à la place.

La fonction {\tt gets} lit une chaîne sur le flux d'entrée
standard ({\tt stdin}), jusqu'à ce qu'un caractère fin de ligne
({\tt $\backslash$n}) ou la fin de fichier soit rencontrée. Le caractère
{\tt $\backslash$n} est remplacé par le caractère nul.

La fonction {\tt fgets} est identique à {\tt gets} sur n'importe
quel flux, en recopiant au maximum {\tt max} caractères.

Ces fonctions renvoient {\tt NULL} si la fin de fichier a été
rencontrée sans qu'aucun caractère n'ait été lu.


\separation
\primitive {opendir, readdir, closedir} --- accès aux informations d'un répertoire
    \label {opendir}
    \index{{\tt opendir}}
    \index{{\tt readdir}}
    \index{{\tt closedir}}
    \index{{\tt telldir}}
    \index{{\tt seekdir}}

\begin {quote}
\begin {verbatim}
#include <dirent.h>

DIR *opendir (const char *nom)
struct dirent *readdir (DIR *dp)
long int telldir (DIR *dp)
void seekdir (DIR *dp, long offset)
void rewinddir (DIR *dp)
int closedir (DIR *dp)
\end{verbatim}
\end {quote}

La fonction {\tt opendir} ouvre un répertoire identifié par son nom, et
renvoie un descripteur utilisable dans les autres fonctions. Le résultat
est {\tt NULL} si le répertoire ne peut être ouvert.

La fonction {\tt readdir} renvoie l'adresse d'une zone (statique) dans
laquelle elle place l'entrée suivante du répertoire. Cette structure
contient les champs suivants~:

\begin {itemize}
    \item {\tt char d\_name []}~: nom de l'entrée dans le
	répertoire, terminé par un octet nul~;
    \item {\tt ino\_t d\_ino}~: numéro d'inode du fichier~;
\end {itemize}

Note~: certaines implémentations comportent un champ \texttt {d\_type}
indiquant le type (fichier, répertoire, etc.) de l'entrée. Ce champ
n'est pas spécifié par POSIX, aussi son utilisation est \textbf
{déconseillée} pour obtenir des programmes portables. On utilisera à
la place la primitive \texttt {stat} (voir page~\pageref {stat}).

Le résultat est {\tt NULL} en cas d'erreur ou lorsque la fin du
répertoire est rencontrée.

la fonction {\tt telldir} renvoie la position courante dans le
répertoire, la fonction {\tt seekdir} initialise cette position
courante, et la fonction {\tt rewinddir} la remet à 0.

La fonction {\tt closedir} ferme le répertoire, et renvoie -1 en cas
d'erreur et 0 en cas de fermeture réussie.


\separation
\primitive {popen, pclose} --- ouvre ou ferme un tube
    \index{{\tt popen}}
    \index{{\tt pclose}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

FILE *popen (const char *commande, const char *mode)
int pclose (FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt popen} ouvre un tube (communication entre
deux processus) avec la commande {\tt commande} interprétée par
le shell.

Le mode d'ouverture {\tt mode} est un chaîne de caractères
contenant {\tt r} pour une ouverture en lecture, ou {\tt w} pour
une ouverture en écriture.

Le résultat de la fonction {\tt popen} est le flux dans lequel
il faut lire ou écrire, ou {\tt NULL} s'il y a une erreur.

Un tube ouvert avec {\tt popen} doit être fermé avec la
fonction {\tt pclose} qui attend que la commande se termine. La
valeur renvoyée par {\tt pclose} est le code de retour de la
commande {\tt commande}.



\separation
\primitive {printf, fprintf, sprintf, snprintf} --- écriture formattée
    \index{{\tt printf}}
    \index{{\tt fprintf}}
    \index{{\tt sprintf}}
    \index{{\tt snprintf}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int printf (const char *format, ...)
int fprintf (FILE *flux, const char *format, ...)
int sprintf (char *str, const char *format, ...)
int snprintf (char *str, size_t taille, const char *format, ...)
\end{verbatim}
\end {quote}

Attention : la fonction \texttt {sprintf} est \textbf {obsolète}, car elle ne
vérifie pas le débordement de la chaîne fournie en paramètre. Il faut
utiliser \texttt {snprintf} à la place.

La fonction {\tt printf} affiche ses données sur la sortie standard, la
fonction {\tt fprintf} écrit sur le flux {\tt flux}, la fonction {\tt
snprintf} place le résultat dans la chaîne de caractères {\tt str} en
vérifiant le non-débordement de cette chaîne.

Chacune de ces fonctions affiche les arguments suivant {\tt format} en
les convertissant suivant le format {\tt format}.  Le format est une
chaîne de caractères qui contient deux sortes d'objets~:  les caractères
simples, qui sont affichés normalement, et les formats de conversion
commençant par un caractère {\tt \%}, régis par la syntaxe suivante (les
éléments entre crochets sont optionnels, les accolades indiquent une
lettre au choix)~:

{\tt \%} [{\tt -}] [ [{\tt 0}] $<$nombre$>$ [{\tt .} $<$nombre$>$] [{\tt l}] {{ {\tt doxufegcs\%} }}

\begin {itemize}
    \item le caractère {\tt -} indique que l'argument doit être cadré à
	gauche dans son champ,

    \item le premier nombre indique la dimension du champ.  Si
	l'argument prend plus de place, l'espace est complété avec des
	blancs, ou avec des {\tt 0} si le premier caractère du nombre
	est {\tt 0},

    \item le point sert de séparateur avec le nombre suivant,

    \item le nombre suivant indique le nombre de caractères maximum de
	la chaîne (format {\tt s}), ou le nombre de chiffres après la
	virgule dans le cas des formats {\tt f} ou {\tt e},

    \item le caractère {\tt l} indique que l'argument est du type long
	pour les formats {\tt d}, {\tt o}, {\tt x} ou {\tt u}.

    \item le caractère suivant indique enfin le type de l'argument~:\\
	\texttt {d} ou \texttt {i}~: conversion en décimal\\
	\texttt {o}~: conversion en octal\\
	\texttt {x}~: conversion en hexadécimal\\
	\texttt {u}~: conversion en décimal non signé\\
	\texttt {f}~: conversion en flottant sans exposant\\
	\texttt {e}~: conversion en flottant avec exposant\\
	\texttt {g}~: conversion d'un flottant en {\tt \%d}, {\tt \%e} ou {\tt \%f}\\
	\texttt {c}~: conversion en caractère\\
	\texttt {s}~: conversion en chaîne de caractères\\
	\texttt {\%}~: affichage d'un caractère {\tt \%}

\end {itemize}

Exemple~: pour imprimer une date et une heure au format~: \par
\begin {quote}
\begin {verbatim}
dimanche 3 juillet, 10:02
\end{verbatim}
\end {quote}

il faut utiliser~:

\begin {quote}
\begin {verbatim}
printf ("%s %d %s, %d:%.2d", sem, jour, mois, heure, mn) ;
\end{verbatim}
\end {quote}

Pour imprimer $\pi$ à 10$^-5$ près~:

\begin {quote}
\begin {verbatim}
printf ("PI = %.5f", 4 * atan (1.0)) ;
\end{verbatim}
\end {quote}


\separation
\primitive {putc, putchar, fputc, putw} --- écrire un caractère sur le flux
    \index{{\tt putc}}
    \index{{\tt putchar}}
    \index{{\tt fputc}}
    \index{{\tt putw}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int putc (int c, FILE *flux)
int putchar (int c)
int fputc (int c, FILE *flux)
int putw (int mot, FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt putc} écrit le caractère {\tt c} sur le flux
{\tt flux}, et incrémente le pointeur dans le flux.

La fonction {\tt putchar(c)} est équivalente à {\tt putc(c,stdin)}.

La fonction {\tt fputc} est identique à {\tt putc}, mais est une
fonction et non une macro. Moins rapide, mais plus
économique en place occupée.

La fonction {\tt putw} écrit le mot ({\tt int} en C) sur le flux.

Ces fonctions renvoient {\tt EOF} en cas d'erreur sur le flux,
sinon le caractère écrit.


\separation
\primitive {puts, fputs} --- écrire une chaîne sur le flux
    \index{{\tt puts}}
    \index{{\tt fputs}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int puts (const char *str)
int fputs (const char *str, FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt puts(s)} est équivalente à {\tt fputs(s,stdout)}.

La fonction {\tt fputs} écrit la chaîne de caractères {\tt str}
(terminée par le caractère nul) sur le flux {\tt flux},
et ajoute un caractère de fin de ligne.

Ces fonctions renvoient {\tt EOF} en cas d'erreur sur le flux.


\separation
\primitive {scanf, fscanf, sscanf} --- lecture formattée
    \index{{\tt scanf}}
    \index{{\tt fscanf}}
    \index{{\tt sscanf}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int scanf (const char *format, ...)
int fscanf (FILE *flux, const char *format, ...)
int sscanf (char *str, const char *format, ...)
\end{verbatim}
\end {quote}

La fonction {\tt scanf} lit ses données dans l'entrée
standard ({\tt stdin}), la fonction {\tt fscanf} lit ses données
dans le flux {\tt flux}, et la fonction {\tt sscanf} lit ses
données dans la chaîne de caractères {\tt str}.

Ces trois fonctions lisent les caractères et les interprètent en
fonction du format représenté par la chaîne de caractères {\tt format}.
Chacun des arguments suivants doit être un pointeur sur la zone mémoire
où sera rangée l'objet lu.

La chaîne de format peut contenir~:

\begin {itemize}
    \item des espaces ou des caractères \verb:\n: pour spécifier un
	nombre quelconque de blancs, \par
    \item des caractères ordinaires (pas {\tt \%}), qui doivent
	correspondre au caractère lu, \par
    \item et des spécifications de conversion commençant par le
	caractère {\tt \%}. Ces spécifications décrivent une conversion
	qui doit être effectuée et le résultat doit être rangé dans
	l'argument suivant, à moins que le caractère {\tt *} soit
	présent, auquel cas la valeur lue est ignorée.
\end {itemize}

Les spécifications de conversion sont~:

\begin {itemize}
    \item {\tt \%}~: le caractère {\tt \%} est attendu, aucune conversion
	n'est effectuée, \par
    \item {\tt d}, {\tt o}, {\tt x} ou {\tt u}~: un nombre en décimal, octal,
	hexadécimal ou décimal non signé est attendu, et l'argument
	correspondant doit être un pointeur sur un entier, \par
    \item {\tt e}, {\tt f} ou {\tt g}~: un nombre flottant est attendu, et
	l'argument doit être un pointeur sur un flottant, \par
    \item {\tt s}~: une chaîne de caractères non nulle est attendue,
	l'argument doit être un pointeur sur un tableau de
	caractères assez grand. Une chaîne vide ne peut être lue par
	{\tt \%s}, \par
    \item {\tt c}~: un caractère est attendu, et l'argument doit être
	un pointeur sur un caractère, \par
    \item {\tt [}~: indique une chaîne dont on spécifie les
	caractères. Par exemple, {\tt \%[A-H]} spécifie une chaîne ne
	contenant que des caractères entre {\tt A} et {\tt H}.
\end {itemize}

Les spécifications {\tt d}, {\tt o}, {\tt u} et {\tt x} peuvent être
précédées de la lettre {\tt l} pour indiquer une valeur longue.
De même, les spécifications {\tt e}, {\tt f} et {\tt g} précédées
de la lettre {\tt l} indiquent que l'argument est un pointeur
sur un {\tt double}.

Ces fonctions renvoient {\tt EOF} si la fin du fichier a été
détectée, ou le nombre d'arguments reconnus.



\separation
\primitive {ungetc} --- replace le caractère dans le flux d'entrée
    \index{{\tt ungetc}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

int ungetc (int c, FILE *flux)
\end{verbatim}
\end {quote}

La fonction {\tt ungetc} insère le caractère {\tt c} dans le
flux {\tt flux}, de telle sorte qu'il soit accessible par les
prochaines instructions de lecture.

Il ne peut y avoir retour que d'un seul caractère, qui doit
être identique à celui qui existait.

La fonction renvoie le caractère replacé, ou {\tt EOF} s'il y
a eû erreur.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gestion de la mémoire
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Gestion de la mémoire}


Les fonctions suivantes permettent de gérer l'allocation
dynamique de la mémoire. Cette gestion de mémoire est
similaire à la gestion du {\em tas} en Pascal (fonctions {\tt new}
et {\tt dispose} de Pascal).




\separation
\primitive {free} --- libère un espace mémoire
    \index{{\tt free}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

void free (void *pointeur)
\end{verbatim}
\end {quote}

La fonction {\tt free} libère un espace précédemment alloué
par {\tt malloc}. L'espace libéré est à nouveau disponible pour
un {\tt malloc} ultérieur.



\separation
\primitive {malloc, calloc} --- alloue un espace mémoire
    \index{{\tt malloc}}
    \index{{\tt calloc}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

void *malloc (size_t taille)
void *calloc (size_t nombre, size_t taille)
\end{verbatim}
\end {quote}

La fonction {\tt malloc} alloue un espace mémoire de
{\tt taille} octets (typiquement obtenu avec l'opérateur
{\tt sizeof}), et renvoie un pointeur sur l'espace alloué.

la fonction {\tt calloc} alloue un espace pour un tableau de
{\tt nombre} éléments de taille {\tt taille} chacun. Cet espace
est initialisé à 0.

Ces deux fonctions renvoient un pointeur sur l'espace
alloué, ou 0 si il n'y a plus de place ou si il y a eû
erreur.


\separation
\primitive {realloc} --- change la taille d'un espace mémoire
    \index{{\tt realloc}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

void *realloc (void *pointeur, size_t taille)
\end{verbatim}
\end {quote}

La fonction {\tt realloc} change la taille de l'espace alloué
à exactement {\tt taille} octets. Si l'espace n'est pas
extensible, {\tt realloc} en cherche un autre et y copie les
données.

La fonction {\tt realloc} renvoie le pointeur sur l'espace
mémoire, ou 0 si il n'y a plus de place ou si il y a eû
erreur.





\separation
\primitive {memcpy, memmove} --- copie de blocs de mémoire
    \index{{\tt memcpy}}
    \index{{\tt memmove}}
    \index{{\tt bcopy}}

\begin {quote}
\begin {verbatim}
#include <string.h>

void *memcpy (void *bloc1, const void *bloc2, size_t n)
void *memmove (void *bloc1, const void *bloc2, size_t n)

#include <strings.h>

void bcopy (const char *bloc2, char *bloc1, int n)
\end{verbatim}
\end {quote}

La fonction {\tt memcpy} copie {\tt n} octets depuis l'adresse {\tt
bloc2} jusqu'à l'adresse {\tt bloc1}. Si les deux blocs ont une
intersection commune, il faut utiliser {\tt memmove}, plus lente mais
plus sûre.

La fonction {\tt bcopy} est la version Berkeley.

La valeur de retour est {\tt bloc1}.


\separation
\primitive {memset} --- initialisation d'un bloc de mémoire
    \index{{\tt memset}}
    \index{{\tt bzero}}

\begin {quote}
\begin {verbatim}
#include <string.h>

void *memset (void *bloc, int c, size_t n)

#include <strings.h>

void bzero (char *bloc, int n)
\end{verbatim}
\end {quote}

La fonction {\tt memset} initialise à l'octet {\tt c} les {\tt n}
octets à partir de l'adresse {\tt bloc}.

La fonction {\tt bzero} est la version Berkeley (restreinte à
l'initialisation à 0).

La valeur de retour est {\tt bloc}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Les chaînes de caractères
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section {Chaînes de caractères}



Les fonctions suivantes utilisent des chaînes de caractères
terminées par un caractère nul. Elles ne vérifient pas le
débordement des chaînes passées en paramètre.




\separation
\primitive {atof, atoi, atol} --- conversion en valeur numérique
    \index{{\tt atof}}
    \index{{\tt atoi}}
    \index{{\tt atol}}


\begin {quote}
\begin {verbatim}
double atof (const char *str)
int atoi (const char *str)
long atol (const char *str)
\end{verbatim}
\end {quote}

Les fonctions de conversion permettent d'obtenir une valeur
numérique en analysant une chaîne de caractères. La fonction
inverse est obtenue en utilisant {\tt sprintf}.

La fonction {\tt atof} traduit la chaîne {\tt str} et en extrait une
valeur {\tt double}.

Les fonctions {\tt atoi} et {\tt atol} analysent la chaîne
{\tt str} et en extraient respectivement un entier et un entier
long.


\separation 
\primitive {isalpha, isupper, islower, isdigit, isspace, ispunct, isalnum, \mbox {isprint}, iscntrl, isascii} --- test sur des caractères
    \index{{\tt isalpha}}
    \index{{\tt isupper}}
    \index{{\tt islower}}
    \index{{\tt isdigit}}
    \index{{\tt isspace}}
    \index{{\tt ispunct}}
    \index{{\tt isalnum}}
    \index{{\tt isprint}}
    \index{{\tt iscntrl}}
    \index{{\tt isascii}}

\begin {quote}
\begin {verbatim}
#include <ctype.h>

int isalpha (int c)
int isupper (int c)
int islower (int c)
int isdigit (int c)
int isspace (int c)
int ispunct (int c)
int isalnum (int c)
int isprint (int c)
int iscntrl (int c)
int isascii (int c)
\end{verbatim}
\end {quote}

Ces fonctions testent un caractère et renvoient une valeur
{\em vrai} ou {\em faux}. Elles sont à utiliser de préférence, car
elles sont souvent plus rapides que des tests d'intervalle
et elles sont indépendantes du jeu de caractère utilisé
(ASCII, EBCDIC...).

La fonction {\tt isalpha} teste si le caractère est une
lettre.

La fonction {\tt isupper} teste si le caractère est une
lettre majuscule.

La fonction {\tt islower} teste si le caractère est une
lettre minuscule.

La fonction {\tt isdigit} teste si le caractère est un
chiffre.

La fonction {\tt isspace} teste si le caractère est un
caractère blanc, c'est-à-dire un espace, une tabulation, un
retour chariot, un line ffed ou un form feed.

La fonction {\tt ispunct} teste si le caractère est un
signe de ponctuation, c'est-à-dire ni un caractère de
contrôle, ni un caractère alphanumérique.

La fonction {\tt isalnum} teste si le caractère est une
lettre ou un chiffre.

La fonction {\tt isprint} teste si le caractère est
imprimable, c'est-à-dire un caractère dont le code dans
l'alphabet ASCII est compris entre 33 et 126.

La fonction {\tt iscntrl} teste si le caractère est un
code de contrôle.

La fonction {\tt isascii} teste si le caractère a un code
compris entre 0 et 127.


\separation 
\primitive {strcat, strncat} --- concaténation de chaînes
    \index{{\tt strcat}}
    \index{{\tt strncat}}

\begin {quote}
\begin {verbatim}
#include <string.h>

char *strcat (char *str1, const char *str2)
char *strncat (char *str1, const char *str2, size_t n)
\end{verbatim}
\end {quote}

Attention : la fonction \texttt {strcat} est \textbf {obsolète}, car elle ne
vérifie pas le débordement de la chaîne \texttt {str1}. Il faut
utiliser \texttt {strncat} à la place.

La fonction {\tt strcat} réalise une concaténation de la
chaîne {\tt str2} à la fin de la chaîne {\tt str1}.

La fonction {\tt strncat} concatène au plus {\tt n} caractères
de {\tt str2} dans {\tt str1}.

Ces deux fonctions renvoient la chaîne {\tt str1} comme
résultat.


\separation 
\primitive {strcmp, strncmp} --- comparaison de chaînes
    \index{{\tt strcmp}}
    \index{{\tt strncmp}}

\begin {quote}
\begin {verbatim}
#include <string.h>

int strcmp (const char *str1, const char *str2)
int strncmp (const char *str1, const char *str2, size_t n)
\end{verbatim}
\end {quote}

La fonction {\tt strcmp} compare les chaînes {\tt str1} et
{\tt str2}. La fonction {\tt strncmp} compare au plus les {\tt n}
premiers caractères des chaînes {\tt str1} et {\tt str2}.

Le résultat est un entier signifiant~:

{\tt < 0 }: str1 $<$ str2 \\
{\tt = 0 }: str1 $=$ str2 \\
{\tt > 0 }: str1 $>$ str2 


\separation 
\primitive {strcpy, strncpy} --- copie de chaînes
    \index{{\tt strcpy}}
    \index{{\tt strncpy}}

\begin {quote}
\begin {verbatim}
#include <string.h>

char *strcpy (char *str1, const char *str2)
char *strncpy (char *str1, const char *str2, size_t n)
\end{verbatim}
\end {quote}

Attention : la fonction \texttt {strcpy} est \textbf {obsolète}, car elle ne
vérifie pas le débordement de la chaîne \texttt {str1}. Il faut
utiliser \texttt {strncpy} à la place.

La fonction {\tt strcpy} copie la chaîne {\tt str2} dans la
chaîne {\tt str1} (en écrasant l'ancienne valeur de {\tt str1}).
La fonction {\tt strncpy} copie au plus {\tt n} caractères.

Ces deux fonctions renvoient la chaîne {\tt str1} en
résultat.


\separation 
\primitive {strlen} --- longueur d'une chaîne
    \index{{\tt strlen}}

\begin {quote}
\begin {verbatim}
#include <string.h>

int strlen (const char *str)
\end{verbatim}
\end {quote}

La fonction {\tt strlen} renvoie la longueur de la chaîne.


\separation 
\primitive {strchr, strrchr} --- recherche d'un caractère dans une chaîne
    \index{{\tt strchr}}
    \index{{\tt strrchr}}

\begin {quote}
\begin {verbatim}
#include <string.h>

char *strchr (const char *str, int c)
char *strrchr (const char *str, int c)
\end{verbatim}
\end {quote}

La fonction {\tt strchr} retourne un pointeur sur la première
occurrence (la dernière pour {\tt strrchr}) du caractère {\tt c}
dans la chaîne {\tt str}.

Ces deux fonctions renvoient un pointeur nul si le
caractère n'est pas trouvé.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Gestion du temps
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section {Gestion du temps}
    \label {gestion-temps}

En complément de \texttt {time} et \texttt {gettimeofday} (voir
page~\pageref {time}), les fonctions suivantes permettent d'assurer des
conversions entre des dates au format numérique (comme par exemple le
type \texttt {time\_t}) et des chaînes de caractères.


\separation 
\primitive {ctime} --- conversion simple de \texttt {time\_t} vers une chaîne
    \index{{\tt ctime}}

\begin {quote}
\begin {verbatim}
include <time.h>

char *ctime (const time_t *horloge)
\end{verbatim}
\end {quote}

La fonction {\tt ctime} renvoie une chaîne de 26 caractères
(non traduite) ayant la forme suivante~:
\begin {quote}
\begin {verbatim}
Sun Sep 16 01:03:52 1973\n\0
\end{verbatim}
\end {quote}
L'argument de {\tt ctime} est la valeur de l'horloge telle
que renvoyée par l'appel système {\tt time}. Le plus simple est
habituellement de procéder comme suit~:

\begin {quote}
\begin {verbatim}
time_t horloge ;

horloge = time (NULL) ;
strncpy (str, ctime (&horloge), 26) ;
\end{verbatim}
\end {quote}


\separation
\primitive {localtime, gmtime} --- décomposition d'une date en éléments simples (\texttt {struct tm})
    \index{{\tt localtime}}
    \index{{\tt gmtime}}

\begin {quote}
\begin {verbatim}
include <time.h>

struct tm *localtime (const time_t *horloge)
struct tm *gmtime (const time_t *horloge)
\end{verbatim}
\end {quote}


Les fonctions {\tt localtime} et {\tt gmtime} décomposent une date (au
format \texttt {time\_t}) en éléments simples (heure, minute, jour,
mois, etc.) et renvoient un pointeur sur une structure définie dans {\em
time.h}.  {\tt localtime} corrige l'heure en fonction du fuseau horaire,
alors que {\tt gmtime} donne l'heure en «~temps universel coordonné~»
(UTC).  Les structures {\tt tm} ont la forme suivante~:
    \label {struct-tm}

\begin {quote}
\begin {verbatim}
struct tm
{
    int tm_sec ;        /* secondes [0..60] */
    int tm_min ;        /* minutes [0..59] */
    int tm_hour ;       /* heures [0..23] */
    int tm_mday ;       /* jour dans le mois [1..31] */
    int tm_mon ;        /* mois [0..11] */
    int tm_year ;       /* année (année - 1900) */
    int tm_wday ;       /* jour de la semaine [0..6] */
    int tm_yday ;       /* jour dans l'année [0..365] */
    int tm_isdst ;      /* 1 si heure d'ete */
} ;
\end{verbatim}
\end {quote}


\separation
\primitive {asctime} --- conversion de \texttt {struct tm} vers une chaîne
    \index{{\tt asctime}}

\begin {quote}
\begin {verbatim}
include <time.h>

char *asctime (const struct tm *tm)
\end{verbatim}
\end {quote}


La fonction {\tt asctime} traduit une structure \texttt {tm} (telle que
retournée par la fonction~\texttt {localtime} par exemple) en une chaîne
de 26 caractères, de manière analogue à \texttt {ctime}.


\separation
\primitive {strftime} --- conversion d'une date en une chaîne de caractères
    \index{{\tt strftime}}

\begin {quote}
\begin {verbatim}
include <time.h>

size_t strftime (char *s, size_t max, const char *format, const struct tm *tm)
\end{verbatim}
\end {quote}

Cette fonction convertit une date fournie sous forme d'une structure
\texttt {tm} (voir \texttt {localtime}, page~\pageref {struct-tm}) en
une chaîne de caractères \texttt {s} (de taille \texttt {max} octets),
suivant les conversions indiquées par \texttt {format}.
Comme avec \texttt {printf}, le format est une chaîne de caractères
qui contient deux sortes d'objets~:  les caractères simples, qui sont
affichés normalement, et les formats de conversion commençant par un
caractère {\tt \%}, régis par la syntaxe suivante (les éléments entre
crochets sont optionnels)~:

{\tt \%} [{\tt 0}] [{\tt +}] [<nombre>] [\texttt {E}\texttt {O}] \textit {conversion}\texttt {\%}

\begin {itemize}
    \item le caractère {\tt 0} indique que le caractère «~0~»
	doit être utilisé pour atteindre le nombre de caractères
	minimum spécifié~;

    \item le caractère {\tt +} indique comme précédemment que
	le caractère «~0~» doit être utilisé pour atteindre le
	nombre de caractères minimum spécifié, mais également que
	si le nombre converti dépasse la limite (4 pour une année,
	ou 2 pour une année dans le siècle), un «~+~» ou un «~-~»
	doit être ajouté suivant la valeur~;

    \item vient ensuite le nombre de caractères minimum de la valeur
	convertie, un ajout de «~0~» ou d'espaces étant effectué si
	la valeur ne remplit pas ce nombre de caractères~;

    \item un argument optionnel «~\texttt {E}~» ou «~\texttt {O}~»
	permet de requérir une représentation alternative de la valeur
	convertie (dépendant de la localisation)~;

    \item enfin, le dernier caractère indique la conversion demandée,
	parmi lesquelles~: \\
	{\tt a}~: jour de la semaine (abrégé) \\
	{\tt A}~: jour de la semaine (complet) \\
	{\tt b}~: mois (abrégé) \\
	{\tt B}~: mois (complet) \\
	{\tt c}~: date et heure \\
	{\tt d}~: jour du mois [01..31] (sur 2 chiffres) \\
	{\tt H}~: heure [00..23] (sur 2 chiffres) \\
	{\tt m}~: mois [01..12] (sur 2 chiffres) \\
	{\tt M}~: minute [00..59] (sur 2 chiffres) \\
	{\tt S}~: seconde [00..60] (sur 2 chiffres) \\
	{\tt T}~: équivalent à \verb|%H:%M:%S| \\
	{\tt Y}~: année (sur 4 chiffres) \\
	{\tt \%}~: affichage d'un caractère {\tt \%}

\end {itemize}

Par exemple, pour afficher la date et l'heure courante, on peut utiliser~:
\begin {quote}
\begin {verbatim}
time_t horloge ;
struct tm *tm ;
char date [256] ;
size_t n ;

horloge = time (NULL) ;
tm = localtime (&horloge) ;
n = strftime (date, sizeof date, "Aujourd'hui : %d/%m/%Y %T", tm) ;
if (n > 0)
    printf ("%s\n", date) ;
\end{verbatim}
\end {quote}

La valeur de retour correspond au nombre d'octets (non compris l'octet
nul terminal) placés dans la chaîne résultat, ou 0 si la conversion
n'est pas possible (format invalide ou pas assez de place).


\separation
\primitive {strptime} --- conversion d'une chaîne de caractères en une date
    \index{{\tt strptime}}

\begin {quote}
\begin {verbatim}
include <time.h>

char *strptime (const char *chaine, const char *format, struct tm *tm)
\end{verbatim}
\end {quote}

La fonction \texttt {strptime} convertit une date (telle que saisie par
l'utilisateur) de la chaîne de caractères \texttt {chaine} vers une
date représentée par la structure \texttt {tm} (voir définition de
la fonction \texttt {localtime}, page~\pageref {struct-tm}), suivant le
format indiqué (voir \texttt {strftime} pour les principaux formats).

Si la conversion réussit, la fonction renvoie un pointeur vers le
caractère suivant la date convertie (dans \texttt {chaine}). Sinon,
elle renvoie un pointeur nul.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonctions associées aux sockets Berkeley
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Fonctions associées aux sockets Berkeley}

Les fonctions ci-après sont le complément indispensable de l'utilisation
des sockets Berkeley.  En particulier, certaines d'entre elles
permettent de rechercher les informations utiles dans les divers
fichiers de configuration du réseau.


\separation
\primitive {getaddrinfo, gai\_strerror, freeaddrinfo} --- informations
    nécessaires pour un dialogue IPv4 ou IPv6
    \index{{\tt getaddrinfo}}
    \index{{\tt gai\_strerror}}
    \index{{\tt freeaddrinfo}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo (const char *nom, const char *service, const struct addrinfo *indic,
                 struct addrinfo **res0)
const char *gai_strerrror (int code)
void freeaddrinfo (struct addrinfo *ai)
\end{verbatim}
\end {quote}

La fonction \texttt {getaddrinfo} recherche les informations
nécessaires (adresses IPv4 et/ou IPv6, numéro de port) pour initier
un dialogue à travers le réseau.

Dans le cas d'un client, \texttt {getaddrinfo} est utilisée pour
identifier le service distant (nom de machine ou adresse IP, port
TCP ou UDP).  Cette fonction renvoie plusieurs résultats (une machine
peut avoir plusieurs adresses IPv4 et/ou IPv6), via une liste dont
la tête sera pointée en retour par \texttt {res0}, destinés à être
utilisés avec les primitives \texttt {socket} et \texttt {connect}
(pour TCP) ou \texttt {sendto} (pour UDP).

Dans le cas d'un serveur, \texttt {getaddrinfo} est utilisée pour
identifier un service (port TCP ou UDP). Le nom fourni doit être
\texttt {NULL} dans ce cas. Cette fonction renvoie plusieurs résultats
(par exemple un pour IPv4 et un pour IPv6), via une liste dont la
tête sera pointée en retour par \texttt {res0}. Ces résultats sont
destinés à être utilisés avec les primitives \texttt {socket} et
\texttt {bind} (pour TCP) ou \texttt {recvfrom} (pour UDP). En
présence de plusieurs sockets, le serveur devra utiliser \texttt
{select} pour attendre les connexions (via \texttt {accept}) en
parallèle.

La structure \texttt {addrinfo} contient les champs suivants~:

\begin {quote}
    \small
\begin {verbatim}
    int ai_flags ;             /* flags pour le paramètre indic */
    int ai_family ;            /* famille de protocoles pour socket() */
    int ai_socktype ;          /* type de socket (SOCK_STREAM ou SOCK_DGRAM) */
    int ai_protocol ;          /* protocole TCP, UDP, etc. trouvé */
    socklen_t ai_addrlen ;     /* taille de l'adresse trouvée */
    struct sockaddr *ai_addr ; /* adresse trouvée */
    char *ai_canonname ;       /* nom canonique trouvé */
    struct addrinfo *ai_next ; /* suivant dans la liste */
\end{verbatim}
\end {quote}

Le paramètre \texttt {indic} fournit des indications sur le type 
de recherche demandée~:

\begin {itemize}
    \item si le bit \texttt {AI\_PASSIVE} est positionné dans \texttt
	{ai\_flags}, \texttt {getaddrinfo} fournit des résultats pour
	un serveur~;

    \item le champ \texttt {ai\_family} est utilisé pour restreindre
	les adresses à IPv4 (\texttt {PF\_INET}) ou IPv6 (\texttt
	{PF\_INET6}) seulement, ou pour autoriser les deux (\texttt
	{PF\_UNSPEC})~;

    \item le champ \texttt {ai\_socktype} est utilisé pour spécifier
	si la communication est basée sur une connexion fiable
	(\texttt {SOCK\_STREAM}, soit TCP) ou sur le mode datagramme
	(\texttt {SOCK\_DGRAM}, soit UDP).

\end {itemize}

La fonction \texttt {getaddrinfo} renvoie 0 en cas de réussite.
Dans le cas d'une erreur, un code est renvoyé qui peut être converti
en chaîne de caractères avec la fonction \texttt {gai\_strerror}.

La fonction {\tt freeaddrinfo} désalloue la liste retournée par
\texttt {getaddrinfo} (paramètre \texttt {res0}).


\separation
\primitive {getnameinfo} --- traduit une adresse IPv4 ou IPv6 en nom
    \index{{\tt getnameinfo}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netdb.h>

int getnameinfo (const struct sockaddr *adr, socklen_t longadr, char *nom, size_t longnom,
                 char *service, size_t longserv, int flags)
\end{verbatim}
\end {quote}

La fonction \texttt {getnameinfo} convertit une structure \texttt
{sockaddr} (paramètre \texttt {adr}) en un nom de machine et un nom
de service (s'il est trouvé dans \texttt {/etc/services}).

Les bits du paramètre \texttt {flags} modifient la manière dont la
conversion est effectuée~:

\begin {itemize}
    \item le bit \texttt {NI\_NOFQDN} indique que le nom retourné
	ne doit pas être pleinement qualifié (i.e. sans le domaine)~;

    \item le bit \texttt {NI\_NUMERICHOST} indique que le nom
	retourné doit être sous forme numérique (comme avec un appel
	à \texttt {inet\_ntop}) sans recherche dans le DNS~;

    \item le bit \texttt {NI\_NAMREQD} indique que la recherche
	DNS doit forcément retourner un nom. Si aucun nom n'existe
	pour l'adresse contenue dans le paramètre \texttt {sa}, une
	erreur est retournée~;

    \item le bit \texttt {NI\_DGRAM} indique que le service doit
	être recherché en UDP (et non en TCP par défaut).

\end {itemize}

La valeur renvoyée est 0 en cas de réussite. Dans le cas contraire,
un code d'erreur est renvoyé qui peut être converti en chaîne de
caractères avec la fonction \texttt {gai\_strerror}.


\separation
\primitive {gethostbyname, gethostbyaddr,
endhostent} --- obtention de l'adresse IPv4
    \index{{\tt gethostbyname}}
    \index{{\tt gethostbyaddr}}
    \index{{\tt endhostent}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

struct hostent *gethostbyname (const char *nom)
struct hostent *gethostbyaddr (const char *adresse, int longueur, int type)
int endhostent (void)
\end{verbatim}
\end {quote}

Attention : ces fonctions sont \textbf {obsolètes} car elles ne gèrent que
des adresses IPv4. Il faut utiliser \texttt {getaddrinfo} et \texttt
{getnameinfo} à la place.

La fonction {\tt gethostbyname} ouvre le fichier {\tt /etc/hosts}
ou accède au serveur de noms (système de nommage DNS), selon la
configuration, et obtient la ou les adresses de la machine de nom
{\tt nom}. Le résultat est placé dans une structure~:

\begin {quote}
    \small
\begin {verbatim}
struct hostent
{
    char *h_name ;         /* nom de la machine */
    char **h_aliases ;     /* acces aux aliases par h_aliases[i] */
    int  h_addrtype ;      /* toujours AF_INET */
    int  h_length ;        /* longueur de l'adresse en octets */
    char **h_addr_list ;   /* acces aux adresses par h_addr_list[i] */
} ;
#define h_addr h_addr_list[0] /* acces facile a la premiere adresse */
\end{verbatim}
\end {quote}

Les tableaux pointés par {\tt h\_aliases} et {\tt h\_addr\_list} sont
terminés par une case nulle pour signaler la fin. Si le nom requis
n'existe pas, la valeur {\tt NULL} est retournée.

La fonction {\tt gethostbyaddr} ouvre le fichier {\tt /etc/hosts} ou
accède au serveur de noms (système de nommage DNS), selon la
configuration, et obtient le nom de la machine d'adresse {\tt
adresse} (la longueur de l'adresse est {\tt longueur} octets et le
type d'adresse {\tt type} est toujours {\tt AF\_INET}). Le résultat
est placé dans une structure {\tt hostent}. Si l'adresse requise
n'est pas trouvée, la valeur {\tt NULL} est retournée.

La fonction {\tt endhostent} ferme le fichier {\tt /etc/hosts} ou clot
la connection avec le serveur de noms s'il est configuré.


\separation
\primitive {getnetbyname, getnetbyaddr,
endnetent} --- lecture de {\tt /etc/networks}
    \index{{\tt getnetbyname}}
    \index{{\tt getnetbyaddr}}
    \index{{\tt endnetent}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netdb.h>

struct netent *getnetbyname (const char *nom)
struct netent *getnetbyaddr (int reseau, int type)
int endnetent (void)
\end{verbatim}
\end {quote}

Attention : ces fonctions sont \textbf {obsolètes} car elles ne gèrent que
des adresses IPv4.

La fonction {\tt getnetbyname} ouvre le fichier {\tt /etc/networks} et
obtient le numéro du réseau de nom {\tt nom}.  Le résultat est placé
dans une structure~:

\begin {quote}
    \small
\begin {verbatim}
struct servent
{
    char *n_name ;         /* nom officiel du netice */
    char **n_aliases ;     /* acces aux aliases par p_aliases[i] */
    int  n_addrtype ;      /* toujours AF_INET */
    unsigned long n_net ;  /* numero de reseau */
} ;
\end{verbatim}
\end {quote}

La fonction {\tt getnetbyaddr} ouvre le fichier {\tt /etc/networks} et
obtient le nom du réseau de numéro {\tt reseau} (le type d'adresse {\tt
type} doit être la constante {\tt AF\_INET}).  Le résultat est placé
dans une structure {\tt netent}.  Si le numéro de réseau demandé n'est
pas trouvé, la valeur {\tt NULL} est retournée.

La fonction {\tt endnetent} ferme le fichier {\tt /etc/networks}.


\separation
\primitive {getprotobyname, getprotobynumber,
endprotoent} --- lecture de {\tt /etc/protocols}
    \index{{\tt getprotobyname}}
    \index{{\tt getprotobynumber}}
    \index{{\tt endprotoent}}

\begin {quote}
\begin {verbatim}
#include <netdb.h>

struct protoent *getprotobyname (const char *nom)
struct protoent *getprotobynumber (int proto)
int endprotoent (void)
\end{verbatim}
\end {quote}

La fonction {\tt getprotobyname} ouvre le fichier {\tt /etc/protocols}
et obtient le numéro du protocole de nom {\tt nom}.  Le résultat est
placé dans une structure~:

\begin {quote}
    \small
\begin {verbatim}
struct protoent
{
    char *p_name ;         /* nom officiel du protocole */
    char **p_aliases ;     /* acces aux aliases par p_aliases[i] */
    int  p_proto ;         /* numero de protocole */
} ;
\end{verbatim}
\end {quote}

La fonction {\tt getprotobynumber} ouvre le fichier {\tt /etc/protocols}
et obtient le nom du protocole de numéro {\tt proto}.  Le résultat est
placé dans une structure {\tt protoent}.  Si le numéro demandé n'est pas
trouvé, la valeur {\tt NULL} est retournée.

La fonction {\tt endprotoent} ferme le fichier {\tt /etc/protocols}.


\separation
\primitive {getservbyname, getservbyport,
endservent} --- lecture de {\tt /etc/services}
    \index{{\tt getservbyname}}
    \index{{\tt getservbyport}}
    \index{{\tt endservent}}

\begin {quote}
\begin {verbatim}
#include <netdb.h>

struct servent *getservbyname (const char *nom)
struct servent *getservbyport (int port)
int endservent (void)
\end{verbatim}
\end {quote}

La fonction {\tt getservbyname} ouvre le fichier {\tt /etc/services} et
obtient le numéro de port du service de nom {\tt nom}.  Le résultat est
placé dans une structure~:

\begin {quote}
    \small
\begin {verbatim}
struct servent
{
    char *s_name ;         /* nom officiel du service */
    char **s_aliases ;     /* acces aux aliases par p_aliases[i] */
    int  s_port ;          /* numero de port du service */
    char *s_proto ;        /* protocole a utiliser */
} ;
\end{verbatim}
\end {quote}

La fonction {\tt getservbyport} ouvre le fichier {\tt /etc/services} et
obtient le nom du service de numéro de port {\tt port}.  Le résultat est
placé dans une structure {\tt servent}.  Si le numéro de port demandé
n'est pas trouvé, la valeur {\tt NULL} est retournée.

La fonction {\tt endservent} ferme le fichier {\tt /etc/services}.


\separation
\primitive {htonl, htons, ntohl, ntohs} --- conversions
    \index{{\tt htonl}}
    \index{{\tt htons}}
    \index{{\tt ntohl}}
    \index{{\tt ntohs}}

\begin {quote}
\begin {verbatim}
#include <arpa/inet.h>

uint32_t htonl (uint32_t l)
uint16_t htons (uint16_t s)
uint32_t ntohl (uint32_t l)
uint16_t ntohs (uint16_t s)
\end{verbatim}
\end {quote}

Ces fonctions convertissent des nombres de 16 ou 32 bits de format {\em
host} (suivant le type de processeur) en format {\em network} (bit le
plus significatif en premier) et réciproquement.  Ces routines sont
fréquemment utilisées avec les fonctions {\tt gethost*} et {\tt
getserv*} pour écrire des programmes portables.

Lorsque les formats {\em host} et {\em network} sont équivalents, ces
fonctions sont toujours définies, mais elles sont vides.


\separation
\primitive {inet\_ntop, inet\_pton} --- conversion d'adresse IPv4 ou IPv6
    \index{{\tt inet\_ntop}}
    \index{{\tt inet\_pton}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

const char *inet_ntop (int famille, const void *src, char *dst, socklen_t max)
int inet_pton (int famille, const char *src, void *dst)
\end{verbatim}
\end {quote}

La fonction \texttt {inet\_ntop} convertit, dans la famille indiquée
par le paramètre \texttt {famille} (soit \texttt {AF\_INET} ou
\texttt {AF\_INET6}) une adresse du format «~réseau~» (indiquée par
le paramètre \texttt {src}, typiquement l'adresse d'une structure
\texttt {in\_addr} ou \texttt {in\_addr6}) vers le format
«~présentation~», c'est-à-dire sous forme d'une chaîne de caractères.
Celle-ci est placée à l'adresse indiquée par le paramètre \texttt
{dst} et la taille maximum (ex: \texttt {INET\_ADDRSTRLEN} ou \texttt
{INET6\_ADDRSTRLEN}) est indiquée par le paramètre \texttt {max}.
Cette fonction renvoie le pointeur nul en cas d'erreur (auquel cas
la variable \texttt {errno} indique la raison de l'erreur), ou le
pointeur vers la chaîne \texttt {dst} en cas de réussite.

La fonction \texttt {inet\_pton} convertit une adresse numérique
fournie en format «~présentation~» (chaîne de caractères indiquée
par le paramètre \texttt {src}) vers le format «~réseau~», placée
à l'adresse indiquée par le paramètre \texttt {dst} (typiquement
l'adresse d'une structure \texttt {in\_addr} ou \texttt {in\_addr6}).
Le paramètre \texttt {famille} vaut \texttt {AF\_INET} ou \texttt
{AF\_INET6}.


\separation
\primitive {inet\_addr, inet\_network, inet\_makeaddr, inet\_lnaof,
inet\_netof} --- manipulation d'adresses IPv4
    \index{{\tt inet\_addr}}
    \index{{\tt inet\_network}}
    \index{{\tt inet\_makeaddr}}
    \index{{\tt inet\_lnaof}}
    \index{{\tt inet\_netof}}

\begin {quote}
\begin {verbatim}
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

unsigned long inet_addr (const char *chaine)
unsigned long inet_network (const char *chaine)
char *inet_ntoa (struct in_addr in)
struct in_addr inet_makeaddr (int net, int lna)
int inet_lnaof (struct in_addr in)
int inet_netof (struct in_addr in)
\end{verbatim}
\end {quote}

Attention : ces fonctions sont \textbf {obsolètes} car elles ne gèrent que
des adresses IPv4. Il faut utiliser \texttt {inet\_ntop} et \texttt
{inet\_pton} à la place.

Les fonctions {\tt inet\_addr} et {\tt inet\_network} prennent en entrée
une spécification d'adresse ou de réseau IPv4 sous la forme de nombres
séparés par des points (par exemple~: 127.0.0.1), et renvoient des
nombres utilisables dans des structures {\tt in\_addr}. Par exemple~:

\begin {quote}
\begin {verbatim}
struct in_addr a ;
a.s_addr = inet_addr ("127.0.0.1") ;
\end{verbatim}
\end {quote}

La fonction {\tt inet\_ntoa} fait la conversion inverse.

La fonction {\tt inet\_makeaddr} construit, à partir du numéro de réseau
{\tt net} et du numéro de machine dans le réseau {\tt lna}, l'adresse IPv4
de la machine correspondante. Cette adresse est retournée dans le format
{\em network}.

Les fonctions {\tt inet\_lnaof} et {\tt inet\_netof} décomposent
respectivement, à partir d'une adresse IPv4 {\tt in}, l'adresse en partie
``numéro de machine dans le réseau'' et en partie ``numéro de réseau''.



\separation
\primitive {openlog, syslog, closelog, setlogmask} --- messages système
    \index{{\tt openlog}}
    \index{{\tt syslog}}
    \index{{\tt closelog}}
    \index{{\tt setlogmask}}

\begin {quote}
\begin {verbatim}
#include <syslog.h>

int openlog (const char *nom, int options, int categorie)
int syslog (int prio, const char *format, ...)
int closelog (void)
int setlogmask (int masque)
\end{verbatim}
\end {quote}

Ces fonctions permettent de simplifier l'écriture des messages des
démons (pas forcément liés aux sockets) via le démon {\tt syslogd}.
Chaque démon choisit une catégorie et, pour chaque message, une
priorité. Le fichier {\tt openlog.h} contient la liste des catégories et
priorités utilisables.

% La table ci-après décrit quelques catégories~:
% 
% {\small
% \begin {quote}
%     \begin {tabular} {|l|l|} \hline
% 	\tt LOG\_KERN &
% 	    messages du noyau
% 	\tt LOG\_USER &
% 	    messages ne rentrant dans aucune autre catégorie
% 	    \\
% 	\tt LOG\_MAIL &
% 	    messages ayant trait à la gestion du courrier
% 	    \\
% 	\tt LOG\_DAEMON &
% 	    messages en provenance de divers démons
% 	    \\
% 	\tt LOG\_AUTH &
% 	    messages ayant trait à la sécurité
% 	    \\
% 	\tt LOG\_LPR &
% 	    messages du gestionnaire d'imprimante
% 	    \\
% 	\tt LOG\_LOCAL0 {\rm à} LOG\_LOCAL7 &
% 	    réservés pour utilisation locale
% 	    \\
% 	\hline
%     \end {tabular}
% \end {quote}
% }
% 
% La table suivante donne quelques priorités~:
% 
% {\small
% \begin {quote}
%     \begin {tabular} {|l|l|} \hline
% 	\tt LOG\_EMERG &
% 	    urgence, le système va s'arrêter
% 	\tt LOG\_ALERT &
% 	    situation devant être corrigée immédiatement
% 	    \\
% 	\tt LOG\_CRIT &
% 	    condition critique, telle qu'une erreur matérielle
% 	    \\
% 	\tt LOG\_ERR &
% 	    erreur
% 	    \\
% 	\tt LOG\_WARNING &
% 	    messages d'avertissement
% 	    \\
% 	\tt LOG\_NOTICE &
% 	    message demandant une intervention manuelle
% 	    \\
% 	\tt LOG\_INFO &
% 	    bon à savoir
% 	    \\
% 	\tt LOG\_DEBUG &
% 	    messages de debogage
% 	    \\
% 	\hline
%     \end {tabular}
% \end {quote}
% }

La fonction {\tt openlog} initialise l'accès à {\tt syslogd}. Le nom est
une chaîne de caractères qui sert à identifier le programme émetteur des
messages dans le log. C'est habituellement le nom du programme. Les
options permettent notamment d'inscrire avec chaque message le numéro du
processus émetteur (option {\tt LOG\_PID}), ou alors d'inscrire les
messages sur la console du système si {\tt syslogd} ne fonctionne pas
(option {\tt LOG\_CONS}). La catégorie correspond à la catégorie par
défaut de tous les messages émis avec {\tt syslog}.

La fonction {\tt syslog} fonctionne de manière similaire à {\tt printf}.
Elle écrit le {\tt format} avec tous ses arguments. Les caractères {\tt
\%m} sont remplacés par le texte correspondant à {\tt errno} s'il y en a
un.  Le paramètre {\tt priorité} est la priorité du message.

La fonction {\tt closelog} clot l'accès à {\tt syslogd}.

La fonction {\tt setlogmask} permet de spécifier les priorités qui
doivent être prises en compte par {\tt syslog}. Il est ainsi possible de
rejeter automatiquement un ou plusieurs niveaux de priorité.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Fonctions système
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section {Fonctions système}



Les fonctions ci-après sont orientées vers l'utilisation du
système.



\separation 
\primitive {ftok} --- création d'une clef pour les IPC System V
    \index{{\tt ftok}}

\begin {quote}
\begin {verbatim}
#include <sys/ipc.h>

key_t ftok (const char *fichier, int id)
\end{verbatim}
\end {quote}

La fonction {\tt ftok} construit une clef adaptée aux primitives ({\tt
msgget}, {\tt semget} et {\tt shmget}) à part d'un nom de fichier et d'un
numéro {\tt id}.

Si le fichier n'est pas accessible, la valeur -1 (ou plus exactement
\verb|((key_t)-1)|) est retournée.


\separation 
\primitive {getcwd} --- répertoire courant
    \index{{\tt getcwd}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

char *getcwd (char *buffer, size_t taille)
\end{verbatim}
\end {quote}

La fonction {\tt getcwd} calcule le nom du répertoire courant et le
place dans le tableau de caractères (déclaré par l'appelant). La
fonction {\tt getcwd} n'essayera pas de placer plus de {\tt taille}
caractères dans ce tableau.

La valeur retourbée est l'adresse du premier caractère du tableau, ou
{\tt NULL} s'il n'est pas assez grand ou s'il y a eû une erreur.


\separation 
\primitive {getenv} --- valeur d'une variable shell
    \index{{\tt getenv}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

char *getenv (const char *var)
\end{verbatim}
\end {quote}

La fonction {\tt getenv} permet de récupérer la valeur d'une
variable du shell. Le résultat est un pointeur
dans l'environnement courant sur le contenu de la variable,
ou 0 si la variable {\tt var}
n'existe pas.


\separation 
\primitive {getopt} --- analyser les options de la ligne de commande
    \index{{\tt getopt}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int getopt (int argc, char *const argv [], const char *optstring)

extern char *optarg ;
extern int optind, opterr ;
\end{verbatim}
\end {quote}

La fonction {\tt getopt} permet d'analyser les arguments de
la ligne de commande. la chaîne {\tt optstring} décrit les
options valides~: une lettre seule décrit une option sans
argument, une lettre suivie d'un caractère {\tt :} est une
option qui admet un argument, séparé ou non par des espaces.
La variable {\tt optarg} pointe alors sur le texte de
l'argument.

{\tt getopt} place dans la variable {\tt optind} l'indice dans
{\tt argv} du prochain argument à traiter. Quand toutes les
options sont traitées, {\tt getopt} renvoie {\tt EOF}.

Exemple~:

\begin {quote}
\begin {verbatim}
main (argc, argv)
int argc ;
char *argv [] ;
{
    int c, errflg = 0 ;
    extern char *optarg ;
    extern int optind ;

    ...
    while ((c = getopt (argc, argv, "abf:o:")) != EOF)
        switch (c)
        {
            case 'a' :     /* option sans argument */
                aflag++ ;
                break ;
            case 'b' :
                bflag++ ;
                break ;
            case 'f' :     /* option avec argument */
                input = optarg ;
                break ;
            case 'o' :
                output = optarg ;
                break ;
            case '?' :     /* option non reconnue */
                errflg++ ;
                break ;
        }
        if (errflg)
        {
            fprintf (stderr, "usage:....") ;
            exit (2) ;
        }
        for ( ; optind < argc; optind++)
        {
            fp = fopen (argv [optind], "r") ;
            ...
        }
}
\end{verbatim}
\end {quote}


\separation 
\primitive {isatty, ttyname} --- nom du terminal
    \index{{\tt isatty}}
    \index{{\tt ttyname}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

int isatty (int descripteur)
char *ttyname (int descripteur)
\end{verbatim}
\end {quote}

La fonction {\tt isatty} renvoie 1 si {\tt descripteur} correspond
à un terminal, 0 sinon.

La fonction {\tt ttyname} renvoie un pointeur sur une chaîne contenant
le nom du terminal associé au {\tt descripteur}, ou {\tt NULL} si le
{\tt descripteur} ne correspond à aucune entrée dans {\tt /dev}. La
chaîne retournée est placée dans une zone statique, réutilisée à chaque
appel.



\separation
\primitive {mkfifo} --- crée un tube nommé
    \index{{\tt mkfifo}}
    \label {mkfifo}

\begin {quote}
\begin {verbatim}
#include <sys/stat.h>

int mkfifo (const char *nom, mode_t mode)
\end{verbatim}
\end {quote}

La fonction {\tt mkfifo} crée un tube nommé ({\em fifo}).
Les permissions sont initialisées avec la valeur de {\tt mode}
(voir {\tt chmod}).

Cette fonction renvoie 0 en cas de création
réussie, ou -1 en cas d'erreur.




\separation 
\primitive {mktemp} --- nom de fichier unique
    \index{{\tt mktemp}}

\begin {quote}
\begin {verbatim}
#include <unistd.h>

char *mktemp (char *modele)
\end{verbatim}
\end {quote}

Cette fonction est \textbf {obsolète}. Il vaut mieux utiliser {\tt tmpfile} et
{\tt tmpnam} (voir page~\pageref {tmpfile}).

La fonction {\tt mktemp} remplace le contenu de la chaîne de
caractères {\tt modele} par un nom de fichier unique, et
renvoie l'adresse de la chaîne.

Le modèle doit être un nom de fichier suivi de 6 caractères
{\it X}. La fonction remplace ces 6 {\it X} par une lettre et un
numéro de telle sorte que le fichier n'ait pas un nom
identique à celui d'un fichier existant.

Si {\tt mktemp} ne peut renvoyer de nom de fichier unique, il
renvoie la chaîne vide, c'est-à-dire la chaîne dont le
premier caractère est \verb:\0:.




\separation 
\primitive {perror, strerror} --- messages d'erreur du système
    \index{{\tt perror}}
    \index{{\tt strerror}}

\begin {quote}
\begin {verbatim}
#include <errno.h>

void perror (const char *str)
char *strerror (int numero)

extern int errno ;
\end{verbatim}
\end {quote}

Lorsqu'une erreur survient dans un appel système (les
appels systèmes sont utilisés par les fonctions de la
librairie), la variable exerne {\tt errno} est initialisée avec
le numéro de l'erreur.

La fonction {\tt perror} affiche le message correspondant,
précédé de la chaîne {\tt str} (qui est typiquement le nom du programme
courant).

La fonction {\tt strerror} retourne un pointeur sur une chaîne de
caractères contenant le message correspond à l'erreur de numéro {\tt
numero}. Cette chaîne ne doit pas être modifiée.



\separation 
\primitive {rand, srand} --- génération de nombres aléatoires
    \index{{\tt rand}}
    \index{{\tt srand}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

int rand (void)
void srand (unsigned int semence)
\end{verbatim}
\end {quote}

La fonction {\tt rand} retourne une valeur pseudo-aléatoire comprise
entre 0 et \texttt {RAND\_MAX}-1 (historiquement~: $2^{15}-1$).

La fonction {\tt srand} initialise la {\tt semence} de l'algorithme de
génération afin de changer la séquence de génération des valeurs.
Par défaut, la valeur initiale de {\tt semence} est 1.




\separation 
\primitive {setjmp, longjmp} --- saut externe à une fonction
    \index{{\tt setjmp}}
    \index{{\tt longjmp}}

\begin {quote}
\begin {verbatim}
#include <setjmp.h>

int setjmp (jmp_buf env)
void longjmp (jmp_buf env, int discriminant)
\end{verbatim}
\end {quote}

La fonction {\tt setjmp} est assimilable à une étiquette, et
{\tt longjmp} à un {\tt goto}. L'avantage de ces routines est que
les sauts peuvent intervenir même à l'extérieur d'une
procédure ou d'une fonction. La seule condition est qu'un
branchement ne peut se faire qu'à un endroit où il y a déjà
eû exécution.

{\tt setjmp} sauve l'endroit (pointeur programme et pointeur
dans la pile d'exécution) dans le buffer {\tt env}, et renvoie
0.

On peut alors exécuter {\tt longjmp} avec une valeur
{\tt discriminant}. L'exécution reprend alors juste après le
{\tt setjmp} correspondant, et la pseudo-valeur de retour de
{\tt setjmp} est la valeur {\tt discriminant}.





\separation 
\primitive {sigemptyset, sigfillset, sigaddset, sigdelset, sigismember} ---
manipulation des masques de signaux
    \index{{\tt sigemptyset}}
    \index{{\tt sigfillset}}
    \index{{\tt sigaddset}}
    \index{{\tt sigdelset}}
    \index{{\tt sigismember}}
    \label {sigsetopts}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int sigemptyset (sigset_t *masque) ;
int sigfillset (sigset_t *masque) ;
int sigaddset (sigset_t *masque, int sig) ;
int sigdelset (sigset_t *masque, int sig) ;
int sigismember (const sigset_t *masque, int sig) ;
\end{verbatim}
\end {quote}

Ces fonctions manipulent des ensembles (masques) de signaux.  Le type
{\tt sigset\_t} est un type {\em opaque}~:  sa définition n'est pas
connue, mais il y a des fonctions pour le manipuler.

La fonction {\tt sigemptyset} initialise l'ensemble de telle façon
qu'aucun signal n'est inclus.

La fonction {\tt sigfillset} initialise l'ensemble de telle façon que
tous les signaux soient inclus.

Les fonctions {\tt sigaddset} (resp. {\tt sigdelset}) ajoutent
(resp. suppriment) un signal de l'ensemble.

Ces fonctions renvoient 0 si l'opération est réussie, -1 sinon.

La fonction {\tt sigismember} teste si le signal {\tt sig} est dans
l'ensemble. La valeur renvoyée est 1 si le signal est dans l'ensemble
ou 0 sinon.



\separation 
\primitive {sleep} --- attend un nombre de secondes
    \index{{\tt sleep}}

\begin {quote}
\begin {verbatim}
unsigned int sleep (unsigned int secondes)
\end{verbatim}
\end {quote}

La fonction {\tt sleep} met le processus en attente pendant un temps
spécifié par le paramètre {\tt secondes}.

La valeur retournée est 0 si {\tt sleep} s'est terminée normalement sans
être interrompue par un signal, ou un temps (en secondes) restant
si elle s'est terminée à cause d'un signal.


\separation 
\primitive {nanosleep} --- attend un nombre de nano-secondes
    \index{{\tt nanosleep}}

\begin {quote}
\begin {verbatim}
int nanosleep(const struct timespec *duree, struct timespec *reste)
\end{verbatim}
\end {quote}

La fonction {\tt nanosleep} met le processus en attente pendant un temps
spécifié par le paramètre {\tt duree}. La structure \texttt {timespec}
contient les champs suivants~:
\begin {quote}
    \small
\begin {verbatim}
struct timespec
{
    time_t tv_sec ;     /* secondes depuis l'époque (cf time()) */
    long tv_nsec ;      /* et nanosecondes */
} ;
\end{verbatim}
\end {quote}

La structure pointée par le paramètre \texttt {reste} contient, si
\texttt {nanosleep} est interrompue par un signal, le temps restant
à attendre.

La valeur retournée est 0 si {\tt nanosleep} s'est terminée normalement
sans être interrompue par un signal. Dans le cas contraire, la valeur de
retour est -1 et la structure pointée par le paramètre \texttt {reste},
s'il est non nul, est mise à jour.


\separation 
\primitive {system} --- appeler une commande shell
    \index{{\tt system}}

\begin {quote}
\begin {verbatim}
#include <stdlib.h>

int system (const char *commande)
\end{verbatim}
\end {quote}

La fonction {\tt system} appelle le shell, et lui passe la
commande {\tt commande} comme si elle avait été tapée au
terminal. L'exécution est suspendue jusqu'à ce que la
commande soit finie.

Si {\tt system} ne peut lancer la commande, une valeur
négative est renvoyée.



\separation 
\primitive {tmpfile} --- ouvre un fichier unique
    \index{{\tt tmpfile}}
    \label {tmpfile}).

\begin {quote}
\begin {verbatim}
#include <stdio.h>

FILE *tmpfile (void)
\end{verbatim}
\end {quote}

La fonction {\tt tmpfile} crée un fichier unique, l'ouvre et renvoie son
descripteur. Le fichier est automatiquement détruit à la fin de
l'exécution du processus.


\separation 
\primitive {tmpnam, tempnam} --- nom de fichier unique
    \index{{\tt tmpnam}}
    \index{{\tt tempnam}}

\begin {quote}
\begin {verbatim}
#include <stdio.h>

char *tmpnam (char *adresse)
char *tmpnam ((char *) 0)
char *tempnam (const char *repertoire, const char *prefixe)
\end{verbatim}
\end {quote}

La fonction {\tt tmpnam} génère un nom de fichier unique. Ce nom est
renvoyé en retour. Si le paramètre {\tt adresse} n'est pas nul, il s'agit
d'un tableau d'au moins {\tt L\_tmpnam} octets, et le nom
est également placé dans ce tableau. Si le paramètre {\tt adresse} est
nul, le nom est mis dans une chaîne statique réutilisée par chaque
nouvel appel.

La fonction {\tt tempnam} est plus complète, mais n'est pas normalisée
par l'ANSI comme {\tt tmpnam}. Le paramètre {\tt repertoire} indique un
répertoire où doit être placé le fichier temporaire, et le paramètre
{\tt prefixe} est un préfixe d'au plus 5 caractères utilisés comme début
du nom unique. Le nom est placé dans un espace alloué avec {\tt malloc}
par {\tt tempnam}. Il faut donc libérer cet espace avec {\tt free} après
usage.

Si {\tt tempnam} ne peut allouer de la place, la valeur {\tt NULL} est
renvoyée.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Threads
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter {Threads POSIX}

La bibliothèque POSIX de «~threads~» permet de créer, supprimer et
synchroniser des threads de manière portable. Toutes ces fonctions
nécessitent l'inclusion du fichier suivant~:

\begin {quote}
\begin {verbatim}
#include <pthread.h>
\end{verbatim}
\end {quote}

Comme pour les autres objets POSIX, les threads utilisent des types
définis dans cet en-tête. L'édition de liens doit être réalisée avec
l'option \verb|-l pthread| pour inclure cette bibliothèque.

Sauf exception, la valeur de retour des fonctions est 0 si l'opération
s'est bien passée, ou un numéro d'erreur sinon (compatible avec les
définitions de la variable globale \texttt {errno.h}).

Ce chapitre décrit les fonctions les plus couramment utilisées.


\section {Création, terminaison et gestion des threads}

\separation 
\primitive {pthread\_create} --- crée un thread
    \index{{\tt pthread\_create}}

\begin {quote}
\begin {verbatim}
int pthread_create (pthread_t *thread, const pthread_attr_t *attr,
                    void *(*fonction)(void *), void *arg)
\end{verbatim}
\end {quote}

Cette fonction crée un nouveau thread pour exécuter la fonction
citée en argument. Cette fonction admet elle-même un seul paramètre
de type \verb|void *|, dont la valeur est passée lors de l'appel à
\verb|pthread_create|.

L'identification du nouveau thread est placée dans la variable pointée
par le paramètre \texttt {thread}. Si \texttt {attr} vaut \texttt {NULL},
les attributs du nouveau thread sont les attributs par défaut, sinon
\texttt {attr} doit pointer sur une variable contenant les attributs
initiaux du nouveau thread (qui ne sont plus modifiables \textit {a
posteriori}).

Le thread existe jusqu'à ce que l'une des conditions suivantes se
réalise~:

\begin {itemize}
    \item la fonction spécifiée en paramètre se termine
    \item le thread appelle la fonction \texttt {pthread\_exit}
    \item un autre thread appelle la fonction \texttt {pthread\_cancel}
\end {itemize}


\separation 
\primitive {pthread\_exit} --- termine le thread courant
    \index{{\tt pthread\_exit}}

\begin {quote}
\begin {verbatim}
void pthread_exit (void *valretour)
\end{verbatim}
\end {quote}

Cette fonction termine le thread courant et rend la valeur \texttt
{valretour} disponible pour le thread qui va utiliser \verb|pthread_join|.


\separation 
\primitive {pthread\_join} --- attend la terminaison d'un thread donné
    \index{{\tt pthread\_join}}

\begin {quote}
\begin {verbatim}
int pthread_join (pthread_t thread, void **valretour)
\end{verbatim}
\end {quote}

Cette fonction attend la terminaison du thread indiqué par l'argument
\texttt {thread}. Le thread désigné n'est pas forcément un fils du
thread courant. La valeur de retour indiquée lors de la terminaison (avec
\verb|pthread_exit|) est retournée via l'argument \texttt {valretour}.


\separation 
\primitive {pthread\_self} --- retourne l'identité du thread courant
    \index{{\tt pthread\_self}}

\begin {quote}
\begin {verbatim}
pthread_t pthread_self (void)
\end{verbatim}
\end {quote}

Cette fonction renvoie l'identité du thread courant, c'est-à-dire la
valeur pointée par \texttt {pthread} à l'issue de la création par
la fonction \verb|pthread_create|.


\separation 
\primitive {pthread\_equal} --- compare deux identités de threads
    \index{{\tt pthread\_equal}}

\begin {quote}
\begin {verbatim}
int pthread_equal (pthread_t t1, pthread_t t2)
\end{verbatim}
\end {quote}

Cette fonction renvoie une valeur différente de 0 si les deux identités
de threads sont identiques, ou 0 si elles sont différentes.


\separation 
\primitive {pthread\_detach} --- détache un thread
    \index{{\tt pthread\_detach}}

\begin {quote}
\begin {verbatim}
int pthread_detach (pthread_t thread)
\end{verbatim}
\end {quote}

Détache le thread spécifié~: ceci signifie que lorsque le thread se
terminera, ses ressources seront automatiquement libérées sans attendre
un appel à \verb|pthread_join|. Un thread détaché ne peut être la
cible d'un appel à \verb|pthread_join|.


\section {Attributs de création de threads}

Les attributs d'un thread peuvent être initialisés lors de sa création
avec \verb|pthread_create|. Les fonctions ci-après servent à spécifier
ces attributs.
Note~: seule une sélection des attributs est présentée ici.


\separation
\primitive {pthread\_attr\_init, pthread\_attr\_destroy} --- initialise ou détruit les attributs
    \index{{\tt pthread\_attr\_init}}
    \index{{\tt pthread\_attr\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_attr_init (pthread_attr_t *attr)
int pthread_attr_destroy (pthread_attr_t *attr)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_attr_init| initialise un objet de type
\verb|pthread_attr_t| avec les attributs par défaut. Dès lors, les
attributs peuvent être modifiés avec les autres fonctions de cette
section.

La fonction \verb|pthread_attr_destroy| sert à détruire l'objet de type
\verb|pthread_attr_t| lorsqu'il n'est plus utilisé (i.e.  lorsque le
ou les threads ont été créés avec \verb|pthread_create|).


\separation
\primitive {pthread\_attr\_getstacksize, pthread\_attr\_setstacksize} --- taille de la pile
    \index{{\tt pthread\_attr\_getstacksize}}
    \index{{\tt pthread\_attr\_setstacksize}}

\begin {quote}
\begin {verbatim}
int pthread_attr_getstacksize (const pthread_attr_t *attr, size_t *val)
int pthread_attr_setstacksize (pthread_attr_t *attr, size_t val)
\end{verbatim}
\end {quote}

Chaque thread dispose d'une pile d'exécution dotée d'une taille
finie. Ces fonctions récupèrent ou modifient la taille de la pile
du thread qui sera créé par \verb|pthread_create|.


\separation
\primitive {pthread\_attr\_getdetachstate,
pthread\_attr\_setdetachstate} --- attribut «~détaché~»
    \index{{\tt pthread\_attr\_getdetachstate}}
    \index{{\tt pthread\_attr\_setdetachstate}}

\begin {quote}
\begin {verbatim}
int pthread_attr_getdetachstate (const pthread_attr_t *attr, int *val)
int pthread_attr_setdetachstate (pthread_attr_t *attr, int val)
\end{verbatim}
\end {quote}

Ces fonctions récupèrent ou modifient l'attribut «~détaché~» qui
sera positionné lors de la création du nouveau thread. Le paramètre
\texttt {val} peut prendre les valeurs suivantes~:

\begin {itemize}
    \item \verb|PTHREAD_CREATE_DETACHED|~: le nouveau thread sera
	créé dans l'état «~détaché~», comme s'il y avait eu un appel
	à \verb|pthread_detach|~;
    \item \verb|PTHREAD_CREATE_JOINABLE|~: le nouveau thread sera
	créé dans l'état par défaut, qui autorise ce thread à être
	la cible d'un appel à \verb|pthread_join|.
\end {itemize}


\section {Gestion des signaux}

Si l'action associée à chaque signal (via \texttt {sigaction}) est
partagée par tous les threads d'un processus, le masque de signaux est
propre à chaque thread. Ceci permet, par exemple, de canaliser vers un
thread la prise en compte d'un signal donné.


\separation 
\primitive {pthread\_kill} --- envoie un signal à un thread donné
    \index{{\tt pthread\_kill}}

\begin {quote}
\begin {verbatim}
int pthread_kill (pthread_t thread, int signal)
\end{verbatim}
\end {quote}

Cette fonction envoie le signal \texttt {signal} au thread indiqué par le
paramètre \texttt {thread}.  Si \texttt {signal} vaut 0, aucun signal
n'est envoyé au thread, cette fonction sert alors à tester l'existence
du thread.


\separation
\primitive {pthread\_sigmask} --- manipulation du masque de signaux
    \index{{\tt pthread\_sigmask}}

\begin {quote}
\begin {verbatim}
#include <signal.h>

int pthread_sigmask (int comment, const sigset_t *nouveau, sigset_t *ancien)
\end{verbatim}
\end {quote}

L'utilisation de cette fonction est similaire à celle de la primitive
\texttt {sigprocmask} (voir page~\pageref {sigprocmask}), mais dans un
contexte multi-threadé.


\section {Verrous exclusifs (mutex)}

Les verrous exclusifs (ou verrous d'exclusion mutuelle, ou mutex),
constituent le mécanisme élémentaire de synchronisation de threads. Ils
reposent sur un objet de type \verb|pthread_mutex_t|, et peuvent avoir
des attributs représentés par le type \verb|pthread_mutexattr_t|.

\separation
\primitive {pthread\_mutex\_init, pthread\_mutex\_destroy} --- initialise ou détruit un mutex
    \index{{\tt pthread\_mutex\_init}}
    \index{{\tt pthread\_mutex\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
int pthread_mutex_destroy (pthread_mutex_t *mutex)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_mutex_init| initialise le verrou exclusif
(mutex) indiqué par le paramètre \texttt {mutex}, et le place dans
l'état «~non verrouillé~». Le paramètre \texttt {attr} indique les
attributs éventuels du mutex, ou vaut \texttt {NULL} si les attributs
par défaut doivent être utilisés.

La fonction \verb|pthread_mutex_destroy| détruit le mutex spécifié.


\separation
\primitive {pthread\_mutex\_lock, pthread\_mutex\_timedlock, pthread\_mutex\_trylock} --- verrouille un mutex
    \index{{\tt pthread\_mutex\_lock}}
    \index{{\tt pthread\_mutex\_timedlock}}
    \index{{\tt pthread\_mutex\_trylock}}

\begin {quote}
\begin {verbatim}
#include <time.h>

int pthread_mutex_lock (pthread_mutex_t *mutex)
int pthread_mutex_timedlock (pthread_mutex_t *mutex, const struct timespec *habs)
int pthread_mutex_trylock (pthread_mutex_t *mutex)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_mutex_lock| attend, si besoin est, que le
verrou indiqué par le paramètre devienne libre, et le verrouille.

La fonction \verb|pthread_mutex_timedlock| fonctionne de même, mais
attend au plus jusqu'à l'heure spécifiée par \texttt {habs}, qui
doit être une heure absolue (et non une durée relative à l'heure
courante). Voir la fonction \texttt {nanosleep} pour la définition
de la structure \texttt {timespec}.

La fonction \verb|pthread_mutex_trylock| tente de verrouiller le mutex
indiqué par le paramètre sans attendre. Si l'opération n'est pas
possible, cette fonction retourne une erreur.

Si \verb|pthread_mutex_timedlock| se termine à l'expiration du délai
sans obtenir le verrou, l'erreur retournée est \texttt {ETIMEDOUT}.
De même, si \verb|pthread_mutex_trylock| ne peut obtenir le verrou,
l'erreur retournée est \texttt {EBUSY}.


\separation
\primitive {pthread\_mutex\_unlock} --- déverrouille un mutex
    \index{{\tt pthread\_mutex\_unlock}}

\begin {quote}
\begin {verbatim}
int pthread_mutex_unlock (pthread_mutex_t *mutex)
\end{verbatim}
\end {quote}

Cette fonction déverrouille le mutex passé en paramètre.


\section {Attributs de création de mutex}

Tout comme les attributs d'un thread, les attributs d'un
mutex peuvent être spécifiés lors de son initialisation avec
\verb|pthread_mutex_init|. Les fonctions ci-après servent à spécifier
ces attributs.
Note~: seule une sélection des attributs est présentée ici.

\separation
\primitive {pthread\_mutexattr\_init, pthread\_mutexattr\_destroy} ---
initialise ou détruit des attributs de mutex
    \index{{\tt pthread\_mutexattr\_destroy}}
    \index{{\tt pthread\_mutexattr\_init}}

\begin {quote}
\begin {verbatim}
int pthread_mutexattr_init (pthread_mutexattr_t *attr)
int pthread_mutexattr_destroy (pthread_mutexattr_t *attr)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_mutexattr_init| initialise un objet de type
\verb|pthread_mutexattr_t| avec les attributs par défaut. Dès lors, les
attributs peuvent être modifiés avec les autres fonctions de cette
section.

La fonction \verb|pthread_mutexattr_destroy| sert à détruire l'objet de type
\verb|pthread_mutexattr_t| lorsqu'il n'est plus utilisé (i.e.  lorsque les
verrous ont été initialisés avec \verb|pthread_mutex_init|).


\separation
\primitive {pthread\_mutexattr\_gettype, pthread\_mutexattr\_settype} --- type de mutex
    \index{{\tt pthread\_mutexattr\_gettype}}
    \index{{\tt pthread\_mutexattr\_settype}}

\begin {quote}
\begin {verbatim}
int pthread_mutexattr_gettype (pthread_mutexattr_t *attr, int *val)
int pthread_mutexattr_settype (pthread_mutexattr_t *attr, int val)
\end{verbatim}
\end {quote}

Le type de mutex précise la manière dont la bibliothèque réagit
face à une tentative de verrouillage d'un mutex déjà verrouillé,
suivant la valeur \texttt {val}~:

\begin {itemize}
    \item \verb|PTHREAD_MUTEX_NORMAL|~: rien n'empêche un thread
	de tenter de verrouiller le mutex si ce même thread l'a déjà
	verrouillé, entraînant ainsi un interblocage du thread~;
    \item \verb|PTHREAD_MUTEX_ERRORCHECK|~: une erreur est détectée
	si le thread essaye de verrouiller à nouveau le mutex sans le
	déverrouiller au préalable, ou si le thread tente de
	déverrouiller le mutex alors qu'il avait été verrouillé par un
	autre thread~;
    \item \verb|PTHREAD_MUTEX_RECURSIVE|~: le mutex peut être verrouillé
	plusieurs fois par le même thread (sans provoquer d'attente),
	un nombre équivalent de déverrouillages est alors nécessaire
	pour réveiller les autres threads attendant ce mutex. Le
	déverrouillage par un autre thread que celui qui a verrouillé
	résulte en une erreur.
    \item \verb|PTHREAD_MUTEX_DEFAULT|~: selon les systèmes, ce type
	correspond à l'une des trois valeurs ci-dessus. Il est donc
	déconseillé de l'utiliser si on cherche un comportement
	spécifique.
\end {itemize}


\section {Verrous actifs (spin locks)}

Les verrous actifs (ou spin locks) sont similaires aux mutex dans le
principe du verrouillage exclusif. La différence est que l'attente,
dans le cas des verrous actifs, est réalisée de manière active sans
libérer le processeur. Étant donné que l'attente active pénalise
l'ensemble du système (les autres processus et threads), les verrous
actifs ne doivent être utilisés que pour des très courtes périodes
d'attente, lorsque le temps de mise en attente avec un mutex est
incompatible avec les exigences de l'application et que le nombre de
processeurs est suffisant.

\separation
\primitive {pthread\_spin\_init, pthread\_spin\_destroy} --- initialise ou détruit un verrou actif
    \index{{\tt pthread\_spin\_init}}
    \index{{\tt pthread\_spin\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_spin_init (pthread_spinlock_t *verrou, int partage)
int pthread_spin_destroy (pthread_spinlock_t *verrou)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_spin_init| initialise le verrou actif indiqué
par le paramètre \texttt {spin}, et le place dans l'état «~non
verrouillé~».  Le paramètre \texttt {partage} peut prendre les
valeurs suivantes~:

\begin {itemize}
    \item \verb|PTHREAD_PROCESS_SHARED|~: le verrou
	est partagé entre les threads de plusieurs processus (si la zone
	de mémoire correspondant au verrou se situe par exemple dans un
	segment de mémoire partagée)~;
    \item \verb|PTHREAD_PROCESS_PRIVATE|~: le verrou n'est accessible
	qu'au threads du processus courant.
\end {itemize}

La fonction \verb|pthread_spin_destroy| détruit le verrou spécifié.


\separation
\primitive {pthread\_spin\_lock, pthread\_spin\_trylock} --- verrouille un verrou actif
    \index{{\tt pthread\_spin\_lock}}
    \index{{\tt pthread\_spin\_trylock}}

\begin {quote}
\begin {verbatim}
#include <time.h>

int pthread_spin_lock (pthread_spinlock_t *spin)
int pthread_spin_trylock (pthread_spinlock_t *spin)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_spin_lock| attend de manière active, si
besoin est, que le verrou indiqué par le paramètre devienne libre,
et le verrouille.

La fonction \verb|pthread_spin_trylock| tente de verrouiller le verrou
indiqué par le paramètre sans attendre. Si l'opération n'est pas
possible, cette fonction retourne une erreur.



\separation
\primitive {pthread\_spin\_unlock} --- déverrouille un verrou actif
    \index{{\tt pthread\_spin\_unlock}}

\begin {quote}
\begin {verbatim}
int pthread_spin_unlock (pthread_spinlock_t *spin)
\end{verbatim}
\end {quote}

Cette fonction déverrouille le spin passé en paramètre.


\section {Conditions}

Les conditions (ou \textit {condition variables} en anglais) sont un
mécanisme de synchronisation qui, associées à un mutex, permettent à
un thread d'attendre qu'une condition soit vérifiée par un autre thread.


\separation
\primitive {pthread\_cond\_init, pthread\_cond\_destroy} --- initialise ou détruit une condition
    \index{{\tt pthread\_cond\_init}}
    \index{{\tt pthread\_cond\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr)
int pthread_cond_destroy (pthread_cond_t *cond)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_cond_init| initialise la condition indiquée
par le paramètre \texttt {cond}.  Le paramètre \texttt {attr} indique
les attributs éventuels de la condition, ou vaut \texttt {NULL} si les
attributs par défaut doivent être utilisés.

La fonction \verb|pthread_cond_destroy| détruit la condition spécifiée.


\separation
\primitive {pthread\_cond\_wait, pthread\_cond\_timedwait} --- attend une condition
    \index{{\tt pthread\_cond\_wait}}
    \index{{\tt pthread\_cond\_timedwait}}

\begin {quote}
\begin {verbatim}
int pthread_cond_wait (pthread_cond_t *, pthread_mutex_t *mutex)
int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,
                            const struct timespec *habs)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_cond_wait| réalise, en une opération atomique
(à l'échelle des threads), le déverrouillage du mutex et la mise en
attente du thread courant. De manière symétrique, lorsque le thread
sera remis sur le processeur, le mutex sera automatiquement verrouillé.
Ceci permet d'implémenter des tests élaborés comme~:

\begin {quote}
\small
\begin {verbatim}
pthread_cond_t cond ;                   /* initialisation non décrite ici */
pthread_mutex_t mtx ;                   /* initialisation non décrite ici */

pthread_mutex_lock (&mtx) ;             /* debut de section critique */
while (travail_a_faire == 0)
    pthread_cond_wait (&cond, &mtx) ;   /* attendre en liberant le verrou */
/* faire le travail */
travail_a_faire = 0 ;
pthread_mutex_unlock (&mtx) ;           /* fin de section critique */
\end{verbatim}
\end {quote}

La boucle \texttt {while} est nécessaire car il peut arriver que
\verb|pthread_cond_wait| se termine sans que la raison ayant provoqué
l'attente soit satisfaite (\textit {spurious wakeup}).

La fonction \verb|pthread_cond_timedwait| fonctionne de manière
similaire à \verb|pthread_cond_wait|, mais attend au plus jusqu'à
l'heure spécifiée par \texttt {habs}, qui doit être une heure absolue
(et non une durée relative à l'heure courante) comme avec
\verb|pthread_mutex_timedlock|.

Si \verb|pthread_cond_timedwait| se termine à l'expiration du délai
sans que la condition soit réalisée, l'erreur retournée est \texttt
{ETIMEDOUT}.


\separation
\primitive {pthread\_cond\_signal, pthread\_cond\_broadcast} --- débloque un ou plusieurs threads
    \index{{\tt pthread\_cond\_signal}}
    \index{{\tt pthread\_cond\_broadcast}}

\begin {quote}
\begin {verbatim}
int pthread_cond_signal (pthread_cond_t *cond)
int pthread_cond_broadcast (pthread_cond_t *cond)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_cond_signal| débloque (au moins) un des threads
attendant la condition passée en paramètre. L'ordre dans lequel les
threads sont débloqués n'est pas déterministe (et ne correspond sans
doute pas à l'ordre dans lequel les threads se sont mis en attente).
Par exemple~:

\begin {quote}
\small
\begin {verbatim}
pthread_cond_t cond ;                   /* initialisation non décrite ici */
pthread_mutex_t mtx ;                   /* initialisation non décrite ici */

/* specifier le travail à faire */
travail_a_faire = 1 ;
pthread_cond_signal (&cond) ;           /* réveiller le thread travailleur */
\end{verbatim}
\end {quote}

Note~: si l'appel à \verb|pthread_cond_signal| est effectué
antérieurement à l'appel à \verb|pthread_cond_wait| correspondant
(c'est-à-dire si aucun thread n'est réveillé), c'est qu'il y a
vraisemblablement un problème dans le programme.

La fonction \verb|pthread_cond_broadcast| débloque tous les threads
attendant la condition passée en paramètre.


\section {Attributs de conditions}

Comme pour les mutex, les conditions possèdent des attributs. En
revanche, aucun attribut courant n'est défini de manière portable
entre tous les systèmes.


\separation
\primitive {pthread\_condattr\_init, pthread\_condattr\_destroy} --- initialise ou détruit des attributs de condition
    \index{{\tt pthread\_condattr\_init}}
    \index{{\tt pthread\_condattr\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_condattr_init (pthread_condattr_t *attr)
int pthread_condattr_destroy (pthread_condattr_t *attr)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_condattr_init| initialise un objet de type
\verb|pthread_condattr_t| avec les attributs par défaut. Dès lors,
les attributs peuvent être modifiés avec les autres fonctions de
cette section.

La fonction \verb|pthread_condattr_destroy| sert à détruire
l'objet de type \verb|pthread_condattr_t| lorsqu'il n'est plus
utilisé (i.e.  lorsque les conditions ont été initialisées avec
\verb|pthread_cond_init|).


\section {Verrous lecteurs/écrivains}

Les verrous lecteurs/écrivains sont un mécanisme de synchronisation de
haut niveau pour répondre au problème classique de multiples lecteurs
et écrivains se partageant un espace commun.

\separation
\primitive {pthread\_rwlock\_init, pthread\_rwlock\_destroy} --- initialise ou détruit un verrou lecteurs/écrivains
    \index{{\tt pthread\_rwlock\_init}}
    \index{{\tt pthread\_rwlock\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_rwlock_init (pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr)
int pthread_rwlock_destroy (pthread_rwlock_t *lock)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_rwlock_init| initialise le verrou
lecteurs/écrivains par le paramètre \texttt {lock}.  Le paramètre
\texttt {attr} indique les attributs éventuels du verrou, ou vaut
\texttt {NULL} si les attributs par défaut doivent être utilisés.

La fonction \verb|pthread_rwlock_destroy| détruit le verrou spécifié.


\separation
\primitive {pthread\_rwlock\_rdlock, pthread\_rwlock\_tryrdlock} --- accès pour un lecteur
    \index{{\tt pthread\_rwlock\_rdlock}}
    \index{{\tt pthread\_rwlock\_tryrdlock}}

\begin {quote}
\begin {verbatim}
int pthread_rwlock_rdlock (pthread_rwlock_t *lock)
int pthread_rwlock_tryrdlock (pthread_rwlock_t *lock)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_rwlock_rdlock| permet l'accès à une zone
partagée entre de multiples lecteurs et écrivains. Plus précisément,
le thread est autorisé à accéder à la zone si aucun écrivain n'a
demandé l'accès à la zone (c'est-à-dire y accède actuellement ou
est bloqué en attendant que les lecteurs aient libéré la zone).

La fonction \verb|pthread_rwlock_tryrdlock| tente de réaliser cet accès
sans attendre. Si l'opération n'est pas possible, cette fonction retourne
une erreur \texttt {EBUSY}.


\separation
\primitive {pthread\_rwlock\_wrlock, pthread\_rwlock\_trywrlock} --- accès pour un écrivain
    \index{{\tt pthread\_rwlock\_wrlock}}
    \index{{\tt pthread\_rwlock\_trywrlock}}

\begin {quote}
\begin {verbatim}
int pthread_rwlock_wrlock (pthread_rwlock_t *lock)
int pthread_rwlock_trywrlock (pthread_rwlock_t *lock)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_rwlock_wrlock| permet l'accès à une zone
partagée entre de multiples lecteurs et écrivains. Plus précisément,
le thread est autorisé à accéder à la zone si aucun autre thread
(lecteur ou écrivain) n'a demandé l'accès à la zone.

La fonction \verb|pthread_rwlock_trywrlock| tente de réaliser cet
accès sans attendre.  Si l'opération n'est pas possible, cette fonction
retourne une erreur \texttt {EBUSY}.



\separation
\primitive {pthread\_rwlock\_unlock} --- libère l'accès à un verrou
lecteurs/écrivains
    \index{{\tt pthread\_rwlock\_unlock}}

\begin {quote}
\begin {verbatim}
int pthread_rwlock_unlock (pthread_rwlock_t *lock)
\end{verbatim}
\end {quote}

Cette fonction libère le verrou lecteurs/écrivains, c'est-à-dire
libère l'accès à la zone de mémoire partagée entre de multiples
lecteurs et écrivains.


\section {Attributs de verrous lecteurs/écrivains}

Les attributs d'un verrou lecteurs/écrivains peuvent
être spécifiés lors de son initialisation avec la fonction
\verb|pthread_rwlock_init|. Les fonctions ci-après servent à spécifier
ces attributs.

\separation
\primitive {pthread\_rwlockattr\_init, pthread\_rwlockattr\_destroy} ---
initialise ou détruit un attribut de verrou lecteurs/écrivains
    \index{{\tt pthread\_rwlockattr\_init}}
    \index{{\tt pthread\_rwlockattr\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
int pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_rwlockattr_init| initialise un objet de type
\verb|pthread_rwlockattr_t| avec les attributs par défaut. Dès lors,
les attributs peuvent être modifiés avec les autres fonctions de
cette section.

La fonction \verb|pthread_rwlockattr_destroy| sert à détruire
l'objet de type \verb|pthread_rwlockattr_t| lorsqu'il n'est plus
utilisé (i.e.  lorsque les verrous ont été initialisés avec
\verb|pthread_rwlock_init|).


\separation
\primitive {pthread\_rwlockattr\_getpshared, pthread\_rwlockattr\_setpshared} --- attribut de partage entre processus
    \index{{\tt pthread\_rwlockattr\_getpshared}}
    \index{{\tt pthread\_rwlockattr\_setpshared}}

\begin {quote}
\begin {verbatim}
int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *val)
int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int val)
\end{verbatim}
\end {quote}

Ces fonctions récupèrent ou modifient l'attribut «~partage entre
processus~» qui sera positionné lors de la création du nouveau
verrou. Le paramètre \texttt {val} peut prendre les valeurs suivantes~:

\begin {itemize}
    \item \verb|PTHREAD_PROCESS_SHARED|~: le verrou lecteurs/écrivains
	est partagé entre les threads de plusieurs processus (si la zone
	de mémoire correspondant au verrou se situe par exemple dans un
	segment de mémoire partagée)~;
    \item \verb|PTHREAD_PROCESS_PRIVATE|~: le verrou n'est accessible
	qu'au threads du processus courant.
\end {itemize}


\section {Barrières}

Les barrières sont un mécanisme qui permet à $n$ threads d'attendre
qu'ils soient tous arrivés à un point (la barrière) avant de le
franchir.

\separation
\primitive {pthread\_barrier\_init, pthread\_barrier\_destroy} --- initialise ou détruit une barrière
    \index{{\tt pthread\_barrier\_init}}
    \index{{\tt pthread\_barrier\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_barrier_init (pthread_barrier_t *barriere, const pthread_barrierattr_t *attr,
                          unsigned int nb)
int pthread_barrier_destroy (pthread_barrier_t *barriere)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_barrier_init| initialise la barrière
spécifiée par le paramètre \texttt {barriere}.  Le paramètre \texttt
{attr} indique les attributs éventuels de la barrière, ou vaut \texttt
{NULL} si les attributs par défaut doivent être utilisés. Enfin,
le paramètre \texttt {nb} indique le nombre de threads à synchroniser.

La fonction \verb|pthread_barrier_destroy| détruit la barrière spécifiée.


\separation
\primitive {pthread\_barrier\_wait} --- attendre le franchissement de la barrière
    \index{{\tt pthread\_barrier\_wait}}

\begin {quote}
\begin {verbatim}
int pthread_barrier_wait (pthread_barrier_t *barriere)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_barrier_wait| met le thread en attente. Lorsque
les $n$ (nombre indiqué lors de la création de la barrière) threads
ont tous appelé cette fonction, elle cesse l'attente, et les $n$
threads peuvent alors reprendre leur exécution. La barrière est alors
réinitialisée et peut servir à nouveau.

Lorsque tout se passe bien, la valeur de retour est
\verb|PTHREAD_BARRIER_SERIAL_THREAD| pour l'un des threads et 0 pour
les $n-1$ autres (ce qui permet à un des threads de jouer un rôle
particulier comme celui de coordinateur par exemple). Sinon, un code
d'erreur est renvoyé.


\section {Attributs de barrière}

Les attributs d'une barrière être spécifiés lors de son initialisation
avec la fonction \verb|pthread_barrier_init|. Les fonctions ci-après
servent à spécifier ces attributs.

\separation
\primitive {pthread\_barrierattr\_init, pthread\_barrierattr\_destroy} ---
initialise ou détruit un attribut de barrière
    \index{{\tt pthread\_barrierattr\_init}}
    \index{{\tt pthread\_barrierattr\_destroy}}

\begin {quote}
\begin {verbatim}
int pthread_barrierattr_init (pthread_barrierattr_t *attr)
int pthread_barrierattr_destroy (pthread_barrierattr_t *attr)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_barrierattr_init| initialise un objet de type
\verb|pthread_barrierattr_t| avec les attributs par défaut. Dès lors,
les attributs peuvent être modifiés avec les autres fonctions de
cette section.

La fonction \verb|pthread_barrierattr_destroy| sert à détruire
l'objet de type \verb|pthread_barrierattr_t| lorsqu'il n'est plus
utilisé (i.e.  lorsque les barrières ont été initialisées avec
\verb|pthread_barrier_init|).


\separation
\primitive {pthread\_barrierattr\_getpshared, pthread\_barrierattr\_setpshared} --- attribut de partage entre processus
    \index{{\tt pthread\_barrierattr\_getpshared}}
    \index{{\tt pthread\_barrierattr\_setpshared}}

\begin {quote}
\begin {verbatim}
int pthread_barrierattr_getpshared (const pthread_barrierattr_t *attr, int *val)
int pthread_barrierattr_setpshared (pthread_barrierattr_t *attr, int val)
\end{verbatim}
\end {quote}

Ces fonctions récupèrent ou modifient l'attribut «~partage entre
processus~» qui sera positionné lors de la création de la nouvelle
barrière. Le paramètre \texttt {val} peut prendre les valeurs suivantes~:

\begin {itemize}
    \item \verb|PTHREAD_PROCESS_SHARED|~: la barrière
	est partagé entre les threads de plusieurs processus (si la zone
	de mémoire correspondant à la barrière se situe par exemple dans un
	segment de mémoire partagée)~;
    \item \verb|PTHREAD_PROCESS_PRIVATE|~: la barrière n'est accessible
	qu'au threads du processus courant.
\end {itemize}


\section {Données spécifiques de threads}

La bibliothèque de threads POSIX fournit un mécanisme permettant de
stocker, à partir de noms communs (les clefs) à tous les threads,
des données (de type \verb|void *|~: par exemple une zone allouée
par \texttt {malloc} ou une valeur entière avec conversion de type
explicite) spécifiques à chaque thread. Ainsi, si un thread crée une
clef (appelons-la $c$), tous les threads verront cette clef $c$ avec
la valeur \texttt {NULL} à la création.  Si un thread stocke par la
suite une valeur pour cette clef $c$, seul ce thread verra cette valeur,
les autres continueront à voir \texttt {NULL}.


\separation
\primitive {pthread\_key\_create, pthread\_key\_delete} --- crée ou supprime une clef
    \index{{\tt pthread\_key\_create}}
    \index{{\tt pthread\_key\_delete}}

\begin {quote}
\begin {verbatim}
int pthread_key_create (pthread_key_t *clef, void (*destructeur) (void *))
int pthread_key_delete (pthread_key_t clef)
\end{verbatim}
\end {quote}

La fonction \verb|pthread_key_create| crée une clef, la stocke à
l'adresse pointée par \texttt {clef}, et lui associe la valeur \texttt
{NULL} pour l'ensemble des threads. La fonction \texttt {destructeur}
est appelée lorsque le thread se termine avec comme unique argument la
valeur associée à la clef. Cette fonction n'est pas appelée si le
paramètre \texttt {destructeur} vaut \texttt {NULL} ou si la donnée
associée à la clef vaut \texttt {NULL}.

La fonction \verb|pthread_key_delete| supprime la clef, qui n'est
alors plus visible dans aucun des threads. Comme la fonction \texttt
{destructeur} précisée à la création n'est pas appelée, l'application
doit s'assurer que toutes les zones de mémoire allouées dynamiquement
dans les divers threads pour cette clef doivent avoir été désallouées.


\separation
\primitive {pthread\_getspecific, pthread\_setspecific} --- donnée du thread associée à une clef
    \index{{\tt pthread\_getspecific}}
    \index{{\tt pthread\_setspecific}}

\begin {quote}
\begin {verbatim}
void *pthread_getspecific (pthread_key_t clef)
int pthread_setspecific (pthread_key_t clef, const void *val)
\end{verbatim}
\end {quote}

Ces fonctions récupèrent ou mémorisent la valeur associée au
paramètre \texttt {clef}.


\section {Sémaphores POSIX}

La bibliothèque des threads POSIX abrite également un jeu de fonctions
pour réaliser les opérations classiques sur des sémaphores\footnote
{ Cette bibliothèque peut gérer des sémaphores \textit {nommés},
mais seuls les sémaphores \textit {anonymes} sont décrits ici.}. Ces
fonctions ne sont pas spécifiques aux threads et peuvent servir dans
d'autres contextes comme par exemple pour synchroniser des processus
distincts partageant une même zone mémoire allouée par \texttt {shmget}
ou \texttt {mmap}.

Toutes ces fonctions utilisent le type \texttt {sem\_t} pour représenter
un sémaphore, et nécessitent l'inclusion du fichier suivant~:

\begin {quote}
\begin {verbatim}
#include <semaphore.h>
\end{verbatim}
\end {quote}

Comme pour les threads POSIX, l'utilisation des sémaphores nécessite
que l'édition de liens soit réalisée avec l'option \verb|-l pthread|
pour inclure la bibliothèque.


\separation
\primitive {sem\_init} --- initialise un sémaphore
    \index{{\tt sem\_init}}

\begin {quote}
\begin {verbatim}
int sem_init (sem_t *sem, int partage, unsigned int val)
\end{verbatim}
\end {quote}

Cette fonction initialise un sémaphore (qui doit déjà être alloué
avec le type \texttt {sem\_t}) avec la valeur \texttt {val}. Si le
paramètre \texttt {partage} est nul, le sémaphore est partagé entre les
différents threads du processus courant. Dans le cas contraire (\texttt
{partage} $\neq$ 0), le sémaphore est partagé entre tous les processus
pouvant accéder à la zone mémoire contenant le sémaphore.

Cette fonction renvoie 0 si l'initialisation est réussie
ou -1 en cas d'erreur.


\separation
\primitive {sem\_destroy} --- détruit un sémaphore
    \index{{\tt sem\_destroy}}

\begin {quote}
\begin {verbatim}
int sem_destroy (sem_t *sem)
\end{verbatim}
\end {quote}

Cette fonction détruit le sémaphore indiqué (mais ne libère pas
la zone mémoire correspondante). Elle retourne 0 en cas de réussite,
et -1 en cas d'erreur.


\separation
\primitive {sem\_wait, sem\_trywait, sem\_timedwait} --- verrouille un sémaphore
    \index{{\tt sem\_wait}}
    \index{{\tt sem\_trywait}}
    \index{{\tt sem\_timedwait}}

\begin {quote}
\begin {verbatim}
int sem_wait (sem_t *sem)
int sem_trywait (sem_t *sem)
int sem_timedwait (sem_t *sem, const struct timespec *habs)
\end{verbatim}
\end {quote}

La fonction \verb|sem_wait| réalise l'opération «~P~» (attente
éventuelle si le compteur du sémaphore n'est pas strictement positif
puis décrémentation du compteur).

La fonction \verb|sem_trywait| fonctionne de manière similaire,
mais échoue si le compteur n'est pas strictement positif.

La fonction \verb|sem_timedwait| fonctionne de manière similaire à
\verb|sem_wait|, mais attend au plus jusqu'à l'heure spécifiée par
\texttt {habs}, qui doit être une heure absolue (et non une durée
relative à l'heure courante) comme avec la fonction
\verb|pthread_mutex_timedlock|.

Ces fonctions renvoient 0 si tout s'est bien passé, ou -1 en cas d'erreur
ou de sémaphore non verrouillé.


\separation
\primitive {sem\_post} --- déverrouille un sémaphore
    \index{{\tt sem\_post}}

\begin {quote}
\begin {verbatim}
int sem_post (sem_t *sem)
\end{verbatim}
\end {quote}

La fonction \verb|sem_post| réalise l'opération «~V~» (incrémentation
du compteur et libération des processus ou threads éventuellement
en attente du sémaphore). Elle renvoie 0 en cas de réussite ou -1 en
cas d'erreur.


\separation
\primitive {sem\_getvalue} --- récupère le compteur d'un sémaphore
    \index{{\tt sem\_getvalue}}

\begin {quote}
\begin {verbatim}
int sem_getvalue (sem_t *sem, int *cptval)
\end{verbatim}
\end {quote}

Cette fonction récupère la valeur du compteur du sémaphore et la
place à l'adresse indiquée par \texttt {cptval}. Il faut noter que
POSIX ne spécifie pas, en cas de de processus ou de thread en attente
sur un sémaphore, si la valeur doit être négative ou si elle doit
être nulle : le choix appartient aux implémentations et peut donc
varier d'un système à l'autre. La valeur de retour est soit 0 en cas
de réussite ou -1 en cas d'erreur.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% DEBOGUEURS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \cleardoublepage
% 
% \chapter {Les débogueurs}
% 
% \input {debug.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%% INDEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\cleardoublepage
\phantomsection			% pour hyperref
\addcontentsline {toc} {chapter} {\indexname}
\printindex


\end {document}
