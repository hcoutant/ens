%
% Brochure d'exercices de TD/TP
%
% Licence Informatique
% Première année ISTY
%
% Textes de T.D.
% Pierre David (pda@prism.uvsq.fr)
%
% Historique
%   1993/01/24 : pda : création
%   1994/05/30 : pda : corrections pour 94/95
%   1994/08/04 : pda : retrait du tri des flottants dans le TD 1
%   1995/02/00 : pda : adaptations pour 94/95
%   1995/10/04 : pda : ... pour 95/96 (cours annuel)
%   1996/09/10 : pda : ... pour 96/97 (thèmes et distribution aux étudiants)
%   1997/08/26 : pda : ... pour 97/98 (ajout d'exercices)
%   1997/09/01 : pda : conversion a LaTeX2e
%   2002/05/16 : pda : retrait des anales - pour les remettre, chercher EXAMENS
%   2007/03/05 : pda : ajout durée d'exécution comparée FL/PS
%   2013/08/27 : pda : ajout pour svnpeda
%

\documentclass [twoside] {report}

    \usepackage {verbatim}	% pour la macro "listing"

    \usepackage [francais] {babel}
    \usepackage [utf8] {inputenc}
    \usepackage [T1] {fontenc}
    \usepackage {graphicx}
    \usepackage {times}
    \renewcommand {\ttdefault}{cmtt}
    \usepackage [a4paper, margin=20mm] {geometry}
    \raggedbottom	% par défaut, babel aligne les bas de page. Pas bôôôôô !

    \setlength {\parskip} {3mm}
    \setlength {\parindent} {0mm}

    \renewcommand {\arraystretch} {1.1}

    \newcommand {\tassertoc} {{ \setlength {\parskip} {0cm} \tableofcontents }}

    \pagestyle {myheadings}

    \newcommand {\marquerchapitre} [1]
    {
        \addcontentsline {toc} {chapter} {#1}
        \markboth {#1} {#1}
    }
    \newcommand {\chapitresanstitre} [1]
    {
        \cleardoublepage
	\marquerchapitre {#1}
    }
    \newcommand {\titrechapitre} [1]
    {
	\begin {center}
	    \Large \bf #1
	\end {center}
	\bigskip
	\bigskip
    }
    \newcommand {\chapitre} [1]
    {
        \chapitresanstitre {#1}
        \titrechapitre {#1}
    }


    \newcounter {td}
    \newcounter {question} [td]
    \renewcommand {\thequestion} {\arabic{td}.\arabic {question}}

    \newcommand {\td} [1]
    {
        \cleardoublepage
        \refstepcounter {td}
	\marquerchapitre {Thème \thetd\ - #1}
	\titrechapitre {Thème \thetd\ - #1}
    }
    \newcommand {\but}
    {
        \bigskip
        {\Large\bf But}
        \bigskip
    }
    \newcommand {\question}
    {
        \refstepcounter {question}
        \bigskip
        {\Large\bf Exercice \thequestion} % {\Large\bf Question \thequestion}
        \nopagebreak
        \bigskip

        \nopagebreak
    }

    \newcommand {\examen} [2]
    {
	\chapitresanstitre {Examen : #2}
	\input {#1}
    }

    \newcounter {tp}
    \newcounter {exercice} [tp]
    \renewcommand {\theexercice} {\arabic{tp}.\arabic {exercice}}

    \newcommand {\fig} [1]
    {
        % \vspace {3mm}
        \begin {center}
	    \includegraphics {#1}
        \end {center}
        % \vspace {2mm}
    }

    \newcommand {\listing} [1]
    {
	{\small\verbatiminput {#1}}
    }

\begin {document}

\thispagestyle {empty}

\begin {titlepage}
    \input {ue}

    \vfill

    \begin {center}
	\huge\bf
	Recueil d'exercices \\
	\vspace* {5mm}
	\input {annee}
    \end {center}

    \vfill

    \begin {flushright}
	Pierre David
    \end {flushright}
\end {titlepage}

\cleardoublepage
\tassertoc


% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % INTRODUCTION
% %
% % Historique
% %   1996/09/10 : pda : séparation en thèmes
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% \chapitre {Introduction}
% 
% Ce recueil d'exercices est destiné à accompagner l'enseignement de
% systèmes d'exploi\-ta\-tion, et plus particulièrement les travaux dirigés.
% 
% Il contient nettement plus d'exercices que vous ne pourrez en faire pendant les
% séances.  Votre enseignant vous indiquera les exercices au programme de
% chaque séance.  Les autres sont laissés à la sagacité des
% lecteurs curieux.
% 
% Les exercices sont regroupés par thèmes.  Ceux-ci sont assez généraux et
% regroupent souvent plusieurs séances de cours et de travaux dirigés.
% Les thèmes se divisent eux-mêmes en deux parties, reflétant les deux
% parties du cours~:  langage~C et système Unix.
% 
% % EXAMENS
% % Pour faciliter vos révisions, une partie des sujets d'examens des années
% % antérieures sont fournis en annexe.
% 
% 
% Bon travail et bonne année~!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGAGE C : ELEMENTS DE BASE
%
% Historique
%   1993/01/24 : pda : création
%   1995/10/04 : pda : adaptation pour 95/96
%   1997/08/26 : pda : ajout de l'exercice lire_16
%   1997/08/26 : pda : ajout de l'exercice ecrire_2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Langage~C~: Éléments de base}

% \but
% 
% Les exercices de ce thème ont pour but l'assimilation des éléments de
% base du langage~C~:  déclarations des variables, structures de contrôle,
% structures, chaînes de caractères, et utilisation d'un jeu minimum de
% fonctions d'entrées/sorties.


\question
%%%% Dependances: for, printf

Écrivez un programme qui affiche à l'écran les valeurs de $2^i$ ($0
\leq i < 10$) en utilisant la fonction {\tt printf}.


\question
%%%% Dependances: getchar, while, EOF, constantes char

Écrivez un programme qui lit des caractères (avec la fonction {\tt
getchar}) sur l'entrée standard et compte le nombre d'occurrences de
chaque lettre (on ne distinguera pas les minuscules des majuscules).

\question
%%%% Dependances: getchar, while, EOF

Écrivez un programme qui lit des phrases (c'est-à-dire des suites de
caractères quelconques) sur l'entrée standard et compte le nombre de
mots (c'est-à-dire les suites de caractères composées exclusivement de
lettres minuscules ou majuscules) qui s'y trouvent.


\question
%%%% Dependances: getchar, while, EOF, \n

Modifiez le programme de l'exercice précédent pour afficher seulement
les mots (et pas les chiffres, les signes de ponctuation, etc.), un par
ligne.


\question
%%%% Dependances: getchar, putchar, tableaux, (chaines), modulo

Avec les fonctions {\tt getchar} et {\tt putchar}, écrivez un programme
qui affiche les 10 dernières lignes lues sur l'entrée standard.


\question
%%%% Dependances: chaînes, fgets, puts, printf, strncpy, strlen

Écrivez un programme qui lit une chaîne de caractères sur l'entrée
standard (avec {\tt fgets}), la recopie (avec {\tt strncpy}) dans une
autre chaîne, puis affiche la nouvelle chaîne (avec {\tt puts}) et
sa longueur (avec {\tt strlen} et {\tt printf}).


\question
%%%% Dependances: fgets, puts, chaînes
    \label {strbrk}

Écrivez un programme qui lit deux chaînes, puis cherche si la deuxième
chaîne fait partie de la première, et affiche un message en conséquence.
Vous n'utiliserez pas de fonction de librairie autre que {\tt fgets} et
{\tt puts}.


\question
%%%% Dependances: chaînes, structures, printf

On désire avoir un programme qui lit sur l'entrée standard un nom de mois
(entre \verb:"janvier":  et \verb:"decembre":), et qui affiche son
numéro (entre 1 et 12) ainsi que le nombre de jours dans ce
mois\footnote {On ne tient pas compte du cas du mois de février lors
des années bissextiles.}. Si le mois n'est pas valide,
il doit afficher un message d'erreur.

Pour cela, on propose de placer les mois valides ainsi que le nombre de
jours correspondant, dans une structure~:

\begin {quote}
\small
\begin {verbatim}
struct mois
{
    char nom [9 + 1] ;     /* nom du mois en clair */
    int  jours ;           /* nombre de jours dans le mois */
} ;
\end{verbatim}
\end {quote}

Déclarez un tableau constant (initialisé) de 12 structures de cette
forme pour mémoriser les 12 mois possibles et écrivez le programme.


\question
%%%% Dependances: chaînes, switch
    \label {backslash}

Les chaînes de caractères et les constantes de type caractère en
langage~C peuvent contenir les éléments suivants~:

\begin {itemize}
    \item caractères ``normaux'', c'est à dire tous les caractères de
	code compris entre 32 et 126~;
    \item caractères de contrôle ``classiques''
	(\verb:\n:, \verb:\r:, \verb:\t:, et \verb:\b:)~;
    \item caractères non représentables tels quels
	(\verb:\\:, \verb:\': et \verb:\":)~;
    \item autres caractères, dont la valeur numérique est comprise entre
	0 et 31 ou supérieure à 127. Dans ce cas, la représentation est
	un antislash (\verb:\:) suivi du code octal du caractère.
\end {itemize}

Écrivez un programme qui lit une chaîne de caractères contenant
éventuellement des caractères spéciaux, puis place dans une deuxième
chaîne la représentation~C (c'est à dire avec le caractère \verb:\t:
remplacé par les deux caractères \verb:\: et \verb:t: par exemple).


\question
%%%% Dependances: chaînes, switch, base, ASCII

Écrivez le programme inverse de l'exercice~\ref {backslash}, pour
transformer une chaîne de caractère contenant éventuellement des
caractères spéciaux en représentation~C, en chaîne de caractères
contenant les caractères traduits (c'est à dire avec les deux caractères
\verb:\:  et \verb:t:  remplacés par le caractère \verb:\t:  par
exemple).


\question
%%%% Dependances: cpp

Le programmeur qui a écrit la définition ci-dessous aura certainement
quelques problèmes lorsqu'il l'utilisera.
Expliquez ces problèmes et
aidez ce pauvre programmeur à améliorer sa définition.

\begin {quote}
\begin {verbatim}
#define carre(x) x*x
\end{verbatim}
\end {quote}


\question
%%%% Dependances: cpp, fonctions, passage par valeur

Expliquez les différences entre votre version corrigée de l'exercice
précédent et la définition ci-dessous~:

\begin {quote}
\begin {verbatim}
int carre (int x) { return x * x ; }
\end{verbatim}
\end {quote}



\question
%%%% Dependances: passage par valeur, operateur --

Pourquoi la fonction ci-après peut donner des résultats faux~?

\begin {quote}
\small
\begin {verbatim}
int factorielle (int n)
{
    int f ;
    if (n <= 1) f = 1 ; else f = n * factorielle (--n) ;
    return f ;
}
\end{verbatim}
\end {quote}


\question
%%%% Dependances: passage par valeur, ASCII, base, opérateurs binaires
    \label {lire16}

Écrivez la fonction :
\begin {quote}
    \verb:unsigned int lire_16 (void):
\end {quote}
qui lit avec
{\tt fgets} une chaîne contenant des chiffres hexadécimaux, et renvoie la
valeur convertie.
Vous n'utiliserez pas les opérateurs \verb:*:, \verb:/:  et \verb:%:.


\question
%%%% Dependances: passage par valeur, ASCII, base, opérateurs binaires

Écrivez la fonction :
\begin {quote}
    \verb:void ecrire_2 (unsigned int):
\end {quote}
qui prend un
nombre en paramètre, et en affiche la représentation binaire sur la
sortie standard.
Comme pour l'exercice~\ref {lire16}, vous n'utiliserez pas les opérateurs
\verb:*:, \verb:/:  et \verb:%:.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGAGE C : FONCTIONS D'ENTREES/SORTIES
%
% Historique
%   1995/02/16 : pda : création
%   1997/08/26 : pda : ajout de l'exercice archiver/desarchiver
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\td {Langage~C~: Fonctions d'entrées/sorties}


% \but
% 
% Cette séance est destinée à introduire les fonctions d'entrées/sorties
% de la bibliothèque standard.


\question

Écrivez un programme qui recopie un fichier {\tt toto} vers un fichier
{\tt titi} à créer, à l'aide des fonctions {\tt fopen}, {\tt putc}, {\tt
getc} et {\tt fclose}.


\question

On désire construire un programme pour réaliser un carnet d'adresses
rudimentaire.  Le carnet est placé dans un fichier, composé de
fiches représentées par des structures du langage~C~:

\begin {quote}
\small
\begin {verbatim}
#define MAXNOM 50
#define MAXTEL 10

struct fiche
{
    int  occupe ;               /* vrai la fiche est utilisee */
    char nom [MAXNOM] ;         /* le nom de la personne */
    char telephone [MAXTEL] ;   /* son numero de telephone */
} ;

typedef struct fiche fiche ;
\end{verbatim}
\end {quote}

Lorsqu'une fiche est détruite, le champ {\tt occupe} est initialisé à la
valeur 0 ({\em faux}). Cette fiche pourra être réutilisée par la suite.

L'accès au carnet est réalisé par une suite de petits programmes
accomplissant chacun une action bien précise~:

\begin {itemize}
    \item {\tt chercher} \\
	Ce programme prend un argument, le nom à chercher. Si le nom est
	trouvé, le numéro de la fiche est affiché sur la sortie
	standard. Dans le cas contraire, rien n'est affiché.
    \item {\tt afficher} \\
	Ce programme prend un argument, le numéro de la fiche à
	afficher. Si ce numéro n'existe pas (argument vide), aucune
	fiche n'est affichée.
    \item {\tt ajouter} \\
	Ce programme prend deux arguments, un nom et un numéro de
	téléphone. La fiche est ajoutée dans le fichier, soit en
	récupérant une fiche inoccupée, soit en l'ajoutant à la fin du
	fichier.
    \item {\tt detruire} \\
	Ce programme prend un argument, le numéro de la fiche à
	détruire.
\end {itemize}


\question

La commande Unix {\tt tail} affiche, par défaut, les 10 dernières lignes
d'un fichier texte. L'option {\tt -n} permet de changer ce nombre de
lignes. Programmez votre propre version de cette commande {\tt tail}

Pour analyser les arguments, il faut utiliser la fonction {\tt getopt}.
Pour repérer les $n$ dernières lignes d'un fichier, une méthode suggérée
consiste à lire les $m$ derniers octets du fichier et à compter le
nombre de caractères \verb|\n| en partant de la fin.  Si ce nombre n'est
pas suffisant, on recommence.  Lorsque le nombre $n$ de \verb|\n| est
atteint, on affiche tous les caractères jusqu'à la fin du fichier.


\question

Le programme {\tt tar} est un utilitaire d'archivage :  il recopie toute
une arborescence et stocke tous les fichiers bout à bout dans un seul
fichier (l'{\em archive}).  Ceci peut être utile pour réaliser des
sauvegardes (la cartouche ou la bande est alors vue par le système comme
le fichier archive), pour transmettre des fichiers multiples par le
réseau, par courrier électronique ou bien avec {\tt ftp}.

On désire programmer deux utilitaires d'archivage comparables à {\tt tar}.

\begin {enumerate}

    \item la syntaxe de l'archiveur est :

	\begin {quote}
	    \verb|archiver archive f1 f2 ... fn|
	\end {quote}

	Le fichier {\tt archive} est le fichier dans lequel les fichiers
	{\tt f1} à {\tt fn} sont recopiés et mis bout à bout.  Chaque
	fichier y est précédé de son nom et de sa taille en octets.

	Note : quelles précautions doit-on prendre pour qu'un fichier
	archivé sur une machine puisse être désarchivé sur une autre~?

    \item la syntaxe du désarchiveur est :

	\begin {quote}
	    \verb|desarchiver archive|
	\end {quote}

	Cette commande analyse le fichier {\tt archive} et en extrait
	tous les fichiers.

\end {enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGAGE C : POINTEURS ET CALCULS D'ADRESSE
%
% Historique
%   1995/10/05 : pda : création
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\td {Langage~C~: Pointeurs}


% \but
% 
% Cette séance est une introduction au maniement des pointeurs,
% et notamment l'arithmétique sur les pointeurs.


\question

À l'aide d'un papier et d'un crayon, reconstituez le déroulement
du programme suivant. Déduisez-en l'affichage sur la sortie stantard,
ainsi que les endroits auxquels le programme provoque une erreur.

\begin {quote}
\small
\begin {verbatim}
#define PRabp(n)    printf ("Ligne %d: " \
        "a: 0x%x %d, b: 0x%x %d, p: 0x%x 0x%x %d\n", \
        n, &a, a, &b,b,&p, p, *p)
#define PRtp(n)     printf( "Ligne %d: " \
        "t: 0x%x %d %d %d, p: 0x%x 0x%x %d\n", \
        n, t, t[0], t[1], t[2],&p, p, *p)

int main (int argc, char *argv [])
{
    int a, b ;
    int t [3] = { 4, 5, 6 } ;
    int *p ;

    p=&b ; a=0 ; b=2 ;       PRabp (1) ;
    *p=4 ;                   PRabp (2) ;
    p++ ;                    PRabp (3) ;
    (*p)++ ;                 PRabp (4) ;
    p=0 ;                    PRabp (5) ;
    p=t ;                    PRtp (6) ;
    p[0] = 10 ; p[1] = 11 ;  PRtp (7) ;
    p++ ;                    PRtp (8) ;
    *p = 15 ; *(p+1) = 16 ;  PRtp (9) ;
    p++ ;                    PRtp (10) ;
    p[0] = 20 ; p[1] = 21 ;  PRtp (11) ;
    return 0 ;
}
\end{verbatim}
\end {quote}


\question
%%%% Dependances: fgets, atoi, pointeurs, malloc

Écrivez un programme qui lit une liste de nombres entiers (avec les
fonctions {\tt fgets} et {\tt atoi}) jusqu'à la fin de fichier, les
enregistre dans une liste en les triant au fur et à mesure, puis affiche
les nombres de la liste (avec la fonction {\tt printf}).


\question

Modifiez le programme de l'exercice précédent pour mettre dans la
liste (qui doit toujours être triée) des chaînes de caractères lues au
clavier.


\question
%%%% Dependances: structures, pointeurs, arithmetique sur les pointeurs

Lorsqu'une structure est déclarée, chaque champ est placé à une adresse
relative au début de la structure.  Soit une structure {\tt s} et une
champ {\tt c}, expliquez comment obtenir la valeur numérique de cette
adresse relative.


\question
%%%% Dependances: fgets, puts, chaînes, strlen, strncmp, pointeurs
%%%% Dependances: arithmetique sur les pointeurs

Écrivez un programme qui lit deux chaînes, puis cherche si la deuxième
chaîne fait partie de la première, et affiche un message en conséquence
(voir exercice~\ref {strbrk}).  Cette fois-ci, vous utiliserez les
fonctions de librairie {\tt strlen} et {\tt strncmp}.


\question
%%%% Dependances: fonction, pointeurs, passage par adresse

Écrivez la fonction \verb:char *mon_strchr (char *chaine, int car):
sans utiliser de fonction de librairie (et surtout pas {\tt strchr}).


\question
%%%% Dependances: fonction, pointeurs, passage par adresse, sizeof,
%%%% Dependances: pile d'execution

Pourquoi les fonctions ci-après ne peuvent pas fonctionner~?
%Pour chacune des fonctions suivantes, il vous est demandé~:
%
%\begin {enumerate}
%    \addtolength {\itemsep} {-2mm}
%    \item de déterminer si la fonction est valide ou non~;
%    \item si elle est valide, d'expliquer son fonctionnement~;
%    \item si elle n'est pas valide, de préciser la ou les raisons~;
%\end {enumerate}

\begin {quote}
    \small

% l'adresse retournee est dans la pile
\begin {verbatim}
int *f1 (int val)
{
    int *p ;
    p = val == 0 ? NULL : &val ;
    return p ;
}
\end{verbatim}

% l'adresse retournee est dans la pile
\begin {verbatim}
char *f2 (void)
{
    char tab [3 + 1] ;
    strcpy (tab, "abc") ;
    return tab ;
}
\end{verbatim}

% l'argument de printf necessite un "*p"
\begin {verbatim}
static char *texte [] = { "une", "suite", "de", "lignes", NULL, } ;

void f3 (void)
{
    char **p ;
    for (p = texte ; *p ; p++)
        printf ("%s\n", p) ;
}
\end{verbatim}

% tab ne peut être incrémenté : c'est un tableau
\begin {verbatim}
char tab [] = "abcdef\n" ;

void f4 (void)
{
    int i ;
    for (i = 0 ; *(tab + i) ; i++)
        putchar (*(tab + i)) ;
    for ( ; *tab ; tab++)
        putchar (*tab) ;
}
\end{verbatim}


% deux problèmes :
%   - sizeof (chaine) = la taille du pointeur
%   - la chaine est stockée en mémoire, et chaine est un pointeur :
%	au deuxième appel, la chaîne sera la chaîne modifiée lors
%	du premier appel.
\begin {verbatim}
void f5 (char tab [], int pas)
{
    char *chaine = "abcdef" ;
    int i ;
    for (i = 0 ; i < sizeof (chaine) ; i += pas)
        chaine [i] = '-' ;
    strcpy (tab, chaine) ;
}
\end{verbatim}
\end {quote}


\question
%%%% Dependances: printf, scanf, float, tableaux, passage de parametre par adr
    \label {sortfloat}

On désire écrire un programme pour lire une série de nombres flottants et
les placer dans un tableau (on supposera qu'il n'y a pas plus de 100
valeurs), trier ce tableau et enfin l'afficher sur la sortie standard.
Pour cela, on propose la décomposition en fonctions~:

\begin {enumerate}
    \item \verb|int lire_tableau (double *tableau, int max_elem, int *nb_elem)| \\
	qui reçoit un tableau en paramètre contenant au plus {\tt
	max\_elem} éléments, lit les valeurs et les range dans le
	tableau, puis renvoie le nombre d'élements lus dans {\tt
	nb\_elem}.  La valeur de retour de cette fonction doit être 0 si
	la lecture s'est bien passée, -1 sinon.


    \item \verb|void trier_tableau (double *tableau, int nb_elem)| \\
	qui trie les {\tt nb\_elem} éléments du tableau {\tt tableau}.

    \item \verb|void afficher_tableau (double *tableau, int nb_elem)| \\
	qui affiche les {\tt nb\_elem} éléments du tableau {\tt tableau}.

\end {enumerate}

Programmez ces fonctions ainsi que {\tt main}.


\question
%%%% Dependances: tableaux d'entiers, malloc

Écrivez un programme qui lit une série d'entiers sur l'entrée
standard, les range dans un tableau (on supposera qu'on ne lit pas plus
de 100 nombres), puis trie ce tableau et enfin l'affiche sur la sortie
standard. Vous n'avez pas le droit d'utiliser l'opérateur {\tt[}...{\tt]}.



\question
%%%% Dependances: pointeurs, typedef, fonctions

Écrivez la déclaration d'un tableau de 50 pointeurs sur des structures
contenant chacune un pointeur sur un caractère, un tableau de 10
entiers et un pointeur sur cette même structure. Donnez une définition
de ce type avec {\tt typedef}.


\question
%%%% Dependances: fonctions, char *, malloc

La fonction {\tt fgets} a un défaut~: l'espace dans lequel les caractères
lus sont rangés doit être alloué par la fonction appelante. Écrivez
une nouvelle fonction~:

\begin {quote}
    \verb|char *mon_fgets (void)|
\end {quote}

qui lit des caractères sur l'entrée standard
(on supposera qu'on ne lit pas plus de 100
caractères) et renvoie l'adresse d'une zone mémoire où votre
fonction les aura rangés.


\question
%%%% Dependances: fonctions, passage par adresse, pointeurs

On désire remplacer la fonction de lecture de tableau de
l'exercice~\ref {sortfloat} en éliminant la contrainte d'un nombre
d'entrées maximum. Pour cela, on change le prototype en~:

\begin {quote}
    \verb|int lire_tableau (double **tableau, int *nb_elem)|
\end {quote}

Le paramètre {\tt tableau} reçoit en sortie un tableau avec le nombre
suffisant d'entrées pour mémoriser tous les éléments lus.  Vous
commencerez par allouer (avec {\tt calloc}) un tableau de $n = 100$
entrées.  Lorsque $n$ éléments sont saisis, allouez un nouveau tableau
de taille $2n$ (sans utiliser {\tt realloc}), recopiez-y les $n$
éléments et désallouez le premier tableau.


\question
%%%% Dependances: fonctions

Comment peut-on déduire que le programmeur qui a écrit la fonction
ci-dessous est débutant~?

\begin {quote}
\small
\begin {verbatim}
int main (void)
{
    char *ligne ;

    ligne = malloc (80) ;
    while (gets (ligne) != NULL)
        puts (ligne) ;
}
\end{verbatim}
\end {quote}



\question
    \label {arbre}

On désire manipuler des expressions (composées des quatre opérations
classiques manipulant exclusivement des entiers) représentées sous forme
d'arbres.  Pour cela, on définit une structure~:

\begin {quote}
\small
\begin {verbatim}
enum code { noeud, feuille } ;

struct noeud
{
    enum code code ;
    union
    {
        int valeur ;
        struct
        {
            char operation ;
            struct noeud *fils_gauche ;
            struct noeud *fils_droit ;
        } s ;
    } u ;
} ;
\end{verbatim}
\end {quote}

Un n{\oe}ud de l'arbre est identifié par le code {\tt noeud} et contient
l'opération et ses deux opérandes.  Une feuille est identifiée par le
code {\tt feuille} et contient la valeur entière.


\begin {enumerate}
    \item Étant donnée l'expression spécifiée en notation préfixée~:

	\begin {quote}
	    \tt (* (* 3 (+ 1 2)) (+ 4 5))
	\end {quote}

	\begin {itemize}
	    \item dessinez l'arbre correspondant~;
	    \item donnez l'expression équivalente en notation algébrique.
	\end {itemize}
    
    \item Écrivez une fonction~:

\begin {quote}
\begin {verbatim}
struct noeud *lire_prefixe (void)
\end{verbatim}
\end {quote}

	qui lit sur l'entrée standard une expression en notation préfixée
	et la mémorise sous forme d'un arbre dont la racine est la
	valeur de retour.

    \item Écrivez une fonction~:

\begin {quote}
\begin {verbatim}
void ecrire_prefixe (struct noeud *arbre)
\end{verbatim}
\end {quote}

	qui affiche sur la sortie standard l'arbre en notation préfixée.
    
    \item Écrivez une fonction~:

\begin {quote}
\begin {verbatim}
int profondeur_arbre (struct noeud *arbre)
\end{verbatim}
\end {quote}

	qui renvoie la profondeur maximum de l'arbre.

    \item Écrivez une fonction~:

\begin {quote}
\begin {verbatim}
int evaluer_arbre (struct noeud *arbre)
\end{verbatim}
\end {quote}

	qui renvoie la valeur de l'expression mémorisée dans l'arbre.
	Pour choisir et réaliser une opération, vous utiliserez le choix
	multiple ({\tt switch}) pour sélectionner la fonction {\tt
	ajouter}, {\tt soustraire}, {\tt multiplier} ou {\tt diviser}.
	Ces fonctions prennent les deux opérandes comme arguments et
	renvoient le résultat de l'opération.

    \item Écrivez une fonction~:

\begin {quote}
\begin {verbatim}
void ecrire_algebrique (struct noeud *arbre)
\end{verbatim}
\end {quote}

	qui affiche l'expression mémorisée dans l'arbre comme une
	expression en notation algébrique (infixée). Par exemple,
	l'expression ci-dessus peut être écrite~:
	\verb:((3*(1+2))*(4+5)):.

\end {enumerate}


\question
%%%% Dependances:

Reprendre la fonction d'évaluation d'une expression mémorisée dans un
arbre (exercice~\ref {arbre}). Cette fois-ci, 
l'évaluation d'une opération doit être réalisée à l'aide d'un tableau de
pointeurs sur des fonctions.


\question
%%%% Dependances:

On définit une liste doublement chaînée par~:

\begin {quote}
\small
\begin {verbatim}
struct element
{
    int clef ;                   /* clef de recherche */
    char *valeur ;               /* valeur associee */
    struct element *suivant ;    /* suivant dans la liste */
    struct element *precedent ;  /* precedent dans la liste */
} ;

struct element tete ;
\end{verbatim}
\end {quote}

La variable {\tt tete} est un élément ne contenant aucune clef et aucune
valeur. Le champ {\tt suivant} pointe sur le premier élément de la
liste, le champ {\tt precedent} pointe sur le dernier. La liste doit
toujours être triée suivant la clef.

Écrivez les fonctions~:

\begin {itemize}
    \item \verb:void initialiser_liste (void): \\
	initialise la structure de liste~;
    \item \verb:void ajouter_element (int clef, char *valeur): \\
	ajoute un élément. La valeur doit être recopiée~;
    \item \verb:char *lire_valeur (int clef): \\
	renvoie un pointeur sur la valeur (sans la recopier)~;
    \item \verb:void retirer_element (int clef): \\
	retire l'élément identifié par sa clef.
\end {itemize}



\question
%%%% Dependances: tableaux de chaînes, malloc
    \label {getpath}

La variable Shell {\tt PATH} contient une liste de répertoires séparés
par des caractères ``{\tt :}''.  Par exemple~:
\verb|/bin:/usr/bin:/usr/local/bin|.

Écrivez une fonction qui prenne en paramètre une chaîne et sépare dans
un tableau de chaînes les différents constituants.

Écrivez un programme qui lit le contenu de la variable {\tt PATH}
(avec la fonction {\tt getenv}), sépare les différents constituants à
l'aide de la fonction que vous venez de programmer, et qui affiche
ces différents constituants.


\question
%%%% Dependances: fonctions, pointeurs, malloc, void *

On désire réaliser un module de gestion de pile générique (c'est à dire
qui soit capable de gérer des éléments de type quelconque). Pour cela,
on définit les fonctions suivantes~:

\begin {itemize}
    \item \verb:PILE *initialiser_pile (int taille):\\
	initialise les structures de données nécessaire. Le paramètre
	{\tt taille} est la taille d'un élément de la pile.
    \item \verb:void empiler (PILE *pile, void *valeur):\\
	empile l'élément situé à l'adresse {\tt valeur}~;
    \item \verb:int pile_vide (PILE *pile):\\
	teste si la pile est vide~;
    \item \verb:void depiler (PILE *pile, void *valeur):\\
	dépile l'élément au somment et le recopie à l'adresse spécifiée
	par {\tt valeur}.
\end {itemize}

Définissez le type {\tt PILE} (comme une liste doublement chaînée),
et programmez ces fonctions.


\question

On désire réaliser une fonction de tri polymorphique, c'est-à-dire qui
soit capable de trier des objets de n'importe quel type. Cette fonction
a la syntaxe suivante~:

\begin {quote}
\begin {verbatim}
void quicksort (void *tab [], int debut, int fin,
                int (*comp) (void *, void *))
\end{verbatim}
\end {quote}

Cette fonction utilise l'algorithme du tri rapide ({\em quick sort})
pour trier un les éléments d'indice compris entre {\tt debut} et {\tt
fin} (bornes incluses) d'un tableau d'éléments référencés par un
pointeur générique.  Pour comparer deux éléments, {\tt quicksort}
utilise une fonction prenant en paramètre deux pointeurs génériques et
renvoyant -1 si le premier argument est inférieur au deuxième, 0 s'ils
sont égaux, et 1 si le premier est supérieur au deuxième.

\begin {enumerate}
    \item écrivez un programme qui lit une suite de nombres flottants,
	utilise {\tt quicksort} pour les trier, et enfin affiche le
	tableau trié (on suppose qu'il ne peut pas y avoir plus de 10000
	nombres)~;

    \item écrivez un programme analogue pour trier des chaînes de
	caractères (on suppose qu'il ne peut pas y avoir plus de 10000
	chaînes, et chaque chaîne est limitée à 1000 caractères)~;

    \item écrivez enfin la fonction {\tt quicksort}.

\end {enumerate}


\question

Les sciences physiques sont consommatrices de puissance de calcul.  Les
problèmes traités font souvent apparaître des {\em matrices creuses},
c'est-à-dire des matrices peuplées essentiellement d'éléments nuls.

Par exemple, une matrice $10\thinspace000 \times 10\thinspace000$
représentée sous la forme d'un tableau bidimensionnel occupe
100\thinspace000\thinspace000 fois la taille d'une valeur flottante,
soit environ 400~Mo si 32 bits sont utilisés (ce qui correspond à la
simple précision sur la plupart des processeurs actuels).  Si cette
matrice contient seulement deux nombres non nuls par ligne, il n'y a que
80\thinspace000 octets d'information ``utile'', d'où une perte énorme.

Pour résoudre ce problème, on propose d'utiliser un codage différent
pour les matrices creuses~:  on représente un élément non nul par un
triplet $(i, j, v)$ où $i$ et $j$ sont les numéros de ligne et de
colonne et $v$ est la valeur de cet élément.  Ces éléments sont placés
dans une liste chaînée. Pour simplifier l'implémentation, on ne
cherchera pas à minimiser les temps de calculs.

Programmez les fonctions~:

\begin {quote}
\begin {verbatim}
typedef struct element *matrice ;

matrice ajouter_matrice (matrice M1, matrice M2, int n)
matrice multiplier_matrice (matrice M1, matrice M2, int n)
\end{verbatim}
\end {quote}

Note~: on suppose que les matrices sont de dimension $n \times n$.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LANGAGE C : PROGRAMMATION AVANCEE
%
% Historique
%   1993/02/03 : pda : création
%   1995/10/06 : pda : adaptation pour 95/96
%   1996/01/03 : pda : ajout de l'exercice malloc/free
%   1996/09/10 : pda : réunion en un seul thème
%   1997/08/26 : pda : ajout des questions pour l'analyse des makefiles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\td {Langage~C~: Programmation avancée}

% \but
% 
% L'objet de ce TD est d'appréhender quelques points avancés du
% langage~C~: compilation séparée, programmation portable, 
% fonctions à nombres d'arguments variables, etc.


\question
%%%% Dependances: stdarg

Écrivez en C ANSI une fonction {\tt afficher\_couples}~:

\begin {quote}
    \verb|void afficher_couples (int nbcouples, ...)|
\end {quote}

qui prend un nombre de couples, puis une suite de couples
(chaîne, entier) à afficher sur la sortie standard.


\question

On désire écrire un programme pour calculer la circonférence et la
surface d'un cercle étant donné son rayon.  Le programme doit être
composé de plusieurs fichiers~:

\begin {quote}
    \renewcommand {\arraystretch} {1}
    \begin {tabular} {ll}
	\tt principal.c & contient la fonction {\tt main} \\
	\tt circonference.c & contient la fonction {\tt circonference} \\
	\tt surface.c & contient la fonction {\tt surface} \\
	\tt pi.h & contient la définition de la valeur approchée de $\pi$
    \end {tabular}
\end {quote}


\begin {enumerate}
    \item
	Écrivez le contenu des différents fichiers, et
	donnez la commande minimum de compilation du programme.

    \item
	Décomposez cette commande de manière à avoir une commande pour
	la compilation de chaque fichier, puis une commande pour
	l'édition de liens.  \\
	Si vous modifiez le fichier {\tt surface.c}, donnez les
	commandes minimum pour recompiler le programme.  Même question
	pour la modification du fichier {\tt pi.h}.

    \item
	Représentez les dépendances de l'exercice précédent sous forme
	de graphe étiqueté.  Écrivez le fichier {\tt Makefile}
	correspondant.

	Ajoutez une cible fictive {\tt clean} dans le {\tt Makefile}
	pour supprimer tous les fichiers intermédiaires ainsi que le
	fichier résultat.

\end {enumerate}


\question

On désire connaître le nombre d'occurrences de chaque mot lu sur
l'entrée standard.  Par exemple, le texte ``{\em il fait beau, n'est il
pas ?}'' est constitué de :

\begin {quote}
    \renewcommand {\arraystretch} {0.9}
    \tt
    \begin {tabular} {ll}
	il   & : 2 fois \\
	fait & : 2 fois \\
	beau & : 1 fois \\
	n    & : 1 fois \\
	est  & : 1 fois \\
	pas  & : 1 fois 
    \end {tabular}
\end {quote}

Pour cela, on définit les fonctions~:

\begin {itemize}
    \item \verb:void initialiser_mots (void): \\
	qui initialise la structure de données associée aux mots~;

    \item \verb:struct mot *trouver_mot (char texte []): \\
	qui trouve un mot, et le crée s'il n'est pas trouvé~;

    \item \verb:void mettre_a_jour_mot (struct mot *mot): \\
	qui met à jour (incrémente) le compteur associé au mot~;

    \item \verb:void afficher_mots (void): \\
	qui affiche le résultat final.

\end {itemize}


\begin {enumerate}
    \item Écrivez le programme en supposant que les fonctions
	ci-dessus existent déjà et sont dans un autre module (fichier).
	Vous placerez dans un fichier {\tt mot.h} les déclarations des
	prototypes de ces fonctions.  Y-a-t'il besoin de placer la
	définition de la structure {\tt mot} dans ce fichier~?

    \item Écrivez les fonctions ci-dessus en prenant comme structure
	de données une liste simplement chaînée~:

\begin {quote}
\small
\begin {verbatim}
struct mot
{
    char *texte ;          /* texte associe au mot */
    int   nb_occurrences ; /* nb d'occurrences du mot */
    struct mot *suivant ;  /* liste chainee */
} ;
struct mot *tete ;
\end{verbatim}
\end {quote}

    \item Écrivez une nouvelle version des fonctions ci-dessus en
	utilisant une table de hachage.

\end {enumerate}


\question

\`A l'aide des mécanismes de compilation conditionnelle offerts par le
préprocesseur, reprenez l'exercice précédent et intégrez les deux
structures de données pour représenter les mots (liste chaînée et table
de hachage) en un seul fichier. La personne qui compile votre programme
doit pouvoir sélectionner l'une ou l'autre structure en définissant un
seul symbole ou en ne le définissant pas.


\question

Sur HP-UX, la page de manuel {\em p} du chapitre {\em n} est localisée
dans le fichier de nom
{\tt /usr/share/man/man{\em n}.Z/{\em p}.{\em n}}. Cette page est
compressée, et la commande pour la formatter est~:
\verb:zcat | nroff -man: en supposant que le fichier est présenté sur
l'entrée standard.

Sur SunOS, la page de manuel {\em p} du chapitre {\em n} est localisée
dans le fichier de nom
{\tt /usr/man/man{\em n}/{\em p}.{\em n}}. Cette page n'est pas
compressée, et la commande pour la formatter est~:
\verb:nroff -man: toujours en supposant que le fichier est présenté sur
l'entrée standard.

Écrivez une commande {\tt man}. Votre programme doit être portable
sur HP-UX ou sur SunOS, en utilisant le symbole {\tt hpux} ou {\tt sun}
du préprocesseur. Vous utiliserez la fonction {\tt popen} pour formatter
la page de manuel.

Rappel~: la vraie commande  {\tt man} admet 1 ou 2 paramètres~:

\begin {quote}
    {\tt man} [ {\em n} ] {\em p}
\end {quote}

Si le chapitre {\em n} n'est pas fourni, la page correspondant à {\em p}
est cherchée dans l'ensemble des chapitres. On supposera que le chapitre
est un entier entre 1 et 8.


\question

Analysez les fichiers {\tt Makefile} ci-après (voir pages~\pageref
{makefile} à~\pageref {makefile-fin}), et répondez aux questions
suivantes~:

\begin {enumerate}
    \item Si on appelle {\tt make} à partir du répertoire {\tt demo/lib},
	quel est le fichier créé~? Même question pour les répertoires
	{\tt demo/src} et {\tt demo/doc}.

    \item Expliquez l'enchaînement des appels à {\tt make} lors de
	l'appel initial à {\tt make} dans le répertoire {\tt demo}.

    \item Dans le fichier {\tt demo/Makefile}, pourquoi les {\tt
	antislashes} (\verb:\:) sont-ils nécessaires dans la cible {\tt
	subdirs}~?

    \item Expliquez l'action effectuée lors de la construction de la
	cible {\tt pcc.o} si {\tt make} est appelé depuis le répertoire
	{\tt demo/src}. Même question si {\tt make} est appelé depuis le
	répertoire {\tt demo}.

    \item Comment fait-on pour adapter l'ensemble du programme à une
	autre version de système d'exploitation~? Où sont concentrées
	les modifications à apporter~? Pourquoi~?

    \item Expliquez les actions effectuées lors de la construction de la
	cible {\tt manuel.ps}.

    \item Pourquoi le fichier {\tt demo.o} (répertoire {\tt demo/src}) est
	construit avec une méthode différente des autres fichiers~?

\end {enumerate}



\question
%%%% Dependances: malloc, sbrk, gestion mémoire

\`A l'aide de la primitive système {\tt sbrk}, écrivez une version
des fonctions de librairie {\tt malloc} et {\tt free}.

Votre version doit tenir à jour une liste de blocs mémoire, triée
selon les adresses. Chaque bloc
est soit alloué, soit libre. Cette liste est gérée selon l'algorithme
du ``{\em First Fit\/}'', c'est à dire que lors d'une demande
d'alloction, le premier emplacement libre suffisamment grand est
choisi. S'il n'y a pas assez de mémoire, une page de 4096 octets
est demandée au système avec {\tt sbrk}. Lorsqu'un emplacement est
libéré avec {\tt free}, on fusionne cet emplacement avec les
emplacements adjacents s'ils étaient eux-mêmes libres.

Pour simplifier, on ne tiendra pas compte des contraintes
d'alignement.


\cleardoublepage
    \label {makefile}

\subsection* {Fichier demo/Makefile}

{\small
\listing {mf1}
}

\clearpage
\subsection* {Fichier demo/lib/Makefile}

{\small
\listing {mf2}
}

\clearpage
\subsection* {Fichier demo/src/Makefile}

{\small
\listing {mf3}
}

\subsection* {Fichier demo/doc/Makefile}

{\small
\listing {mf4}
}
\label {makefile-fin}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PRIMITIVES DE GESTION DE FICHIERS
%
% Historique
%   1993/01/31 : pda : création
%   1996/09/10 : pda : réunion en un seul thème
%   1997/08/26 : pda : ajout de l'exercice des erreurs
%   1997/08/26 : pda : ajout de l'exercice "ls"
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: Gestion de fichiers}

% \but
% 
% L'objet de ce TD est l'étude des primitives système, et plus
% particulièrement des primitives de gestion des fichiers.


\question

Nommez quelques primitives système. Est-ce que {\tt fopen} est une
primitive système~?

Quelles sont les différences et ressemblances entre
primitives système et fonctions de bibliothèque~?
Comment justifier ces différences~?

Illustrez ces différences et ressemblances sur les
fonctions et primitives d'entrée~/~sortie.


\question

Pourquoi la fonction ci-dessous ne peut pas fonctionner ?  Détaillez
toutes les fautes.  On ne demande pas de corriger cette fonction.

\begin {quote}
\small
\begin {verbatim}
int faux (char *nom)
{
    FILE *fp ;
    int c ;

    fp = open (nom, "r") ;
    read (fp, &c, 1) ;
    fclose (fp) ;
    return c ;
}
\end{verbatim}
\end {quote}


\question
    \label {cp}

Écrivez un programme qui recopie un fichier {\tt toto} vers un fichier
{\tt titi} à créer, à l'aide des primitives système.
Vous ne chercherez
pas à créer le nouveau fichier avec les permissions du fichier original.


\question

Écrivez la fonction {\tt getchar} qui renvoie un caractère lu
sur l'entrée standard, ou la constante {\tt EOF} en fin de
fichier.

Quelle peut être la valeur numérique de la constante EOF~?


\question

Écrivez une version bufferisée de {\tt getchar}.


\question

On croit souvent que les primitives système étant de plus bas niveau,
elles sont plus efficaces que les fonctions de bibliothèque
équivalentes. On désire confirmer ou infirmer cette proposition par
l'expérimentation.

Pour cela, on demande de rédiger deux programmes pour copier l'entrée
standard sur la sortie standard. Le premier utilisera les fonctions
de bibliothèque \texttt {getchar} et \texttt {putchar}.  Le deuxième
utilisera les primitives système \texttt {read} et \texttt {write}
et prendra en argument la taille du buffer utilisé pour la copie.
Si cette taille égale 1, la copie sera effectuée caractère par
caractère.

Vous utiliserez la commande Unix \texttt {time} pour comparer les
temps d'exécution, en considérant la somme des temps CPU en mode
utilisateur et en mode système\footnote {Le temps «~réel~» correspond
au temps réellement écoulé~: on nt'utilisera pas cette valeur car
elle dépend de la charge du système.}.

En prenant comme tailles de buffer les puissances successives de 2
(2$^0$, 2$^1$, 2$^2$, 2$^3$, etc.), à partir de quelle taille de
buffer est-il plus intéressant d'utiliser les primitives système
que les fonctions de bibliothèque~?


\question

Écrivez un programme qui affiche en clair le type du fichier demandé
(répertoire, fichier ordinaire, etc.), ainsi que ses permissions
(lecture, écriture et exécution, sous la même forme que la commande {\tt
ls} avec l'option {\tt -l}).


\question

On désire implémenter une nouvelle version de la librairie standard
d'entrées/sorties à l'aide des primitives système.

\begin {enumerate}
    \item Donnez une définition du type {\tt FICHIER}.  N'oubliez de
	prévoir la bufferisation des entrées/sorties.

    \item Programmez la fonction {\tt my\_open}, analogue à {\tt fopen}.

    \item Reprenez l'exercice précédent pour programmer {\tt my\_getc},
	analogue à {\tt getc}.

    \item Programmez la fonction {\tt my\_putc}, analogue à {\tt putc}.

    \item Programmez la fonction {\tt my\_close}, analogue à {\tt
	fclose}.

\end {enumerate}



\question

Écrivez une commande qui prend en paramètre un nom de répertoire, et
qui affiche tous les objets contenus dans ce répertoire. On prendra les
mêmes conventions de restriction d'affichage que la commande {\tt ls}
(pas d'affichage des noms commençant par un point).


\question

Reprenez le programme de l'exercice~\ref {cp} pour recopier toute une
arborescence.


\question

Reprenez le programme de l'exercice précédent pour restaurer dans les
copies les dates d'accès et modification ainsi que les permissions des
fichiers originaux.


\question

Reprenez la fonction développée lors de l'exercice~\ref {getpath} pour écrire
un programme {\tt which} afin de chercher où une commande est trouvée.
Par exemple, ``{\tt which~ls}'' doit donner~: {\tt /bin/ls}.


\question

Le shell {\tt ksh} dispose d'une variable {\tt CDPATH}.  Celle-ci
spécifie une certain nombre de répertoires de recherche.  Lorsqu'on
utilise {\tt cd} avec un argument (nom de chemin relatif), celui est
cherché dans les différents répertoires indiqués par {\tt CDPATH} et le
changement de répertoire est effectué s'il est trouvé.

Programmez une commande {\tt chdir}.

Pourquoi cette commande ne peut pas fonctionner~?




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PRIMITIVES DE GESTION DE PROCESSUS
%
% Historique
%   1993/01/31 : pda : création
%   1996/01/06 : pda : séparation en deux TD
%   1996/09/10 : pda : réunion en un seul thème
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: Gestion des processus}

% \but
% 
% L'objet de ce TD est l'étude des primitives système de
% gestion des processus.


\question

Écrivez un programme générant un processus fils avec la primitive
système {\tt fork}.

\begin {itemize}
    \item le processus fils doit afficher son numéro ({\em pid}) ainsi
	que le numéro du père à l'aide des primitives système {\tt
	getpid} et {\tt getppid}, puis sort (primitive {\tt exit}) avec
	un code de retour égal au dernier chiffre du {\em pid}.

    \item le processus père, quant à lui, affiche le {\em pid} du fils,
	puis attend sa terminaison (primitive {\tt wait}) et affiche son
	code de retour.

\end {itemize}


\question

Écrivez un programme qui lance {\em n} processus fils dans une
première étape puis, dans une deuxième étape, attend leur terminaison
à l'aide de la primitive {\tt wait}.
\`A chaque fois qu'un processus se termine,
le père affiche son numéro ({\em pid}) et son code de retour.


\question

Écrivez un programme ayant la syntaxe suivante~:

\vspace* {-3mm}
\begin {quote}
{\tt matproc $n$ $m$}
\end {quote}

L'action de ce programme doit être de générer $n$ processus, chacun
d'entre-eux devant générer $n$ processus à son tour, et ainsi de suite
jusqu'à $m$ niveaux.

Combien de processus sont générés au total ?


\question

Écrivez un programme qui~:

\begin {enumerate}
    \item lance la commande {\tt ls} sur un répertoire passé en
        paramètre,
    \item redirige la sortie standard de {\tt ls} sur {\tt /dev/null},
    \item affiche le temps pris par la commande {\tt ls} (primitive
	système {\tt times}).
\end {enumerate}


\question

Écrivez un programme qui~:

\begin {enumerate}
    \item attende une ligne (une commande) sur l'entrée standard (vous
	pouvez utiliser la fonction de librairie {\tt fgets})~;

    \item la décompose en mots séparés par des espaces~;

    \item recherche le premier mot dans le {\tt PATH}~;

    \item exécute cette commande par le biais de la primitive système
	{\tt execv}~;
    
    \item revienne au point 1.

\end {enumerate}

Félicitations, vous avez écrit un {\em shell}~!


\question

Reprenez le programme de l'exercice précédent et ajoutez un traitement
spécial dans le cas où la commande est terminée par le mot \verb:&:.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ENVIRONNEMENT D'UN PROCESSUS, SIGNAUX V7, SIGNAUX POSIX
%
% Historique
%   1996/02/27 : pda : création
%   1996/09/10 : pda : séparation de l'environnement
%   1997/08/26 : pda : ajout de l'exercice pwd
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: Environnement d'un processus}

% \but
% 
% L'objet de ce TD est l'approfondissement de notions souvent
% rencontrées dans le contexte des processus.


\question

La variable globale {\tt environ} est déclarée comme~:

\begin {quote}
    \verb|extern char **environ|
\end {quote}

Cette variable est automatiquement définie. Elle référence le premier
élément d'un tableau de chaînes de la forme {\em var{\tt=}valeur}. Ce
tableau est terminé par le pointeur {\tt NULL}.

Dessinez cette structure de données.

Écrivez la fonction de librairie {\tt getenv}.


\question

La fonction de librairie {\tt system} prend en argument une commande
(contenant éven\-tuel\-lement des redirections, ou même composée de
plusieurs commandes reliées par un tube), l'exécute et renvoie
le code de retour de la commande si elle a été lancée, ou -1
sinon.

Vous utiliserez le Shell de Bourne ({\tt /bin/sh}) avec l'option {\tt
-c} pour exécuter la commande.


\question

Il peut arriver qu'un programme désire savoir si l'entrée ou la
sortie standard a été redirigée.

Donnez des exemples de programmes dont le comportement dépend de la
redirection de l'entrée ou de la sortie standard.

Écrivez la fonction {\tt isatty} qui prend en argument un descripteur
de fichier, et renvoie 1 si c'est un terminal (ou plus généralement un
périphérique en mode caractère) ou 0 sinon.


\question

Les champs {\tt st\_dev} et {\tt st\_ino} de la structure {\tt stat}
identifient de manière unique un fichier dans le système. Écrivez une
fonction {\tt ttyname} qui prend en paramètre un descripteur de fichier,
et renvoie un pointeur sur une chaîne (statique) contenant le nom
complet du fichier (cherché dans {\tt /dev}) correspondant.


\question

Écrivez une nouvelle version de la fonction {\tt getcwd}.  Pour cela,
on cherchera le numéro d'inode du répertoire courant.  Puis, on
cherchera dans le répertoire parent le nom correspondant à l'inode du
répertoire courant.  En répétant cette opération jusqu'au répertoire
d'inode numéro 2 (la racine du système de fichiers), on peut
reconstituer le nom du répertoire courant.

On notera que cette méthode ne tient compte que du système de fichiers
courant. On n'essayera pas de s'affranchir de cette limitation.


% getlogin
% 
% sleep
% 
% simuler des tubes (popen) avec des fichiers

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SIGNAUX V7, SIGNAUX POSIX
%
% Historique
%   1993/01/31 : pda : création
%   1995/05/02 : pda : ajout des signaux POSIX
%   1996/02/28 : pda : séparation des tubes
%   1996/09/10 : pda : séparation de l'environnement
%   1996/09/10 : pda : réunion des signaux POSIX
%   2007/04/19 : pda : séparation exercices 1 et 2
%   2007/04/19 : pda : rédaction exercice envoyer/reception
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: Signaux}

% \but
% 
% L'objet de ce TD est l'étude des signaux V7 et POSIX.


\question

À l'aide des primitives V7, écrivez un programme qui attend l'arrivée
d'un signal (n'importe lequel), affiche sa signification (par
exemple~:  {\tt illegal instruction} pour {\tt SIGILL}) puis se
termine.


\question

Modifiez le programme de la question précédente pour traiter plusieurs
signaux consécutifs~: votre programme ne doit pas se terminer après
l'arrivée d'un signal.


\question

Écrivez un programme composé de deux processus.  Le processus père
génère un processus fils qui doit exécuter une fonction {\tt traite}
toutes les secondes.  Au bout d'une minute, le processus père le
prévient qu'il doit s'arrêter.  Lorsque le processus fils s'arrête
effectivement, le processus père se termine. Vous utiliserez les
primitives V7.


\question

Écrivez un programme composé d'une boucle sans fin qui
incrémente un compteur. Lorsque l'utilisateur appuie sur la touche
d'interruption (signal {\tt SIGINT}), le programme sauve la date en
clair et la valeur courante du compteur dans un fichier,
à la suite de ce qui s'y trouve déjà.
Lorsque le signal {\tt SIGTERM} est reçu, le programme écrit
le mot {\tt fin} dans le fichier, puis se termine. Vous utiliserez les
primitives POSIX.


\question

On désire simuler un mécanisme matériel comparable à un coupleur série
à l'aide des signaux POSIX. Un 0 (zéro) est matérialisé par le signal
{\tt SIGUSR1}, un 1 (un) est matérialisé par le signal {\tt SIGUSR2}.
Un octet est transmis par une succession de 8 bits (0 ou 1).
À chaque fois qu'il reçoit un bit, le récepteur doit envoyer en
retour un acquittement (signal {\tt SIGUSR1}) pour prévenir l'émetteur
qu'il peut passer au bit suivant.

Écrivez les fonctions suivantes~:

\begin {enumerate}
    \item \verb:void envoyer (pid_t recepteur, int octet):

	Cette fonction envoie les 8 bits constituant un octet au
	processus désigné.

    \item \verb:void preparer_reception (pid_t emetteur):

	Cette fonction prépare le récepteur à recevoir un octet.

    \item \verb:void int recevoir (void):

	Cette fonction attend que suffisamment de bits soient reçus
	pour constituer un octet,  et renvoie alors la valeur reçue.

\end {enumerate}


\question

En utilisant un protocole similaire à celui de la question précédente,
on désire simuler le fonctionnement d'un tube, c'est à dire réaliser
les fonctions suivantes~:

\begin {enumerate}
    \item \verb:void preparer_tube (void):

	Cette fonction initialise les structures de données associées
	au tube.

    \item \verb:void processus_tube (pid_t autre, int sens):

	Connaissant le \textit {pid} de l'autre processus, cette
	fonction initialise l'accès au tube pour une lecture (sens
	= 1) ou pour une écriture (sens = 2).

    \item \verb:void fermer_tube (void):

	Cette fonction ferme le tube.

    \item \verb:void ecrire_tube (void *buffer, int longueur):

	Cette fonction écrit dans le tube les données spécifiées.

    \item \verb:int lire_tube (void *buffer, int longueur):

	Cette fonction extrait du tube les données et les renvoie
	dans le buffer. Le nombre d'octets lus est renvoyé (0 en
	fin de tube).

\end {enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TUBES
%
% Historique
%   1993/01/31 : pda : création
%   1995/05/02 : pda : ajout des signaux POSIX
%   1996/02/28 : pda : séparation des tubes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: Tubes}

% \but
% 
% L'objet de ce TD est l'étude des tubes.


\question
    \label {q:tube1}

Écrivez un programme composé de deux processus~: le
premier lit des données sur l'entrée
standard et les passe par un {\em tube} au deuxième qui les
affiche sur sa sortie standard.


\question

Généralisez l'exercice précédent à $n$ processus~:  le premier passe les
données depuis l'entrée standard au second, qui les passe au troisième,
et ainsi de suite jusqu'au $n-1$-ème qui les passe au $n$-ème, qui les
écrit sur sa sortie standard.


\question

On désire connaître la capacité d'un tube.  Pour cela, on propose
d'envoyer des données, en les comptant, dans un tube qu'aucun lecteur ne
consulte (ouvert en lecture, mais jamais lu par un processus).  Au bout
d'un certain nombre d'octets, l'écrivain se bloque en attendant que le
tube se vide.  Si un signal survient dans cet état, on peut afficher le
nombre d'octets placés dans le tube, c'est à dire sa capacité.

Faites un programe pour afficher la taille d'un tube avec la méthode
ci-dessus.


\question

Reprenez l'exercice~\ref {q:tube1} en le séparant en deux
programmes distincts et en utilisant un tube nommé.  Le premier
programme crée le tube avec {\tt mkfifo}, et y place les données lues
sur l'entrée standard.  Le deuxième programme ouvre le tube, lit les
données qui s'y trouvent et les affiche sur sa sortie standard.


\question

On désire mettre en place un système de communication inter-processus
sous le contrôle d'un gérant de communication.  Le gérant de
communication reçoit des requêtes des processus par un (unique) tube
nommé (appellé $T$). Le nom de ce tube est connu par tous les processus
voulant communiquer.

Lorsqu'un processus $P_i$ veut communiquer avec un autre, il crée un
tube nommé (appelé $T_i$) qui lui est propre, puis envoie au gérant (par
l'intermédiaire du tube $T$) un message spécifiant le nom de $T_i$.
C'est l'{\em abonnement}.

Le gérant ouvre alors $T_i$, lui associe un numéro interne ($\geq 0$),
et renvoie ce numéro interne au processus $P_i$ par l'intermédiaire de
$T_i$.

Par la suite, lorsque le processus $P_i$ veut envoyer un message au
processus $P_j$, le processus $P_i$ écrit un message dans le tube $T$,
le gérant lit ce message, l'analyse pour voir si c'est possible (i.e.
si $P_j$ est déjà abonné) et l'envoie à $P_j$ par l'intermédiaire du
tube $T_j$. Le gérant envoie un message $P_i$ pour lui signaler si
l'opération a réussi ou non.

Le processus $P_i$ doit pouvoir obtenir la liste de tous les processus
abonnés. Dans ce cas, il envoie un message dans $T$, le gérant répond
alors par $T_i$ en lui envoyant la liste.

Le processus $P_i$ doit aussi pouvoir se désabonner.

\begin {enumerate}
    \item Spécifiez le format des messages (c'est-à-dire le {\em
	protocole}) circulant dans $T$ et dans les tubes $T_i$.

    \item Programmez le gérant.

\end {enumerate}


\question

On s'intéresse maintenant aux processus clients (les $P_i$). Ils
doivent avoir une interface simplifiée (interface de programmation)
pour dialoguer avec le gérant.

Cette interface suppose que toutes les données relatives à une
connexion sont décrites par un type {\tt comm} dont vous devez
définir le contenu.

Les fonctions disponibles sont~:

\begin {itemize}

    \item \verb:comm initialiser (char tube []):

	Cette fonction amorce une communication avec le gérant spécifié
	par le tube de nom {\tt tube} (elle crée et ouvre le tube propre
	au processus, et elle le tube du gérant).

    \item \verb:int liste (comm gerant, int abonnes [], int maxab):

	Cette fonction retourne dans le tableau {\tt abonne} la liste
	des abonnes au gérant de communication spécifié par {\tt
	gerant}.  Le nombre maximum\footnote {S'il y a plus d'abonnés,
	leurs numéros sont perdus.} de numéros pouvant être placés dans
	ce tableau est spécifié par {\tt maxab}. Cette fonction retourne
	le nombre d'abonnés placés dans le tableau, ou -1 pour signifier
	une erreur.
    
    \item \verb:int envoyer (comm gerant, int abonne, char *message, int lg):

	Cette fonction envoie à l'abonné {\tt abonne}, par
	l'intermédiaire du gérant, un message spécifié par les {\tt lg}
	octets inclus dans {\tt message}.  Le résultat est un code
	signifiant si l'opération s'est bien déroulée.

    \item \verb:int recevoir (struct comm *comm, char *message, int *lgmax):

	Cette fonction attend un message. Le message (au plus {\tt
	lgmax} octets) est placé dans la zone spécifiée par {\tt
	message}. La longueur du message reçu est placée en retour dans
	{\tt lgmax}. Le résultat de cette fonction est l'identificateur
	de l'émetteur, ou -1 si une erreur est intervenue.

\end {itemize}

On vous demande de :

\begin {enumerate}

    \item définir le type {\tt comm}~;

    \item programmer une application simple à l'aide des fonctions
	décrites ci-dessus~: à chaque fois qu'un processus s'abonne, il
	demande à tous les autres abonnés leur numéro de processus, et
	affiche le numéro minimum~;
    
    \item programmer les fonctions ci-dessus.

\end {enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IPC SYSTEM V
%
% Historique
%   1993/01/31 : pda : création
%   1996/04/09 : pda : séparation
%   1996/09/10 : pda : réunion en un seul thème
%   2007/05/11 : pda : ajout exercice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Système~: IPC System V}

% \but
% 
% L'objet de ce TD est l'étude des primitives de communication dites IPC
% System~V.


\question

Écrivez un programme composé de deux processus. Le père crée
une file de messages anonyme, puis y envoie des messages composés
de lignes lues sur l'entrée standard. Lorsque la fin de fichier
est détectée, il envoie une chaîne vide, puis attend la terminaison
du processus fils. Le processus fils reçoit les messages, puis
comptabilise le nombre d'octets reçus.


\question

On désire traiter des requêtes fournies sous forme de messages, chaque
requête étant composée d'une priorité (de 1 à 3, 1 étant la plus
prioritaire) et d'une donnée de type \verb|char []|.

La file de messages est identifiée par une clef formée à l'aide d'un nom
de fichier ({\tt toto} par exemple) et de la lettre E.

Écrivez le programme serveur qui crée la file de messages, puis traite
les messages selon leur priorité.  Chaque message est traité à l'aide
d'une fonction {\tt traite} que l'on supposera écrite.  Le programme
doit se terminer et effacer la file de messages lorsqu'il reçoit un
message contenant une donnée de taille nulle.

Écrivez à présent le programme client qui reçoit zéro (pour envoyer un
message de taille nulle) ou deux paramètres (priorité et chaîne de
caractères représentant la donnée).


\question

On suppose qu'il existe une file de messages de clef $c$. On désire
avoir un système qui permette à $n$ processus d'émettre des messages à
destination du processus $i$ ($1 \leq i \leq n$).

Programmez les fonctions~:

\begin {quote}
\begin {verbatim}
    int ouvrir (key_t clef)
    int envoyer (int msqid, int moi, int lui,
                        void *message, size_t taille)
    int recevoir (int msqid, int moi, int *lui,
                        void *message, size_t *taille)
\end{verbatim}
\end {quote}

La fonction {\tt ouvrir} doit permettre l'accès à la file. La fonction
{\tt envoyer} envoie, par l'intermédiaire de la file, un message à
destination du processus {\tt lui}, composé de {\tt taille} octets
situés à l'adresse {\tt message}. La fonction {\tt recevoir} attend un
message de l'un quelconque des processus, place à l'adresse {\tt lui} le
numéro de l'émetteur, et place à l'adresse {\tt message} le message
reçu. Le paramètre {\tt taille} précise la place maximum utilisable pour
le message en entreé, et la place réellement utilisée en sortie.


\question

On désire communiquer des grandes quantités de données entre deux
processus.  Pour cela, on propose d'utiliser un segment de mémoire
partagée de taille {\tt MAX} octets.  Lorsque l'émetteur désire envoyer
$n$ octets, il les place au début du segment, puis il envoie un
message contenant $n$ au récepteur.  Lorsque le récepteur a fini de
lire le message, il renvoie un message a l'émetteur pour signifier que
la place est libre. Programmez les deux processus.


\question

% DEPENDANCE VIS-A-VIS DE LA QUESTION PRECEDENTE
Reprenez l'exercice précédent en utilisant un segment de mémoire
partagée et un groupe de sémaphores~: expliquez la méthode de
synchronisation et programmez les deux processus.


\question

Écrivez un programme composé de deux processus~:  le premier
initialise un segment de mémoire partagée et un groupe de deux
sémaphores, crée le fils, puis lit des données entières dans le segment
et les affiche.  Le fils calcule des données avec une fonction {\tt
calcul} (qui renvoie 0 lorsque toutes les données ont été calculées) et
les transmet au fur et à mesure au père par l'intermédiaire du segment
de mémoire partagée.  Pour écrire une donnée, le fils fait un P sur le
premier sémaphore, écrit la donnée, puis fait un V sur le deuxième
sémaphore.  De manière symétrique, le père fait un P sur le deuxième
sémaphore, lit la donnée, puis fait un V sur le premier sémaphore.


\question

% DEPENDANCE VIS-A-VIS DE LA QUESTION PRECEDENTE
En vous basant sur l'exercice précédent, écrivez deux programmes.
Le premier s'utilise de la manière suivante~:

\begin {quote}
    \small
    \verb|producteur| \textit {n}
\end {quote}

où \textit {n} est une valeur entière. La valeur est placée dans
le segment de mémoire partagée après la dernière valeur déjà produite.
S'il n'y a plus d'emplacement libre, le programme attend qu'un
emplacement se libère par le deuxième programme.

Le deuxième programme, \texttt {consommateur}, ne prend aucun
argument et renvoie la première valeur stockée dans le segment de
mémoire partagée. Si aucune valeur n'est disponible, le programme
attend qu'un producteur y stocke une valeur.

Vous noterez que l'indice de la première valeur stockée doit être
partagé par tous les consommateurs. De même, l'indice du premier
emplacement libre doit être partagé par tous les producteurs.  Ces
deux indices doivent donc être placés dans le segment de mémoire
partagée, et constituent des variables critiques qui doivent être
protégées par des sémaphores d'exclusion mutuelle.


\question

On souhaite implémenter un mécanisme comparable aux files de messages à
l'aide de la mémoire partagée et un groupe de trois sémaphores.  Le
segment de mémoire partagée contient (voir figure) un en-tête, puis les
messages eux-mêmes.
La zone des messages est gérée comme un buffer circulaire~:  lorsqu'un
message ne peut être mis en entier à la fin du segment, sa suite est
placée au début de la zone des messages.
L'en-tête contient la taille de la zone des messages, les références au
premier message et au dernier message.

% \fig {msg} {Segment de mémoire partagée}
\fig {msg}

Par convention, le groupe de sémaphores a une clef égale à la
clef du segment de mémoire partagée + 1. Il contient~:

\begin {itemize}
    \item un sémaphore représentant la place disponible dans le
	segment~:  il est initialisé à la taille de la zone des messages
	en nombre d'octets~;
    \item un deuxième sémaphore pour réaliser l'exclusion mutuelle lors
	de la manipulation des structures de données~: il est initialisé
	à 1~;
    \item un troisième sémaphore pour représenter le nombre de messages
	dans la file~: il est initialisé à 0~;
\end {itemize}


Écrivez les fonctions~:

\begin {itemize}
    \item \verb|int initialiser_file (key_t clef)| \\
	cette fonction, appelée une seule fois, crée et initialise un
	segment de mémoire partagée pour 10000 octets de messages, puis
	crée le groupe de sémaphores et l'initialise et retourne -1 en
	cas d'erreur~;

    \item \verb|int envoyer (key_t clef, const char *message)| \\
	cette fonction envoie le message spécifié, et retourne -1 en cas
	d'erreur~;

    \item \verb|int recevoir (key_t clef, char *message)| \\
	cette fonction attend un message, le recopie dans la zone
	spécifiée par l'adresse fournie en paramètre (que l'on suppose
	déjà allouée), et retourne -1 en cas d'erreur.

\end {itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SOCKETS
%
% Historique
%   2008/01/14 : pda : création
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\td {Réseau~: Sockets}

% \but
% 
% L'objet de ce TD est l'étude des primitives systèmes de programmation
% réseau (sockets) et des fonctions de bibliothèque associées.

\question

Écrivez un programme qui prend en paramètre un nom de hôte (tel que
\texttt {mailhost.u-strasbg.fr} par exemple), une adresse IPv4 ou
une adresse IPv6. Pour chaque adresse trouvée par la fonction \texttt
{getaddrinfo}, votre programme doit afficher la famille d'adresses
(IPv4 ou IPv6) et l'adresse avec la fonction \texttt {inet\_ntop}.


\question

Modifiez votre programme précédent pour ne sélectionner qu'une
famille d'adresses (IPv4 ou IPv6).



\question

Écrivez un client UDP pour le protocole Echo (service «~\texttt
{echo/udp}~»).

Écrivez un serveur UDP pour le protocole Echo (service «~\texttt
{echo/udp}~»).

\question

Même question que précédemment en mode TCP.


\question

Écrivez à l'aide du protocole TCP un client et le serveur qui
échangent des valeurs. On adoptera le protocole décrit par la
structure suivante~:

\begin {quote}
\begin {verbatim}
struct proto {
    uint16_t nint ;          /* nombre de valeurs émises */
    int32_t valeurs [MAX] ;  /* les valeurs elles-mêmes */
} ;
\end{verbatim}
\end {quote}

Le client accepte comme premier argument un nom de hôte ou une
adresse IP (v4 ou v6), et comme arguments suivants la liste des
valeurs à transmettre. Les arguments suivants seront les valeurs.
Pour chaque connexion de client, le serveur doit lire la liste de
valeurs, et renvoyer au client les valeurs élevées au carré.

Les données doivent être échangées, même si les deux ordinateurs
ont des formats de stockage des entiers différents.


\question

Modifiez le programme de la question précédente~: si la connexion
vient d'une adresse IPv4, le serveur renvoie les nombres élevés à
la puissance 4. Si la connexion vient d'une adresse IPv6, le serveur
renvoie les nombres élevés à la puissance 6.


\question

Programmez un système de discussion multi-utilisateurs (\textit
{chat\/}). Chaque client se connecte sur le serveur. Toute ligne
saisie par l'utilisateur est envoyée par le client vers le serveur.
Toute ligne reçue depuis le serveur est affichée à l'écran. Lorsque
le serveur reçoit une ligne d'un client, il la retransmet à tous
les autres clients.


\question

L'objet de cette question est de rédiger un programme pour distribuer
des jetons à des clients IP. On représente un jeton par un entier
de 1 à $n$. Le serveur accepte des connexions des clients.

Si le client demande un jeton, le serveur lui attribue le premier
jeton disponible et mémorise l'adresse IP du client et la date
d'attribution. Ces informations (jetons, adresse IP associée et
date d'obtention) doivent être mémorisées dans un segment de mémoire
partagée.

Si un client demande à qui est attribué un jeton, le serveur répond
avec l'adresse IP du client, ou un code en cas de jeton non associé.

Enfin, un jeton est considéré comme abandonné au bout d'un certain
délai. En conséquence, un client peut demander à rafraîchir
l'association d'un jeton avant l'expiration du délai. Pour ce faire,
il envoie un message au serveur avec le numéro du jeton à rafraîchir.
Si l'adresse IP concorde, le serveur doit réinitialiser la date
d'obtention du client.

\begin {enumerate}
    \item spécifiez le protocole que le serveur et les clients doivent
	utiliser, de telle sorte que vous puissiez utiliser le programme
	\texttt {telnet} comme client primitif~;
    \item rédigez le serveur, qui doit prendre en paramètre le
	nombre de jetons initialement disponibles~;
    \item rédigez le client d'obtention de jeton~;
    \item rédigez le client d'interrogation de jeton~;
    \item rédigez le client de rafraîchissement de jeton.
\end {enumerate}


\end {document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sujets d'examens
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\setlength {\parskip} {2mm}

%%% 1992/1993

% \examen {e9306} {Juin 1993}
% \examen {e9309} {Septembre 1993}

%%% 1993/1994

% \examen {e9405} {Mai 1994}
% \examen {e9406} {Juin 1994}
% \examen {e9409} {Septembre 1994}

%%% 1994/1995

% \examen {e9504} {Avril 1995}
% \examen {e9506} {Juin 1995}
% \examen {e9509} {Septembre 1995}

%%% 1995/1996

% \examen {e9511} {Novembre 1995 (Licence d'informatique et ISTY)}
% \examen {e9601} {Janvier 1996 (Licence d'informatique et ISTY)}
% \examen {e9604} {Avril 1996 (Licence d'informatique et ISTY)}
% \examen {e9606} {Juin 1996 (Licence d'informatique et ISTY)}
% \examen {e9609} {Septembre 1996 (Licence d'informatique et ISTY)}

%%% 1996/1997

\examen {el9611} {Novembre 1996 (Licence d'informatique)}
\examen {el9701} {Janvier 1997 (Licence d'informatique)}
\examen {el9703} {Mars 1997 (Licence d'informatique)}
\examen {el9706} {Juin 1997 (Licence d'informatique)}
\examen {el9709} {Septembre 1997 (Licence d'informatique)}

\examen {ei9611} {Novembre 1996 (ISTY 1)}
\examen {ei9701} {Janvier 1997 (ISTY 1)}
% \examen {ei9703} {Mars 1997 (ISTY 1)}
\examen {ei9706} {Juin 1997 (ISTY 1)}
% \examen {ei9709} {Septembre 1997 (ISTY 1)}

%%% 1997/1998

\examen {el9801} {Janvier 1998 (Licence d'informatique)}
\examen {el9806} {Juin 1998 (Licence d'informatique)}
\examen {el9809} {Septembre 1998 (Licence d'informatique)}

\examen {ei9711} {Novembre 1997 (ISTY 1)}
\examen {ei9801} {Janvier 1998 (ISTY 1)}
\examen {ei9805} {Mai 1998 (ISTY 1)}
\examen {ei9806} {Juin 1998 (ISTY 1)}
\examen {ei9809} {Septembre 1998 (ISTY 1)}


\end {document}
